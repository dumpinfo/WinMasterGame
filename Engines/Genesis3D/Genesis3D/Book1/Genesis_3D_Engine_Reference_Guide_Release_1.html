<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Heading 1</TITLE>
<META NAME="Template" CONTENT="C:\Program Files\Microsoft Office\Templates\Manuscript.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<B><FONT FACE="Arial Black" SIZE=5><P ALIGN="CENTER">&nbsp;</P>
<P ALIGN="CENTER">&nbsp;</P>
<P ALIGN="CENTER">&nbsp;</P>
<P ALIGN="CENTER">&nbsp;</P>
<P ALIGN="CENTER">&nbsp;</P>
</B></FONT><FONT FACE="Arial Black" SIZE=6><P ALIGN="CENTER"><A NAME="_Toc446558862">Vol. 1 Genesis3D Engine</P>
<P ALIGN="CENTER">Reference Guide</P>
<P ALIGN="CENTER">Release 1</A>.0</P>
</FONT><FONT FACE="Arial">
<P ALIGN="CENTER">by</P>
<P ALIGN="CENTER">David Dougher</P>
<P ALIGN="CENTER">January 25, 1999</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558863">Table of Contents</A></P>
</FONT><B><I><P>Introduction&#9;</B></I><A HREF="#_Toc454069773">*</A>
<B><I><P>GENESIS3D PUBLIC LICENSE&#9;</B></I><A HREF="#_Toc454069774">*</A></P><DIR>

<B><FONT SIZE=3><P>PREAMBLE&#9;</B></FONT><A HREF="#_Toc454069775">*</A></P>
<B><FONT SIZE=3><P>1. DEFINITIONS&#9;</B></FONT><A HREF="#_Toc454069776">*</A></P>
<B><FONT SIZE=3><P>2. SOURCE CODE LICENSE&#9;</B></FONT><A HREF="#_Toc454069777">*</A></P>
<B><FONT SIZE=2><P>2.1. The Eclipse Grant.&#9;</B></FONT><A HREF="#_Toc454069778">*</A></P>
<B><FONT SIZE=2><P>2.2. Contributor Grant.&#9;</B></FONT><A HREF="#_Toc454069779">*</A></P>
<B><FONT SIZE=2><P>2.3. Your Grant.&#9;</B></FONT><A HREF="#_Toc454069780">*</A></P>
<B><FONT SIZE=3><P>3. DISTRIBUTION OBLIGATIONS&#9;</B></FONT><A HREF="#_Toc454069781">*</A></P>
<B><FONT SIZE=2><P>3.1. Application of License to You.&#9;</B></FONT><A HREF="#_Toc454069782">*</A></P>
<B><FONT SIZE=2><P>3.2. Application of License to Eclipse.&#9;</B></FONT><A HREF="#_Toc454069783">*</A></P>
<B><FONT SIZE=2><P>3.3. Availability of Source Code.&#9;</B></FONT><A HREF="#_Toc454069784">*</A></P>
<B><FONT SIZE=2><P>3.4. Description of Modifications.&#9;</B></FONT><A HREF="#_Toc454069785">*</A></P>
<B><FONT SIZE=2><P>3.5. Intellectual Property Matters&#9;</B></FONT><A HREF="#_Toc454069786">*</A></P>
<B><FONT SIZE=2><P>3.6. Required Notices.&#9;</B></FONT><A HREF="#_Toc454069787">*</A></P>
<B><FONT SIZE=2><P>3.7. Distribution of Executable Versions.&#9;</B></FONT><A HREF="#_Toc454069788">*</A></P>
<B><FONT SIZE=2><P>3.8. Larger Works.&#9;</B></FONT><A HREF="#_Toc454069789">*</A></P>
<B><FONT SIZE=3><P>4. RESTRICTIONS&#9;</B></FONT><A HREF="#_Toc454069790">*</A></P>
<B><FONT SIZE=2><P>4.1. You agree to:&#9;</B></FONT><A HREF="#_Toc454069791">*</A></P>
<B><FONT SIZE=2><P>4.2. You may not:&#9;</B></FONT><A HREF="#_Toc454069792">*</A></P>
<B><FONT SIZE=3><P>5. INABILITY TO COMPLY DUE TO STATUTE OR&#9;</B></FONT><A HREF="#_Toc454069793">*</A></P>
<B><FONT SIZE=3><P>REGULATION&#9;</B></FONT><A HREF="#_Toc454069794">*</A></P>
<B><FONT SIZE=3><P>6. APPLICATION OF THIS LICENSE&#9;</B></FONT><A HREF="#_Toc454069795">*</A></P>
<B><FONT SIZE=3><P>7. VERSIONS OF THE LICENSE&#9;</B></FONT><A HREF="#_Toc454069796">*</A></P>
<B><FONT SIZE=2><P>7.1. New Versions.&#9;</B></FONT><A HREF="#_Toc454069797">*</A></P>
<B><FONT SIZE=2><P>7.2. Effect of New Versions.&#9;</B></FONT><A HREF="#_Toc454069798">*</A></P>
<B><FONT SIZE=3><P>8. DISCLAIMER OF WARRANTY&#9;</B></FONT><A HREF="#_Toc454069799">*</A></P>
<B><FONT SIZE=3><P>9. TERMINATION&#9;</B></FONT><A HREF="#_Toc454069800">*</A></P>
<B><FONT SIZE=3><P>10. LIMITATION OF LIABILITY&#9;</B></FONT><A HREF="#_Toc454069801">*</A></P>
<B><FONT SIZE=3><P>11. U.S. GOVERNMENT END USERS&#9;</B></FONT><A HREF="#_Toc454069802">*</A></P>
<B><FONT SIZE=3><P>12. MISCELLANEOUS&#9;</B></FONT><A HREF="#_Toc454069803">*</A></P>
<B><FONT SIZE=3><P>13. RESPONSIBILITY FOR CLAIMS&#9;</B></FONT><A HREF="#_Toc454069804">*</A></P>
<B><FONT SIZE=3><P>EXHIBIT A.&#9;</B></FONT><A HREF="#_Toc454069805">*</A></P>
<B><FONT SIZE=3><P>EXHIBIT B.&#9;</B></FONT><A HREF="#_Toc454069806">*</A></P></DIR>

<B><I><P>Game File Structure Layout&#9;</B></I><A HREF="#_Toc454069807">*</A></P><DIR>

<FONT FACE="Arial" SIZE=3><P>Directory of C:\Genesis3D*</FONT><B><FONT SIZE=3>&#9;</B></FONT><A HREF="#_Toc454069808">*</A></P>
<FONT FACE="Arial" SIZE=2><P>Directory of C:\Genesis3D\Actors*</FONT><B><FONT SIZE=2>&#9;</B></FONT><A HREF="#_Toc454069809">*</A></P>
<FONT FACE="Arial" SIZE=2><P>Directory of C:\Genesis\Bmp*</FONT><B><FONT SIZE=2>&#9;</B></FONT><A HREF="#_Toc454069810">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis\Bmp\Console*&#9;</FONT><A HREF="#_Toc454069811">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis\Bmp\Console\320x240*&#9;</FONT><A HREF="#_Toc454069812">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis\Bmp\Console\640x480*&#9;</FONT><A HREF="#_Toc454069813">*</A></P></DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\bmp\Explode*&#9;</FONT><A HREF="#_Toc454069814">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\bmp\Fx*&#9;</FONT><A HREF="#_Toc454069815">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\bmp\Menu*&#9;</FONT><A HREF="#_Toc454069816">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\bmp\Sbar*&#9;</FONT><A HREF="#_Toc454069817">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\bmp\SBar\320x240*&#9;</FONT><A HREF="#_Toc454069818">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\bmp\SBar\640x480*&#9;</FONT><A HREF="#_Toc454069819">*</A></P></DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\bmp\Weapon*&#9;</FONT><A HREF="#_Toc454069820">*</A></P></DIR>

<FONT FACE="Arial" SIZE=2><P>Directory of C:\Genesis3D\doc*</FONT><B><FONT SIZE=2>&#9;</B></FONT><A HREF="#_Toc454069821">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\doc\APIReference*&#9;</FONT><A HREF="#_Toc454069822">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\doc\editor*&#9;</FONT><A HREF="#_Toc454069823">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\doc\editor*&#9;</FONT><A HREF="#_Toc454069824">*</A></P></DIR>

<FONT FACE="Arial" SIZE=2><P>Directory of C:\Genesis3D\Genesis3D*</FONT><B><FONT SIZE=2>&#9;</B></FONT><A HREF="#_Toc454069825">*</A></P>
<FONT FACE="Arial" SIZE=2><P>Directory of C:\Genesis3D\include</FONT><B><FONT SIZE=2>&#9;</B></FONT><A HREF="#_Toc454069826">*</A></P>
<FONT FACE="Arial" SIZE=2><P>Directory of C:\Genesis3D\levels*</FONT><B><FONT SIZE=2>&#9;</B></FONT><A HREF="#_Toc454069827">*</A></P>
<FONT FACE="Arial" SIZE=2><P>Directory of C:\Genesis3D\lib*</FONT><B><FONT SIZE=2>&#9;</B></FONT><A HREF="#_Toc454069828">*</A></P>
<FONT FACE="Arial" SIZE=2><P>Directory of C:\Genesis3D\Objects*</FONT><B><FONT SIZE=2>&#9;</B></FONT><A HREF="#_Toc454069829">*</A></P>
<FONT FACE="Arial" SIZE=2><P>Directory of C:\Genesis3D\OpenSource*</FONT><B><FONT SIZE=2>&#9;</B></FONT><A HREF="#_Toc454069830">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\masm*&#9;</FONT><A HREF="#_Toc454069831">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\msdev60*&#9;</FONT><A HREF="#_Toc454069832">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\sdk*&#9;</FONT><A HREF="#_Toc454069833">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\sdk\DX6SDK*&#9;</FONT><A HREF="#_Toc454069834">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\sdk\Glide*&#9;</FONT><A HREF="#_Toc454069835">*</A></P></DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source&#9;</FONT><A HREF="#_Toc454069836">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Actor&#9;</FONT><A HREF="#_Toc454069837">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Bitmap&#9;</FONT><A HREF="#_Toc454069838">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Bitmap\Compression&#9;</FONT><A HREF="#_Toc454069839">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Engine&#9;</FONT><A HREF="#_Toc454069840">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers&#9;</FONT><A HREF="#_Toc454069841">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers\D3DDrv&#9;</FONT><A HREF="#_Toc454069842">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers\GlideDrv&#9;</FONT><A HREF="#_Toc454069843">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers\SoftDrv&#9;</FONT><A HREF="#_Toc454069844">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers\SoftDrv2&#9;</FONT><A HREF="#_Toc454069845">*</A></P></DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Engine\Logo&#9;</FONT><A HREF="#_Toc454069846">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Entities&#9;</FONT><A HREF="#_Toc454069847">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Font&#9;</FONT><A HREF="#_Toc454069848">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Math&#9;</FONT><A HREF="#_Toc454069849">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Physics&#9;</FONT><A HREF="#_Toc454069850">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Support&#9;</FONT><A HREF="#_Toc454069851">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\Vfile&#9;</FONT><A HREF="#_Toc454069852">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Source\World&#9;</FONT><A HREF="#_Toc454069853">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools*&#9;</FONT><A HREF="#_Toc454069854">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView*&#9;</FONT><A HREF="#_Toc454069855">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView\Doc*&#9;</FONT><A HREF="#_Toc454069856">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView\GenesisSDK*&#9;</FONT><A HREF="#_Toc454069857">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView\GenesisSDK\include&#9;</FONT><A HREF="#_Toc454069858">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView\GenesisSDK\lib*&#9;</FONT><A HREF="#_Toc454069859">*</A></P></DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView\Main&#9;</FONT><A HREF="#_Toc454069860">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView\res*&#9;</FONT><A HREF="#_Toc454069861">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView\Util&#9;</FONT><A HREF="#_Toc454069862">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\Exporters&#9;</FONT><A HREF="#_Toc454069863">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\Exporters\max2sdk*&#9;</FONT><A HREF="#_Toc454069864">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2&#9;</FONT><A HREF="#_Toc454069865">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\Deliver*&#9;</FONT><A HREF="#_Toc454069866">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\Doc*&#9;</FONT><A HREF="#_Toc454069867">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\Doc\html*&#9;</FONT><A HREF="#_Toc454069868">*</A></P></DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\GenesisSDK*&#9;</FONT><A HREF="#_Toc454069869">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\GenesisSDK\include&#9;</FONT><A HREF="#_Toc454069870">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\GenesisSDK\lib*&#9;</FONT><A HREF="#_Toc454069871">*</A></P></DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\res*&#9;</FONT><A HREF="#_Toc454069872">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\TypeParser&#9;</FONT><A HREF="#_Toc454069873">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\GBSPLib&#9;</FONT><A HREF="#_Toc454069874">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\GBSPLib\SDKShare*&#9;</FONT><A HREF="#_Toc454069875">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\GBSPLib\SDKShare\Include&#9;</FONT><A HREF="#_Toc454069876">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\GBSPLib\SDKShare\Lib*&#9;</FONT><A HREF="#_Toc454069877">*</A></P></DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\GPreview&#9;</FONT><A HREF="#_Toc454069878">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\GPreview\genesissdk*&#9;</FONT><A HREF="#_Toc454069879">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\GPreview\genesissdk\include&#9;</FONT><A HREF="#_Toc454069880">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\GPreview\genesissdk\lib*&#9;</FONT><A HREF="#_Toc454069881">*</A></P></DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor*&#9;</FONT><A HREF="#_Toc454069882">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\ActBuild&#9;</FONT><A HREF="#_Toc454069883">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\AStudio&#9;</FONT><A HREF="#_Toc454069884">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\AStudio\HLP*&#9;</FONT><A HREF="#_Toc454069885">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\AStudio\RES*&#9;</FONT><A HREF="#_Toc454069886">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\AStudio\Util&#9;</FONT><A HREF="#_Toc454069887">*</A></P></DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\common&#9;</FONT><A HREF="#_Toc454069888">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\Debug*&#9;</FONT><A HREF="#_Toc454069889">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\fmtactor&#9;</FONT><A HREF="#_Toc454069890">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\GenesisSDK*&#9;</FONT><A HREF="#_Toc454069891">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\GenesisSDK\include&#9;</FONT><A HREF="#_Toc454069892">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\GenesisSDK\lib*&#9;</FONT><A HREF="#_Toc454069893">*</A></P></DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\mkactor&#9;</FONT><A HREF="#_Toc454069894">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\mkbody&#9;</FONT><A HREF="#_Toc454069895">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\mkmotion&#9;</FONT><A HREF="#_Toc454069896">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\mop&#9;</FONT><A HREF="#_Toc454069897">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\Release*&#9;</FONT><A HREF="#_Toc454069898">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\Tpack*&#9;</FONT><A HREF="#_Toc454069899">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\TPack\GenesisSDK*&#9;</FONT><A HREF="#_Toc454069900">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\TPack\GenesisSDK\include&#9;</FONT><A HREF="#_Toc454069901">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\TPack\GenesisSDK\lib*&#9;</FONT><A HREF="#_Toc454069902">*</A></P></DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\TPack\res<I>*</I>&#9;</FONT><A HREF="#_Toc454069903">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\OpenSource\Tools\TPack\Source&#9;</FONT><A HREF="#_Toc454069904">*</A></P></DIR>
</DIR>

<FONT FACE="Arial" SIZE=2><P>Directory of C:\Genesis3D\Redist*</FONT><B><FONT SIZE=2>&#9;</B></FONT><A HREF="#_Toc454069905">*</A></P>
<FONT FACE="Arial" SIZE=2><P>Directory of C:\Genesis3D\src</FONT><B><FONT SIZE=2>&#9;</B></FONT><A HREF="#_Toc454069906">*</A></P><DIR>

<FONT SIZE=2><P>Directory of C:\Genesis3D\src\DrvMenu&#9;</FONT><A HREF="#_Toc454069907">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\src\FX&#9;</FONT><A HREF="#_Toc454069908">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\src\Game&#9;</FONT><A HREF="#_Toc454069909">*</A></P>
<FONT SIZE=2><P>Directory of C:\Genesis3D\src\Procedurals&#9;</FONT><A HREF="#_Toc454069910">*</A></P></DIR>

<FONT FACE="Arial" SIZE=2><P>Directory of C:\Genesis3D\Tools</FONT><B><FONT SIZE=2>&#9;</B></FONT><A HREF="#_Toc454069911">*</A></P>
<FONT FACE="Arial" SIZE=2><P>Directory of C:\Genesis3D\wav*</FONT><B><FONT SIZE=2>&#9;</B></FONT><A HREF="#_Toc454069912">*</A></P></DIR>

<B><I><P>Genesis3D API Documentation&#9;</B></I><A HREF="#_Toc454069913">*</A></P><DIR>

<B><FONT SIZE=3><P>Genesis3D API and Tools Documentation&#9;</B></FONT><A HREF="#_Toc454069914">*</A></P></DIR>

<B><I><P>Genesis3D Library Header Files&#9;</B></I><A HREF="#_Toc454069915">*</A></P><DIR>

<B><I><FONT SIZE=3><P>Include Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454069916">*</A></P>
<B><FONT SIZE=2><P>Actor.h&#9;</B></FONT><A HREF="#_Toc454069917">*</A></P>
<B><FONT SIZE=2><P>Basetype.h&#9;</B></FONT><A HREF="#_Toc454069918">*</A></P>
<B><FONT SIZE=2><P>Bitmap.h&#9;</B></FONT><A HREF="#_Toc454069919">*</A></P>
<B><FONT SIZE=2><P>Body.h&#9;</B></FONT><A HREF="#_Toc454069920">*</A></P>
<B><FONT SIZE=2><P>Errorlog.h&#9;</B></FONT><A HREF="#_Toc454069921">*</A></P>
<B><FONT SIZE=2><P>ExtBox.h&#9;</B></FONT><A HREF="#_Toc454069922">*</A></P>
<B><FONT SIZE=2><P>Font.h&#9;</B></FONT><A HREF="#_Toc454069923">*</A></P>
<B><FONT SIZE=2><P>Genesis.h&#9;</B></FONT><A HREF="#_Toc454069924">*</A></P>
<B><FONT SIZE=2><P>Getypes.h&#9;</B></FONT><A HREF="#_Toc454069925">*</A></P>
<B><FONT SIZE=2><P>Matrix33.h&#9;</B></FONT><A HREF="#_Toc454069926">*</A></P>
<B><FONT SIZE=2><P>Motion.h&#9;</B></FONT><A HREF="#_Toc454069927">*</A></P>
<B><FONT SIZE=2><P>Path.h&#9;</B></FONT><A HREF="#_Toc454069928">*</A></P>
<B><FONT SIZE=2><P>PhysicsJoint.h&#9;</B></FONT><A HREF="#_Toc454069929">*</A></P>
<B><FONT SIZE=2><P>PhysicsObject.h&#9;</B></FONT><A HREF="#_Toc454069930">*</A></P>
<B><FONT SIZE=2><P>PhysicsSystem.h&#9;</B></FONT><A HREF="#_Toc454069931">*</A></P>
<B><FONT SIZE=2><P>Pixelformat.h&#9;</B></FONT><A HREF="#_Toc454069932">*</A></P>
<B><FONT SIZE=2><P>Quatern.h&#9;</B></FONT><A HREF="#_Toc454069933">*</A></P>
<B><FONT SIZE=2><P>Ram.h&#9;</B></FONT><A HREF="#_Toc454069934">*</A></P>
<B><FONT SIZE=2><P>Vec3d.h&#9;</B></FONT><A HREF="#_Toc454069935">*</A></P>
<B><FONT SIZE=2><P>Vfile.h&#9;</B></FONT><A HREF="#_Toc454069936">*</A></P>
<B><FONT SIZE=2><P>Xform3d.h&#9;</B></FONT><A HREF="#_Toc454069937">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454069938">*</A></P>
<B><FONT SIZE=2><P>Camera.h&#9;</B></FONT><A HREF="#_Toc454069939">*</A></P>
<B><FONT SIZE=2><P>CSNetMgr.h&#9;</B></FONT><A HREF="#_Toc454069940">*</A></P>
<B><FONT SIZE=2><P>Genesis.h&#9;</B></FONT><A HREF="#_Toc454069941">*</A></P>
<B><FONT SIZE=2><P>GETypes.h&#9;</B></FONT><A HREF="#_Toc454069942">*</A></P>
<B><FONT SIZE=2><P>List.h&#9;</B></FONT><A HREF="#_Toc454069943">*</A></P>
<B><FONT SIZE=2><P>NetPlay.h&#9;</B></FONT><A HREF="#_Toc454069944">*</A></P>
<B><FONT SIZE=2><P>PtrTypes.h&#9;</B></FONT><A HREF="#_Toc454069945">*</A></P>
<B><FONT SIZE=2><P>Resource.h&#9;</B></FONT><A HREF="#_Toc454069946">*</A></P>
<B><FONT SIZE=2><P>Sound.h&#9;</B></FONT><A HREF="#_Toc454069947">*</A></P>
<B><FONT SIZE=2><P>Sound3D.h&#9;</B></FONT><A HREF="#_Toc454069948">*</A></P>
<B><FONT SIZE=2><P>Tclip.h&#9;</B></FONT><A HREF="#_Toc454069949">*</A></P>
<B><FONT SIZE=2><P>Timer.h&#9;</B></FONT><A HREF="#_Toc454069950">*</A></P>
<B><FONT SIZE=2><P>TSC.h&#9;</B></FONT><A HREF="#_Toc454069951">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Actor Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454069952">*</A></P>
<B><FONT SIZE=2><P>Actor.h&#9;</B></FONT><A HREF="#_Toc454069953">*</A></P>
<B><FONT SIZE=2><P>Body._h&#9;</B></FONT><A HREF="#_Toc454069954">*</A></P>
<B><FONT SIZE=2><P>Body.h&#9;</B></FONT><A HREF="#_Toc454069955">*</A></P>
<B><FONT SIZE=2><P>Bodyinst.h&#9;</B></FONT><A HREF="#_Toc454069956">*</A></P>
<B><FONT SIZE=2><P>Motion.h&#9;</B></FONT><A HREF="#_Toc454069957">*</A></P>
<B><FONT SIZE=2><P>Path.h&#9;</B></FONT><A HREF="#_Toc454069958">*</A></P>
<B><FONT SIZE=2><P>Pose.h&#9;</B></FONT><A HREF="#_Toc454069959">*</A></P>
<B><FONT SIZE=2><P>Puppet.h&#9;</B></FONT><A HREF="#_Toc454069960">*</A></P>
<B><FONT SIZE=2><P>QKFrame.h&#9;</B></FONT><A HREF="#_Toc454069961">*</A></P>
<B><FONT SIZE=2><P>strblock.h&#9;</B></FONT><A HREF="#_Toc454069962">*</A></P>
<B><FONT SIZE=2><P>tkarray.h&#9;</B></FONT><A HREF="#_Toc454069963">*</A></P>
<B><FONT SIZE=2><P>tkevents.h&#9;</B></FONT><A HREF="#_Toc454069964">*</A></P>
<B><FONT SIZE=2><P>vkframe.h&#9;</B></FONT><A HREF="#_Toc454069965">*</A></P>
<B><FONT SIZE=2><P>xfarray.h&#9;</B></FONT><A HREF="#_Toc454069966">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Bitmap Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454069967">*</A></P>
<B><FONT SIZE=2><P>bitmap._h&#9;</B></FONT><A HREF="#_Toc454069968">*</A></P>
<B><FONT SIZE=2><P>bitmap.h&#9;</B></FONT><A HREF="#_Toc454069969">*</A></P>
<B><FONT SIZE=2><P>bitmap_blitdata.h&#9;</B></FONT><A HREF="#_Toc454069970">*</A></P>
<B><FONT SIZE=2><P>bitmap_gamma.h&#9;</B></FONT><A HREF="#_Toc454069971">*</A></P>
<B><FONT SIZE=2><P>pixelformat.h&#9;</B></FONT><A HREF="#_Toc454069972">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Bitmap/Compression Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454069973">*</A></P>
<B><FONT SIZE=2><P>Palcreate.h&#9;</B></FONT><A HREF="#_Toc454069974">*</A></P>
<B><FONT SIZE=2><P>palettize.h&#9;</B></FONT><A HREF="#_Toc454069975">*</A></P>
<B><FONT SIZE=2><P>paloptimize.h&#9;</B></FONT><A HREF="#_Toc454069976">*</A></P>
<B><FONT SIZE=2><P>utility.h&#9;</B></FONT><A HREF="#_Toc454069977">*</A></P>
<B><FONT SIZE=2><P>yuv.h&#9;</B></FONT><A HREF="#_Toc454069978">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Engine Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454069979">*</A></P>
<B><FONT SIZE=2><P>Bitmaplist.h&#9;</B></FONT><A HREF="#_Toc454069980">*</A></P>
<B><FONT SIZE=2><P>engine.h&#9;</B></FONT><A HREF="#_Toc454069981">*</A></P>
<B><FONT SIZE=2><P>system.h&#9;</B></FONT><A HREF="#_Toc454069982">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Engine/DCommon Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454069983">*</A></P>
<B><FONT SIZE=2><P>Dcommon.h&#9;</B></FONT><A HREF="#_Toc454069984">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Engine/D3DDrv Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454069985">*</A></P>
<B><FONT SIZE=2><P>D3derr.h&#9;</B></FONT><A HREF="#_Toc454069986">*</A></P>
<B><FONT SIZE=2><P>D3d_fx.h&#9;</B></FONT><A HREF="#_Toc454069987">*</A></P>
<B><FONT SIZE=2><P>D3d_main.h&#9;</B></FONT><A HREF="#_Toc454069988">*</A></P>
<B><FONT SIZE=2><P>D3dcache.h&#9;</B></FONT><A HREF="#_Toc454069989">*</A></P>
<B><FONT SIZE=2><P>D3ddrv.h&#9;</B></FONT><A HREF="#_Toc454069990">*</A></P>
<B><FONT SIZE=2><P>DDMemMgr.h&#9;</B></FONT><A HREF="#_Toc454069991">*</A></P>
<B><FONT SIZE=2><P>Gspan.h&#9;</B></FONT><A HREF="#_Toc454069992">*</A></P>
<B><FONT SIZE=2><P>Pcache.h&#9;</B></FONT><A HREF="#_Toc454069993">*</A></P>
<B><FONT SIZE=2><P>Render.h&#9;</B></FONT><A HREF="#_Toc454069994">*</A></P>
<B><FONT SIZE=2><P>Scene.h&#9;</B></FONT><A HREF="#_Toc454069995">*</A></P>
<B><FONT SIZE=2><P>Thandle.h&#9;</B></FONT><A HREF="#_Toc454069996">*</A></P>
<B><FONT SIZE=2><P>Tpage.h&#9;</B></FONT><A HREF="#_Toc454069997">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Engine/Drivers/GlideDrv Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454069998">*</A></P>
<B><FONT SIZE=2><P>GCache.h&#9;</B></FONT><A HREF="#_Toc454069999">*</A></P>
<B><FONT SIZE=2><P>Glidedrv.h&#9;</B></FONT><A HREF="#_Toc454070000">*</A></P>
<B><FONT SIZE=2><P>Gmain.h&#9;</B></FONT><A HREF="#_Toc454070001">*</A></P>
<B><FONT SIZE=2><P>GMemMgr.h&#9;</B></FONT><A HREF="#_Toc454070002">*</A></P>
<B><FONT SIZE=2><P>GSpan.h&#9;</B></FONT><A HREF="#_Toc454070003">*</A></P>
<B><FONT SIZE=2><P>GThandle.h&#9;</B></FONT><A HREF="#_Toc454070004">*</A></P>
<B><FONT SIZE=2><P>Render.h&#9;</B></FONT><A HREF="#_Toc454070005">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Engine/Drivers/SoftDrv Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454070006">*</A></P>
<B><FONT SIZE=2><P>3dnowspan.h&#9;</B></FONT><A HREF="#_Toc454070007">*</A></P>
<B><FONT SIZE=2><P>dmodes.h&#9;</B></FONT><A HREF="#_Toc454070008">*</A></P>
<B><FONT SIZE=2><P>drawspan.h&#9;</B></FONT><A HREF="#_Toc454070009">*</A></P>
<B><FONT SIZE=2><P>Register.h&#9;</B></FONT><A HREF="#_Toc454070010">*</A></P>
<B><FONT SIZE=2><P>Render.h&#9;</B></FONT><A HREF="#_Toc454070011">*</A></P>
<B><FONT SIZE=2><P>sal.h&#9;</B></FONT><A HREF="#_Toc454070012">*</A></P>
<B><FONT SIZE=2><P>Scene.h&#9;</B></FONT><A HREF="#_Toc454070013">*</A></P>
<B><FONT SIZE=2><P>Softdrv.h&#9;</B></FONT><A HREF="#_Toc454070014">*</A></P>
<B><FONT SIZE=2><P>Span.h&#9;</B></FONT><A HREF="#_Toc454070015">*</A></P>
<B><FONT SIZE=2><P>System.h&#9;</B></FONT><A HREF="#_Toc454070016">*</A></P>
<B><FONT SIZE=2><P>x86span555.h&#9;</B></FONT><A HREF="#_Toc454070017">*</A></P>
<B><FONT SIZE=2><P>x86span565.h&#9;</B></FONT><A HREF="#_Toc454070018">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Engine/Drivers/SoftDrv2 Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454070019">*</A></P>
<B><FONT SIZE=2><P>CPUInfo.h&#9;</B></FONT><A HREF="#_Toc454070020">*</A></P>
<B><FONT SIZE=2><P>DDrawDisplay.h&#9;</B></FONT><A HREF="#_Toc454070021">*</A></P>
<B><FONT SIZE=2><P>DIBDisplay.h&#9;</B></FONT><A HREF="#_Toc454070022">*</A></P>
<B><FONT SIZE=2><P>display.h&#9;</B></FONT><A HREF="#_Toc454070023">*</A></P>
<B><FONT SIZE=2><P>DisplayModeInfo.h&#9;</B></FONT><A HREF="#_Toc454070024">*</A></P>
<B><FONT SIZE=2><P>DrawDecal.h&#9;</B></FONT><A HREF="#_Toc454070025">*</A></P>
<B><FONT SIZE=2><P>rop.h&#9;</B></FONT><A HREF="#_Toc454070026">*</A></P>
<B><FONT SIZE=2><P>Softdrv.h&#9;</B></FONT><A HREF="#_Toc454070027">*</A></P>
<B><FONT SIZE=2><P>Span.h&#9;</B></FONT><A HREF="#_Toc454070028">*</A></P>
<B><FONT SIZE=2><P>Span_AffineLoop.h&#9;</B></FONT><A HREF="#_Toc454070029">*</A></P>
<B><FONT SIZE=2><P>Span_Factory.h&#9;</B></FONT><A HREF="#_Toc454070030">*</A></P>
<B><FONT SIZE=2><P>SpanBuffer.h&#9;</B></FONT><A HREF="#_Toc454070031">*</A></P>
<B><FONT SIZE=2><P>SpanEdges_Factory.h&#9;</B></FONT><A HREF="#_Toc454070032">*</A></P>
<B><FONT SIZE=2><P>SWTHandle.h&#9;</B></FONT><A HREF="#_Toc454070033">*</A></P>
<B><FONT SIZE=2><P>traster.h&#9;</B></FONT><A HREF="#_Toc454070034">*</A></P>
<B><FONT SIZE=2><P>triangle.h&#9;</B></FONT><A HREF="#_Toc454070035">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Engine/Logo Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454070036">*</A></P>
<B><FONT SIZE=2><P>electric.h&#9;</B></FONT><A HREF="#_Toc454070037">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Engine/Entities Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454070038">*</A></P>
<B><FONT SIZE=2><P>Entities.h&#9;</B></FONT><A HREF="#_Toc454070039">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Engine/Font Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454070040">*</A></P>
<B><FONT SIZE=2><P>Font.h&#9;</B></FONT><A HREF="#_Toc454070041">*</A></P>
<B><FONT SIZE=2><P>wgClip.h&#9;</B></FONT><A HREF="#_Toc454070042">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Engine/Math Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454070043">*</A></P>
<B><FONT SIZE=2><P>Box.h&#9;</B></FONT><A HREF="#_Toc454070044">*</A></P>
<B><FONT SIZE=2><P>CRC32.h&#9;</B></FONT><A HREF="#_Toc454070045">*</A></P>
<B><FONT SIZE=2><P>ExtBox.h&#9;</B></FONT><A HREF="#_Toc454070046">*</A></P>
<B><FONT SIZE=2><P>QUATERN.H&#9;</B></FONT><A HREF="#_Toc454070047">*</A></P>
<B><FONT SIZE=2><P>VEC3D.H&#9;</B></FONT><A HREF="#_Toc454070048">*</A></P>
<B><FONT SIZE=2><P>XFORM3D.h&#9;</B></FONT><A HREF="#_Toc454070049">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Engine/Support Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454070050">*</A></P>
<B><FONT SIZE=2><P>BASETYPE.H&#9;</B></FONT><A HREF="#_Toc454070051">*</A></P>
<B><FONT SIZE=2><P>Errorlog.h&#9;</B></FONT><A HREF="#_Toc454070052">*</A></P>
<B><FONT SIZE=2><P>geAssert.h&#9;</B></FONT><A HREF="#_Toc454070053">*</A></P>
<B><FONT SIZE=2><P>LOG.H&#9;</B></FONT><A HREF="#_Toc454070054">*</A></P>
<B><FONT SIZE=2><P>MEMPOOL.H&#9;</B></FONT><A HREF="#_Toc454070055">*</A></P>
<B><FONT SIZE=2><P>RAM.H&#9;</B></FONT><A HREF="#_Toc454070056">*</A></P>
<B><I><FONT SIZE=3><P>OpenSource/Source/Engine/Vfile Subdirectory</I>&#9;</B></FONT><A HREF="#_Toc454070057">*</A></P>
<B><FONT SIZE=2><P>DirTree.h&#9;</B></FONT><A HREF="#_Toc454070058">*</A></P>
<B><FONT SIZE=2><P>FSDOS.H&#9;</B></FONT><A HREF="#_Toc454070059">*</A></P>
<B><FONT SIZE=2><P>FSMemory.h&#9;</B></FONT><A HREF="#_Toc454070060">*</A></P>
<B><FONT SIZE=2><P>FSVFS.h&#9;</B></FONT><A HREF="#_Toc454070061">*</A></P>
<B><FONT SIZE=2><P>VFILE._h&#9;</B></FONT><A HREF="#_Toc454070062">*</A></P>
<B><FONT SIZE=2><P>VFILE.h&#9;</B></FONT><A HREF="#_Toc454070063">*</A></P>
<B><FONT SIZE=2><P>Fog.h&#9;</B></FONT><A HREF="#_Toc454070064">*</A></P>
<B><FONT SIZE=2><P>Frustrum.h&#9;</B></FONT><A HREF="#_Toc454070065">*</A></P>
<B><FONT SIZE=2><P>GBSPFILE.H&#9;</B></FONT><A HREF="#_Toc454070066">*</A></P>
<B><FONT SIZE=2><P>LIGHT.h&#9;</B></FONT><A HREF="#_Toc454070067">*</A></P>
<B><FONT SIZE=2><P>Plane.h&#9;</B></FONT><A HREF="#_Toc454070068">*</A></P>
<B><FONT SIZE=2><P>Surface.h&#9;</B></FONT><A HREF="#_Toc454070069">*</A></P>
<B><FONT SIZE=2><P>Trace.h&#9;</B></FONT><A HREF="#_Toc454070070">*</A></P>
<B><FONT SIZE=2><P>User.h&#9;</B></FONT><A HREF="#_Toc454070071">*</A></P>
<B><FONT SIZE=2><P>Vis.h&#9;</B></FONT><A HREF="#_Toc454070072">*</A></P>
<B><FONT SIZE=2><P>WBitmap.h&#9;</B></FONT><A HREF="#_Toc454070073">*</A></P>
<B><FONT SIZE=2><P>World.h&#9;</B></FONT><A HREF="#_Toc454070074">*</A></P>
<FONT FACE="Arial"></DIR>
</P>
</FONT><B><I><P> </P>
</B></I><FONT FACE="Arial"><P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc446558895"><A NAME="_Toc454069773">Introduction</A></P>
</B></FONT><FONT FACE="Arial">
<P>&#9;First of all, I would like to thank the people at Eclipse Software for their kind permission to incorporate so much of their hard work, dedication and creativity into this book.  As a result, what you are reading is primarily a work of research, not creativity, on my part.  I am indebted to the people at Eclipse for allowing me to incorporate large amounts of their header files and rephrase much of their documentation.  I have attempted to add quite a bit of useful information and my own organizational spin, but wherever possible I have retained the content that Eclipse has presented on the theory that their descriptions often contain subtle nuances which are of importance in understanding the content, direction and focus of the engine component development efforts.</P>
<P>&#9;This reference work is the first in a series of books about the Genesis3D Engine from Eclipse Software.  This book is specifically about the Genesis3D Engine Release 1.0.  This book describes the layout of the Genesis3D files and subdirectories, as well as their contents. It continues with a complete listing of all the C and C++ header files in both the C:\Genesis3d\include subdirectory,  and the OpenSource\Source subdirectories.  These comprise all the C and C++ header files for the Genesis3D engine for developers who wish to create programs using the Genesis3D engine.</P>
<P>&#9;The second volume of this series addresses the Tools developed by Eclipse in support of the Genesis3D engine.  It contains much of the same material in the opening sections of this book and then goes on to cover the C and C++ header files in the C:\Genesis\OpenSource\Tools section and the example program in C:\Genesis\src.</P>
<P>&#9;The third volume contains a listing of the major function calls contained in the outer include directory - this directory contains all the function calls necessary to use the engine without modification.  Examination of this reference will point developers to functions which contain code they may need to modify for their own application, or for tools they are developing, or it can serve as a reference to those who wish to make a game without modifying the sources.</P>
<P>&#9;The fourth and fifth volumes are an introduction to using the Genesis3D Tools and the construction of a game using the Genesis3D engine.</P>
<P>&#9;This volume can be used both by persons who wish to modify the Genesis3D engine and those who do not.  Genesis3D is an OpenSource project with unique requirements, so the decision on whether you wish to use the engine as is, or modify it in some fashion should be made after a careful reading of the license agreement. </P>
<P>&#9; In essence the agreement states that if you wish to use the precreated libraries and link using the header files in the include directory there is no obligation on you and you may use the resultant software in any way you wish -- as long as you incorporate the Genesis logo at the beginning of your program to acknowledge Eclipse's contribution. If you wish to modify the source code to the engine you must either contribute the changes you have made to the Genesis community or purchase a $50,000.00 source code license from Eclipse.  I have enclosed a copy of this document so you can make an informed decision.<BR>
</P>
<P>&#9;I would also like to thank my wife Deborah for her support, for keeping the wolves at bay while I typed, and for bringing me endless cups of tea and english muffins as I worked on this book.  I hope that you will find this work useful.  </P>

<P>&#9;D. Dougher</P>
<P>&#9;May 1999</P>
</FONT><B><FONT FACE="Arial Black" SIZE=5><P ALIGN="CENTER">&nbsp;</P>
<P ALIGN="CENTER"><A NAME="_Toc454069774">GENESIS3D PUBLIC LICENSE</A></P>
</B></FONT><FONT FACE="Arial">
<P ALIGN="CENTER">Version 1.01</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069775">PREAMBLE</A></P>
</B></FONT><FONT FACE="Arial">
<P>Please read this license carefully before using Genesis3D. By </P>
<P>downloading and using Genesis3D, you are agreeing to be bound by the </P>
<P>terms of this license. If you do not or cannot agree to the terms of this </P>
<P>License, do not download or use Genesis3D.</P>

<P>This license is intended to make the source code of a state-of-the-art 3D </P>
<P>engine available to everyone who wants the opportunity to use and </P>
<P>contribute to a 3D engine.  Genesis3D is a commercial product.  It is not </P>
<P>in the public domain or "freeware" or "shareware".  By making the source </P>
<P>code available we are not giving it away or abandoning our right of </P>
<P>ownership.  By using Genesis3D you agree to be bound by the spirit and </P>
<P>the terms of this license.</P>

<P>This license permits you to use the Genesis3D SDK to create and sell </P>
<P>products.  You may also redistribute the Genesis3D SDK.  You may also </P>
<P>make modifications to the SDK and distribute them too.</P>

<P>If you modify the Genesis3D engine source, excerpt any portion of it, or if </P>
<P>you use a modified version of the engine source, you must make your </P>
<P>source code available for others to use under the same terms that we have </P>
<P>granted you.  This guarantees that modifications to the engine will be </P>
<P>available to everyone and the best modifications can become part of the </P>
<P>official Genesis3D release.  Your source code must be released </P>
<P>concurrent with releasing any executable built with Genesis3D.  If you do </P>
<P>not wish to make your source code available you must obtain a separate </P>
<P>license from Eclipse.</P>

<P>Gtest, the sample game, is specifically excluded from this requirement.  </P>
<P>Feel free to modify Gtest and use it in any way that benefits you.</P>

<P>If you use the original unmodified Eclipse-built binaries there is no </P>
<P>requirement for you to make your source code available.</P>

<P>You must display the original unmodified Genesis3D animated logo as </P>
<P>the first logo on startup of your product, demo or application.  You must </P>
<P>also prominently display the Genesis3D logo on any marketing materials, </P>
<P>advertising or packaging of your product.</P>

<P>These terms are good for the community because it makes the source of a </P>
<P>high-end 3D engine available to everyone and it encourages sharing of </P>
<P>improvements.  They are good for Eclipse because some companies will </P>
<P>opt to not share their source and will prefer to pay to license the engine </P>
<P>instead. These kinds of licenses will fund future Genesis3D development </P>
<P>and subsidize the free licenses that many people will enjoy.</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069776">1. DEFINITIONS</A></P>
</B></FONT><FONT FACE="Arial">
<P>1.1. ``Contributor'' means each entity that creates or contributes to </P>
<P>the creation of Modifications.</P>

<P>1.2. ``Contributor Version'' means the combination of the Original </P>
<P>Code, prior Modifications used by a Contributor, and the </P>
<P>Modifications made by that particular Contributor.</P>

<P>1.3. ``Covered Code'' means the Original Code or Modifications or </P>
<P>the combination of the Original Code and Modifications, in each case </P>
<P>including portions thereof, and any Source Code which duplicates, </P>
<P>enhances, modifies or replaces functionality of the Covered Code as </P>
<P>defined in Exhibit B.</P>
<P> </P>
<P>1.4. ``Electronic Distribution Mechanism'' means a mechanism </P>
<P>generally accepted in the software development community for the </P>
<P>electronic transfer of data.</P>

<P>1.5. ``Eclipse'' means Eclipse Entertainment, L.L.C.</P>

<P>1.6. ``Executable'' means Covered Code in any form other than </P>
<P>Source Code.</P>

<P>1.7. ``Larger Work'' means a work which combines Covered Code </P>
<P>or portions thereof with code not governed by the terms of this </P>
<P>License.</P>

<P>1.8. ``License'' means this document.</P>

<P>1.9. ``Modifications'' means any addition to or deletion from the </P>
<P>substance or structure of either the Original Code or any previous </P>
<P>Modifications. When Covered Code is released as a series of files, a </P>
<P>Modification is:</P>
<P>A. Any addition to or deletion from the contents of a file </P>
<P>containing Original Code or previous Modifications. </P>
<P>B. Any new file that contains any part of the Original Code </P>
<P>or previous Modifications.</P>

<P>1.10. ``Original Code'' means Source Code of computer software </P>
<P>code which is described in the Source Code notice required by </P>
<P>Exhibit A as Original Code, and which, at the time of its release </P>
<P>under this License is not already Covered Code governed by this </P>
<P>License.</P>

<P>1.11. ``Source Code'' means the preferred form of the Covered Code </P>
<P>for making modifications to it, including all modules it contains, plus </P>
<P>any associated interface definition files, scripts used to control </P>
<P>compilation and installation of an Executable, or a list of source code </P>
<P>differential comparisons against either the Original Code or another </P>
<P>well known, available Covered Code of the Contributor's choice. The </P>
<P>Source Code can be in a compressed or archival form, provided the </P>
<P>appropriate decompression or de-archiving software is widely </P>
<P>available for no charge.</P>
<P> </P>
<P>1.12. ``You'' means an individual or a legal entity exercising rights </P>
<P>under, and complying with all of the terms of, this License or a future </P>
<P>version of this License issued under Section 7.1. For legal entities, </P>
<P>``You'' includes any entity which controls, is controlled by, or is </P>
<P>under common control with You. For purposes of this definition, </P>
<P>``control'' means (a) the power, direct or indirect, to cause the </P>
<P>direction or management of such entity, whether by contract or </P>
<P>otherwise, or (b) ownership of fifty percent (50%) or more of the </P>
<P>outstanding shares or beneficial ownership of such entity. </P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069777">2. SOURCE CODE LICENSE</A></P>
</B></FONT><FONT FACE="Arial"><P> </P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069778">2.1. The Eclipse Grant.</A> </P>
</B></I></FONT><FONT FACE="Arial"><P>Eclipse hereby grants You a world-wide, fully paid, royalty-free, non-</P>
<P>exclusive license, subject to third party intellectual property claims: </P>
<P>(a) to use, reproduce, modify, display, perform, sublicense and </P>
<P>distribute the Original Code (or portions thereof) with or without </P>
<P>Modifications, or as part of a Larger Work; and </P>
<P>(b) under patents now or hereafter owned or controlled by </P>
<P>Eclipse, to make, have made, use and sell (``Utilize'') the </P>
<P>Original Code (or portions thereof), but solely to the extent that </P>
<P>any such patent is reasonably necessary to enable You to Utilize </P>
<P>the Original Code (or portions thereof) and not to any greater </P>
<P>extent that may be necessary to Utilize further Modifications or </P>
<P>combinations.</P>
<P> </P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069779">2.2. Contributor Grant.</A> </P>
</B></I></FONT><FONT FACE="Arial"><P>Each Contributor hereby grants You a world-wide, fully paid, </P>
<P>royalty-free, non-exclusive license, subject to third party intellectual </P>
<P>property claims:</P>
<P>(a) to use, reproduce, modify, display, perform, sublicense and </P>
<P>distribute the Modifications created by such Contributor (or </P>
<P>portions thereof) either on an unmodified basis, with other </P>
<P>Modifications, as Covered Code or as part of a Larger Work; and</P>
<P>(b) under patents now or hereafter owned or controlled by </P>
<P>Contributor, to Utilize the Contributor Version (or portions </P>
<P>thereof), but solely to the extent that any such patent is </P>
<P>reasonably necessary to enable You to Utilize the Contributor </P>
<P>Version (or portions thereof), and not to any greater extent that </P>
<P>may be necessary to Utilize further Modifications or </P>
<P>combinations.</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069780">2.3. Your Grant.</A> </P>
</B></I></FONT><FONT FACE="Arial"><P>You hereby grant to Eclipse a world-wide, fully paid, royalty-free, </P>
<P>non-exclusive license, subject to third party intellectual property </P>
<P>claims:</P>
<P>(a) to use, reproduce, modify, display, perform, sublicense and </P>
<P>distribute the Modifications created by You (or portions thereof) </P>
<P>either on an unmodified basis, with other Modifications, as </P>
<P>Covered Code or as part of a Larger Work; and</P>
<P>(b) under patents now or hereafter owned or controlled by You, </P>
<P>to Utilize the Modifications (or portions thereof), but solely to </P>
<P>the extent that any such patent is reasonably necessary to enable </P>
<P>Eclipse to Utilize the Modifications (or portions thereof), and not </P>
<P>to any greater extent that may be necessary to Utilize further </P>
<P>Modifications or combinations.</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069781">3. DISTRIBUTION OBLIGATIONS</A></P>
</B></FONT><FONT FACE="Arial"><P> </P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069782">3.1. Application of License to You.</A></P>
</B></I></FONT><FONT FACE="Arial"><P>The Modifications which You create or to which You contribute are </P>
<P>governed by the terms of this License, including without limitation </P>
<P>Section 2.2. The Source Code version of Covered Code may be </P>
<P>distributed only under the terms of this License or a future version of </P>
<P>this License released under Section 7.1, and You must include a copy </P>
<P>of this License with every copy of the Source Code You distribute. </P>
<P>You may not offer or impose any terms on any Source Code version </P>
<P>that alters or restricts the applicable version of this License or the </P>
<P>recipients' rights hereunder. However, You may include an additional </P>
<P>document offering the additional rights described in Section 3.6.</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069783">3.2. Application of License to Eclipse.</A></P>
</B></I></FONT><FONT FACE="Arial"><P>(a) Other Products.</P>
<P>Eclipse may include Covered Code in products other than </P>
<P>Genesis3D without such additional products becoming subject to </P>
<P>the terms of this License, and may license such additional </P>
<P>products on different terms from those contained in this License.</P>
<P>(b) Other Licenses.</P>
<P>Eclipse may license the Source Code including Modifications </P>
<P>incorporated therein, without such additional products becoming </P>
<P>subject to the terms of this License, and may license such </P>
<P>additional products on different terms from those contained in </P>
<P>this License.</P>
<P>(c) Other Releases.</P>
<P>Eclipse may create new releases of Genesis3D without such </P>
<P>releases becoming subject to the terms of this License. </P>
<P> </P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069784">3.3. Availability of Source Code.</A> </P>
</B></I></FONT><FONT FACE="Arial"><P>Any Modification which You create or to which You contribute must </P>
<P>be made available in Source Code form under the terms of this </P>
<P>License either on the same media as an Executable version or via an </P>
<P>accepted Electronic Distribution Mechanism to anyone to whom you </P>
<P>made an Executable version available; and if made available via </P>
<P>Electronic Distribution Mechanism, must remain available for at least </P>
<P>twelve (12) months after the date it initially became available, or at </P>
<P>least six (6) months after a subsequent version of that particular </P>
<P>Modification has been made available to such recipients. You are </P>
<P>responsible for ensuring that the Source Code version remains </P>
<P>available even if the Electronic Distribution Mechanism is maintained </P>
<P>by a third party.  Furthermore, the Source Code to the Modifications </P>
<P>You create or contribute must be delivered in fully compilable form </P>
<P>using commonly available tools.  If the tools used to compile the </P>
<P>Source Code are not commonly available You must also include the </P>
<P>tools, in Source Code and Executable forms, as part of the </P>
<P>Modifications.  Your Source Code must be delivered unencrypted, </P>
<P>uncloaked, unobscured and in human readable form.</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069785">3.4. Description of Modifications.</A> </P>
</B></I></FONT><FONT FACE="Arial"><P>You must cause all Covered Code to which you contribute to contain </P>
<P>a file documenting the changes You made to create that Covered </P>
<P>Code and the date of any change. You must include a prominent </P>
<P>statement that the Modification is derived, directly or indirectly, from </P>
<P>Original Code provided by Eclipse in (a) the Source Code, and (b) in </P>
<P>any notice in an Executable version or related documentation in </P>
<P>which You describe the origin or ownership of the Covered Code. </P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069786">3.5. Intellectual Property Matters</A> </P>
</B></I></FONT><FONT FACE="Arial"><P>(a) Third Party Claims. </P>
<P>If You have knowledge that a party claims an intellectual </P>
<P>property right in particular functionality or code (or its utilization </P>
<P>under this License), you must include a text file with the source </P>
<P>code distribution titled ``LEGAL'' which describes the claim and </P>
<P>the party making the claim in sufficient detail that a recipient will </P>
<P>know whom to contact. If you obtain such knowledge after You </P>
<P>make Your Modification available as described in Section 3.3, </P>
<P>You shall promptly modify the LEGAL file in all copies You </P>
<P>make available thereafter and shall take other steps (such as </P>
<P>notifying appropriate mailing lists or newsgroups) reasonably </P>
<P>calculated to inform those who received the Covered Code that </P>
<P>new knowledge has been obtained. </P>
<P>(b) Contributor APIs. </P>
<P>If Your Modification is an application programming interface </P>
<P>and You own or control patents which are reasonably necessary </P>
<P>to implement that API, you must also include this information in </P>
<P>the LEGAL file. </P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069787">3.6. Required Notices.</A> </P>
</B></I></FONT><FONT FACE="Arial"><P>You must duplicate the notice in Exhibit A in each file of the Source </P>
<P>Code, and this License in any documentation for the Source Code, </P>
<P>where You describe recipients' rights relating to Covered Code. If </P>
<P>You created one or more Modification(s), You may add your name as </P>
<P>a Contributor to the notice described in Exhibit A. If it is not </P>
<P>possible to put such notice in a particular Source Code file due to its </P>
<P>structure, then you must include such notice in a location (such as a </P>
<P>relevant directory file) where a user would be likely to look for such a </P>
<P>notice. You may choose to offer, and to charge a fee for, warranty, </P>
<P>support, indemnity or liability obligations to one or more recipients </P>
<P>of Covered Code. However, You may do so only on Your own </P>
<P>behalf, and not on behalf of Eclipse or any Contributor. You must </P>
<P>make it absolutely clear that any such warranty, support, indemnity or </P>
<P>liability obligation is offered by You alone, and You hereby agree to </P>
<P>indemnify Eclipse and every Contributor for any liability incurred by </P>
<P>Eclipse or such Contributor as a result of warranty, support, </P>
<P>indemnity or liability terms You offer.</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069788">3.7. Distribution of Executable Versions.</A> </P>
</B></I></FONT><FONT FACE="Arial"><P>You may distribute Covered Code in Executable form only if the </P>
<P>requirements of Section 3.1-3.6 have been met for that Covered </P>
<P>Code, and if You include a notice stating that the Source Code </P>
<P>version of the Covered Code is available under the terms of this </P>
<P>License, including a description of how and where You have fulfilled </P>
<P>the obligations of Section 3.3. The notice must be conspicuously </P>
<P>included in any notice in an Executable version, related </P>
<P>documentation or collateral in which You describe recipients' rights </P>
<P>relating to the Covered Code. You may distribute the Executable </P>
<P>version of Covered Code under a license of Your choice, which may </P>
<P>contain terms different from this License, provided that You are in </P>
<P>compliance with the terms of this License and that the license for the </P>
<P>Executable version does not attempt to limit or alter the recipient's </P>
<P>rights in the Source Code version from the rights set forth in this </P>
<P>License. If You distribute the Executable version under a different </P>
<P>license You must make it absolutely clear that any terms which differ </P>
<P>from this License are offered by You alone, not by Eclipse or any </P>
<P>Contributor. You hereby agree to indemnify Eclipse and every </P>
<P>Contributor for any liability incurred by Eclipse or such Contributor </P>
<P>as a result of any such terms You offer. </P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069789">3.8. Larger Works.</A> </P>
</B></I></FONT><FONT FACE="Arial"><P>You may create a Larger Work by combining Covered Code with </P>
<P>other code not governed by the terms of this License and distribute </P>
<P>the Larger Work as a single product. In such a case, You must make </P>
<P>sure the requirements of this License are fulfilled for the Covered </P>
<P>Code. </P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069790">4. RESTRICTIONS</A></P>
</B></FONT><FONT FACE="Arial"><P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069791">4.1. You agree to:</A></P>
</B></I></FONT><FONT FACE="Arial"><P>(a) display the original, unmodified Genesis3D animated logo as the </P>
<P>first logo on startup of your product, demo or application;</P>
<P>(b) prominently display the Genesis3D logo on any marketing </P>
<P>materials, advertising or packaging of your product, demo or </P>
<P>application;</P>
<P>(c) distribute the Covered Code to third parties who agree to be </P>
<P>bound by these terms and conditions;</P>
<P>(d) make reasonable efforts to discontinue distribution of the Covered </P>
<P>Code upon Eclipse's release of an update, upgrade or new version of </P>
<P>the Covered Code and to make reasonable efforts to distribute such </P>
<P>updates, upgrades or new versions to your customers who have </P>
<P>received the Covered Code herein;</P>
<P>(e) be solely responsible for any update or support obligation or other </P>
<P>liability which may arise from your distribution of the Covered Code.</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069792">4.2. You may not:</A></P>
</B></I></FONT><FONT FACE="Arial"><P>(a) remove, alter, obscure, or modify in any way the appearance or </P>
<P>operation of the Genesis3D logo;</P>
<P>(b) copy the Covered Code, in whole or in part, except as provided in </P>
<P>this License;</P>
<P>(c) make any statement that your product is "certified," or that its </P>
<P>performance is guaranteed, by Eclipse.</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069793">5. INABILITY TO COMPLY DUE TO STATUTE OR</A> </P>
<P><A NAME="_Toc454069794">REGULATION</A></P>
</B></FONT><FONT FACE="Arial">
<P>If it is impossible for You to comply with any of the terms of this </P>
<P>License with respect to some or all of the Covered Code due to </P>
<P>statute or regulation then You must: (a) comply with the terms of this </P>
<P>License to the maximum extent possible; and (b) describe the </P>
<P>limitations and the code they affect. Such description must be </P>
<P>included in the LEGAL file described in Section 3.5 and must be </P>
<P>included with all distributions of the Source Code. Except to the </P>
<P>extent prohibited by statute or regulation, such description must be </P>
<P>sufficiently detailed for a recipient of ordinary skill to be able to </P>
<P>understand it. </P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069795">6. APPLICATION OF THIS LICENSE</A></P>
</B></FONT><FONT FACE="Arial">
<P>This License applies to code to which Eclipse has attached the notice </P>
<P>in Exhibit A, and to related Covered Code.</P>
<P> </P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069796">7. VERSIONS OF THE LICENSE</A></P>
</B></FONT><FONT FACE="Arial"><P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069797">7.1. New Versions.</A> </P>
</B></I></FONT><FONT FACE="Arial"><P>Eclipse may publish revised and/or new versions of the License from </P>
<P>time to time. Each version will be given a distinguishing version </P>
<P>number.</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069798">7.2. Effect of New Versions.</A> </P>
</B></I></FONT><FONT FACE="Arial"><P>Once Covered Code has been published under a particular version of </P>
<P>the License, You may always continue to use it under the terms of </P>
<P>that version. You may also choose to use such Covered Code under </P>
<P>the terms of any subsequent version of the License published by </P>
<P>Eclipse. No one other than Eclipse has the right to modify the terms </P>
<P>applicable to Covered Code created under this License. </P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069799">8. DISCLAIMER OF WARRANTY</A></P>
</B></FONT><FONT FACE="Arial">
<P>COVERED CODE IS PROVIDED UNDER THIS LICENSE ON </P>
<P>AN ``AS IS'' BASIS, WITHOUT WARRANTY OF ANY KIND, </P>
<P>EITHER EXPRESSED OR IMPLIED, INCLUDING, WITHOUT </P>
<P>LIMITATION, WARRANTIES THAT THE COVERED CODE IS </P>
<P>FREE OF DEFECTS, MERCHANTABLE, FIT FOR A </P>
<P>PARTICULAR PURPOSE OR NON-INFRINGING. THE ENTIRE </P>
<P>RISK AS TO THE QUALITY AND PERFORMANCE OF THE </P>
<P>COVERED CODE IS WITH YOU. SHOULD ANY COVERED </P>
<P>CODE PROVE DEFECTIVE IN ANY RESPECT, YOU (NOT </P>
<P>ECLIPSE OR ANY OTHER CONTRIBUTOR) ASSUME THE </P>
<P>COST OF ANY NECESSARY SERVICING, REPAIR OR </P>
<P>CORRECTION. THIS DISCLAIMER OF WARRANTY </P>
<P>CONSTITUTES AN ESSENTIAL PART OF THIS LICENSE. NO </P>
<P>USE OF ANY COVERED CODE IS AUTHORIZED HEREUNDER </P>
<P>EXCEPT UNDER THIS DISCLAIMER. </P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069800">9. TERMINATION</A></P>
</B></FONT><FONT FACE="Arial">
<P>This License and the rights granted hereunder will terminate </P>
<P>automatically if You fail to comply with terms herein and fail to cure </P>
<P>such breach within 30 days of becoming aware of the breach. All </P>
<P>sublicenses to the Covered Code which are properly granted shall </P>
<P>survive any termination of this License. Provisions which, by their </P>
<P>nature, must remain in effect beyond the termination of this License </P>
<P>shall survive.</P>
<P> </P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069801">10. LIMITATION OF LIABILITY</A></P>
</B></FONT><FONT FACE="Arial">
<P>UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL </P>
<P>THEORY, WHETHER TORT (INCLUDING NEGLIGENCE), </P>
<P>CONTRACT, OR OTHERWISE, SHALL ECLIPSE, ANY OTHER </P>
<P>CONTRIBUTOR, OR ANY DISTRIBUTOR OF COVERED </P>
<P>CODE, OR ANY SUPPLIER OF ANY OF SUCH PARTIES, BE </P>
<P>LIABLE TO YOU OR ANY OTHER PERSON FOR ANY </P>
<P>INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL </P>
<P>DAMAGES OF ANY CHARACTER INCLUDING, WITHOUT </P>
<P>LIMITATION, DAMAGES FOR LOSS OF GOODWILL, WORK </P>
<P>STOPPAGE, COMPUTER FAILURE OR MALFUNCTION, OR </P>
<P>ANY AND ALL OTHER COMMERCIAL DAMAGES OR </P>
<P>LOSSES, EVEN IF SUCH PARTY SHALL HAVE BEEN </P>
<P>INFORMED OF THE POSSIBILITY OF SUCH DAMAGES. THIS </P>
<P>LIMITATION OF LIABILITY SHALL NOT APPLY TO </P>
<P>LIABILITY FOR DEATH OR PERSONAL INJURY RESULTING </P>
<P>FROM SUCH PARTY'S NEGLIGENCE TO THE EXTENT </P>
<P>APPLICABLE LAW PROHIBITS SUCH LIMITATION. SOME </P>
<P>JURISDICTIONS DO NOT ALLOW THE EXCLUSION OR </P>
<P>LIMITATION OF INCIDENTAL OR CONSEQUENTIAL </P>
<P>DAMAGES, SO THAT EXCLUSION AND LIMITATION MAY </P>
<P>NOT APPLY TO YOU.</P>

<P>INDEMNIFICATION:  YOU SHALL INDEMNIFY, HOLD </P>
<P>HARMLESS, AND DEFEND ECLIPSE AND IT SUPPLIERS </P>
<P>FROM AND AGAINST ANY CLAIMS OR LAWSUITS, </P>
<P>INCLUDING ATTORNEY'S FEES, THAT ARISE OR RESULT </P>
<P>FROM YOUR USE OR DISTRIBUTION OF ANY PRODUCT </P>
<P>INCORPORATING THE COVERED CODE IN WHOLE OR IN </P>
<P>PART.</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069802">11. U.S. GOVERNMENT END USERS</A></P>
</B></FONT><FONT FACE="Arial">
<P>The Covered Code is a ``commercial item,'' as that term is defined in </P>
<P>48 C.F.R. 2.101 (Oct. 1995), consisting of ``commercial computer </P>
<P>software'' and ``commercial computer software documentation,'' as </P>
<P>such terms are used in 48 C.F.R. 12.212 (Sept. 1995). Consistent with </P>
<P>48 C.F.R. 12.212 and 48 C.F.R. 227.7202-1 through 227.7202-4 </P>
<P>(June 1995), all U.S. Government End Users acquire Covered Code </P>
<P>with only those rights set forth herein.</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069803">12. MISCELLANEOUS</A></P>
</B></FONT><FONT FACE="Arial">
<P>This License represents the complete agreement concerning subject </P>
<P>matter hereof. If any provision of this License is held to be </P>
<P>unenforceable, such provision shall be reformed only to the extent </P>
<P>necessary to make it enforceable.  This License is governed by the </P>
<P>laws of the State of Texas and the United States, including patent and </P>
<P>copyright laws.  Any claim arising out of this License will be brought </P>
<P>in Travis County, Texas.</P>

<P>The application of the United Nations Convention on Contracts for </P>
<P>the International Sale of Goods is expressly excluded. Any law or </P>
<P>regulation which provides that the language of a contract shall be </P>
<P>construed against the drafter shall not apply to this License. </P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069804">13. RESPONSIBILITY FOR CLAIMS</A></P>
</B></FONT><FONT FACE="Arial">
<P>Except in cases where another Contributor has failed to comply with </P>
<P>Section 3.5, You are responsible for damages arising, directly or </P>
<P>indirectly, out of Your utilization of rights under this License, based </P>
<P>on the number of copies of Covered Code you made available, the </P>
<P>revenues you received from utilizing such rights, and other relevant </P>
<P>factors. You agree to work with affected parties to distribute </P>
<P>responsibility on an equitable basis.</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069805">EXHIBIT A.</A> </P>
</B></FONT><FONT FACE="Arial">
<P>``The contents of this file are subject to the Genesis3D Public </P>
<P>License Version 1.01 (the "License"); you may not use this file </P>
<P>except in compliance with the License. You may obtain a copy of the </P>
<P>License at http://www.genesis3d.com</P>
<P>Software distributed under the License is distributed on an "AS IS" </P>
<P>basis, WITHOUT WARRANTY OF ANY KIND, either express or </P>
<P>implied. See the License for the specific language governing rights </P>
<P>and limitations under the License. </P>
<P>The Original Code is Genesis3D, released March 25, 1999. </P>
<P>Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights </P>
<P>Reserved. </P>
<P>Contributor(s): ______________________________________.'' </P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069806">EXHIBIT B.</A> </P>
</B></FONT><FONT FACE="Arial">
<P>Functionality of the Covered Code includes:</P>

<P>(a) Representation and rendering of 2D and 3D images, objects, </P>
<P>characters and scenes;</P>
<P>(b) Collision detection;</P>
<P>(c) Artificial Intelligence (AI), including path finding, planning and </P>
<P>movement;</P>
<P>(d) Network and internet communications;</P>
<P>(e) Data compression;</P>
<P>(f) Streaming data over a network, modem, or the internet;</P>
<P>(g) Client/server architecture;</P>
<P>(h) Physics simulation;</P>
<P>(i) Creation and editing of world geometry;</P>
<P>(j) Character animation, including motion interpolation, motion </P>
<P>planning, collision, and inverse kinematics.</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc454069807">Game File Structure Layout</A></A></P>
</B></FONT><I><FONT FACE="Arial"><P>&nbsp;</P>
</I></FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc446558897"><A NAME="_Toc454069808">Directory of C:\Genesis3D*</A> </P>
</FONT><FONT FACE="Arial"><P>Below is the basic subdirectory layout for the Genesis3D system as delivered by Eclipse.  The system was unpacked taking all the standard defaults.  As a result there are several subdirectories which are repeated in the Tools section.  This duplication was chosen by Eclipse deliberately in order to shorten compile times and create benchmark milestones more easily.</P>

<P>Each subdirectory is indented in the Table of Contents to give you an idea of its position in the tree.  The full path is shown to give you an idea where it is and a brief explanation of the contents of each subdirectory is also given.  Not all subdirectories have source code files, many contain data, object code or executables.  </P>
<I>
<P>* Subdirectories that do <U>not</U> have header or code files are marked with an asterisk.</I>  </P>

<P>This first directory contains the executable and help files that make up the example game Gtest and the Genesis3D tools (ActBuild, ActView, Astudio, Gedit, and Tpack.  There are also two files, keyexp.dle and nfoexp.dle, which can be plugged into 3D Studio Max to export the .ACT file models used by the Genesis3D engine.</P>

</FONT><B><FONT FACE="Courier New" SIZE=2><P>Total Files Listed:</P>
<P>            1616 File(s)     73,636,424 bytes</P>
</B></FONT><FONT FACE="Courier New" SIZE=1>
<P>Directory of C:\Genesis3D</P>

<P>05/17/99  06:38p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:38p        &lt;DIR&gt;          ..</P>
<P>03/25/99  01:52p               495,616 ActBuild.exe</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          Actors</P>
<P>09/16/98  11:25a                   663 ActView.cnt</P>
<P>05/11/99  03:01p               548,864 ActView.exe</P>
<P>09/16/98  03:34p                16,112 ActView.hlp</P>
<P>03/25/99  01:55p               667,648 AStudio.exe</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          bmp</P>
<P>05/14/99  09:06p               110,592 D3DDrv.dll</P>
<P>05/11/99  04:58p                    22 demo.ini</P>
<P>05/14/99  10:23p             1,150,475 demo2.dem</P>
<P>05/14/99  11:07p             2,047,123 demo3.dem</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          doc</P>
<P>07/10/98  09:52a                15,252 g3dlogo.gif</P>
<P>05/11/99  01:08a               274,432 GBSPLib.dll</P>
<P>07/03/98  01:28p                 1,292 gedit.cnt</P>
<P>05/12/99  03:22p               901,120 gedit.exe</P>
<P>09/02/98  07:03p                36,528 GEDIT.HLP</P>
<P>01/20/99  10:33p                 1,481 gedit.ini</P>
<P>05/14/99  09:09p               659,456 Genesis.dll</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          Genesis3D</P>
<P>05/14/99  09:05p                73,728 GlideDrv.dll</P>
<P>05/17/99  06:38p                 1,120 GMenu.Dat</P>
<P>05/15/99  12:21a               786,432 GTest.exe</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          include</P>
<P>03/24/99  10:22a                77,824 keyexp.dle</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          levels</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          lib</P>
<P>07/10/98  09:59a                   547 local.html</P>
<P>03/24/99  10:20a                81,920 nfoexp.dle</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          OpenSource</P>
<P>05/10/99  04:59p                   175 readme.txt</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          Redist</P>
<P>05/14/99  09:05p               237,568 SoftDrv.dll</P>
<P>05/14/99  09:07p               167,936 softdrv2.dll</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          src</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          Tools</P>
<P>03/25/99  01:56p               126,976 tpack.exe</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          wav</P>
<P>              40 File(s)      8,480,902 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069809">Directory of C:\Genesis3D\Actors*</A></P>
</FONT><FONT FACE="Arial"><P>The Actors subdirectory is a repository for ACT files, Genesis3D 's unique file format for animated models.  These .ACT files are used in the example game GTest, and are not essential to the engine itself.</P>
</FONT><FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\Actors</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>11/11/98  12:09p                23,520 armor.act</P>
<P>11/15/98  07:46p               313,194 dema.act</P>
<P>11/10/98  03:21p                41,824 glaunch.act</P>
<P>11/17/98  01:17a                24,036 grenade.act</P>
<P>11/11/98  12:09p               134,736 medkit.act</P>
<P>11/10/98  03:21p                74,940 rlaunch.act</P>
<P>11/16/98  04:09p                24,452 rocket.act</P>
<P>11/17/98  01:17a                 4,596 sammo.act</P>
<P>11/10/98  03:22p                52,296 shredder.act</P>
<P>11/15/98  08:30p               470,799 turret.act</P>
<P>              12 File(s)      1,164,393 bytes</P>
</FONT><FONT FACE="Arial"><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069810">Directory of C:\Genesis\Bmp*</A></P>
</FONT><FONT FACE="Arial"><P>The Bmp subdirectory contains several additional subdirectories that hold bitmap graphic files used in the GTest example game.  The graphics are only required for the sample game and are not needed elsewhere.</P>
</FONT><FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\bmp</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>12/09/98  10:10a                 2,167 BOLT.bmp</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          Console</P>
<P>04/07/99  06:16p                 5,174 CORONA.bmp</P>
<P>04/06/99  04:31p                12,344 CORONA_A.bmp</P>
<P>12/09/98  10:10a                 1,367 CURSOR.bmp</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          Explode</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          Fx</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          Menu</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          SBar</P>
<P>12/09/98  10:10a                40,913 SFONT1.bmp</P>
<P>12/09/98  10:10a                40,913 SFONT2.bmp</P>
<P>12/09/98  10:10a                 5,303 SPOT.bmp</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          Weapon</P>
<P>              15 File(s)        108,181 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069811">Directory of C:\Genesis\Bmp\Console*</A></P>
</FONT><FONT FACE="Arial"><P>The Console subdirectory contains a two subdirectories which hold the bmp files for the console display at two different resolutions for the GTest application.  If you create a game and console in a different resolution to expand Gtest, you should follow the pattern and place the textures here in a new subdirectory.  The console subdirectories are not essential to the engine itself.</P>
</FONT><FONT FACE="Courier New" SIZE=2>
</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\bmp\Console</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          320x240</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          640x480</P>
<P>               4 File(s)              0 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069812">Directory of C:\Genesis\Bmp\Console\320x240*</A></P>
</FONT><FONT FACE="Arial"><P>There are two bmp graphic files here.  The first contains the font table used for the console, the second is the background texture.  It is created for a screen size of 320x240.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\bmp\Console\320x240</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>12/10/98  12:31p                17,719 CONSOLE.BMP</P>
<P>12/10/98  12:31p                 5,565 FONT.BMP</P>
<P>               4 File(s)         23,284 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069813">Directory of C:\Genesis\Bmp\Console\640x480*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the same graphics files as those above but they are intended for a screen resolution of 640x480.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\bmp\Console\640x480</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>12/10/98  12:20p                17,719 CONSOLE.BMP</P>
<P>12/10/98  12:20p                26,703 FONT.BMP</P>
<P>               4 File(s)         44,422 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069814">Directory of C:\Genesis3D\bmp\Explode*</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains a series of bmp files that when played rapidly create a colored graphical explosion and a grey smoky background.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\bmp\Explode</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>12/10/98  07:15p                 2,167 1EXP01.BMP</P>
<P>12/10/98  07:15p                 2,167 1EXP02.BMP</P>
<P>12/10/98  07:15p                 2,167 1EXP03.BMP</P>
<P>12/10/98  07:15p                 2,167 1EXP04.BMP</P>
<P>12/10/98  07:15p                 2,167 1EXP05.BMP</P>
<P>12/10/98  07:15p                 2,167 1EXP06.BMP</P>
<P>12/10/98  07:15p                 2,167 A_1EXP01.BMP</P>
<P>12/10/98  07:15p                 2,167 A_1EXP02.BMP</P>
<P>12/10/98  07:15p                 2,167 A_1EXP03.BMP</P>
<P>12/10/98  07:15p                 2,167 A_1EXP04.BMP</P>
<P>12/10/98  07:15p                 2,167 A_1EXP05.BMP</P>
<P>12/10/98  07:15p                 2,167 A_1EXP06.BMP</P>
<P>              14 File(s)         26,004 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069815">Directory of C:\Genesis3D\bmp\Fx*</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains three special effects.  The first is a black and white explosion with a gradual smoke dissipation.  The second is a particle explosion.  The third is a colored explosion that expands outward and turns smoky and dissipates.  The texture size for these shots is larger than for those in the previous subdirectory.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\bmp\Fx</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>12/10/98  07:13p                 5,303 A_SMK01.BMP</P>
<P>12/10/98  07:13p                 5,303 A_SMK02.BMP</P>
<P>12/10/98  07:13p                 5,303 A_SMK03.BMP</P>
<P>12/10/98  07:13p                 5,303 A_SMK04.BMP</P>
<P>12/10/98  07:13p                 5,303 a_smk05.bmp</P>
<P>12/10/98  07:13p                 5,303 A_SMK06.BMP</P>
<P>12/10/98  07:13p                 5,303 A_SMK07.BMP</P>
<P>12/10/98  07:13p                 5,303 A_SMK08.BMP</P>
<P>12/10/98  07:13p                 5,303 A_SMK09.BMP</P>
<P>12/10/98  07:13p                 5,303 A_SMK10.BMP</P>
<P>12/10/98  07:13p                 5,303 PARTI1.BMP</P>
<P>12/10/98  07:13p                 5,303 PARTI2.BMP</P>
<P>12/10/98  07:13p                 5,303 PARTI3.BMP</P>
<P>12/10/98  07:13p                 5,303 PARTI4.BMP</P>
<P>12/10/98  07:13p                 5,303 PARTI5.BMP</P>
<P>12/10/98  07:13p                 5,303 PARTI6.BMP</P>
<P>12/10/98  07:13p                 5,303 PARTI7.BMP</P>
<P>12/10/98  07:13p                 5,303 PARTI8.BMP</P>
<P>12/10/98  07:13p                 5,303 SMOKE_01.BMP</P>
<P>12/10/98  07:13p                 5,303 SMOKE_02.BMP</P>
<P>12/10/98  07:13p                 5,303 SMOKE_03.BMP</P>
<P>12/10/98  07:13p                 5,303 SMOKE_04.BMP</P>
<P>12/10/98  07:13p                 5,303 smoke_05.bmp</P>
<P>12/10/98  07:13p                 5,303 SMOKE_06.BMP</P>
<P>12/10/98  07:13p                 5,303 SMOKE_07.BMP</P>
<P>12/10/98  07:13p                 5,303 SMOKE_08.BMP</P>
<P>12/10/98  07:13p                 5,303 SMOKE_09.BMP</P>
<P>12/10/98  07:13p                 5,303 SMOKE_10.BMP</P>
<P>              30 File(s)        148,484 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069816">Directory of C:\Genesis3D\bmp\Menu*</A> </P>
</FONT><FONT FACE="Arial"><P>There are four graphics in this subdirectory two are the screen credits for the Eclipse development team. The other two are the graphics for a slider bar.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\bmp\Menu</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>12/09/98  10:12a                78,439 CREDITS0.BMP</P>
<P>12/09/98  10:12a               309,399 CREDITS1.BMP</P>
<P>12/09/98  10:12a                 1,333 SLIDERB.BMP</P>
<P>12/09/98  10:12a                 3,013 SLIDERR.BMP</P>
<P>               6 File(s)        392,184 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069817">Directory of C:\Genesis3D\bmp\Sbar*</A> </P>
</FONT><FONT FACE="Arial"><P>At the bottom of the demonstration game is a status bar which indicates what weapons you have, and which one is your current selection. The two subdirectories below contain the graphics for this bar and are done in two resolutions depending on which screen size you are using.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\bmp\SBar</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          320x240</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          640x480</P>
<P>               4 File(s)              0 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069818">Directory of C:\Genesis3D\bmp\SBar\320x240*</A></P>
</FONT><FONT FACE="Arial"><P>This is the 320x240 status bar.  It contains three screen shots for each of the demonstration weapons.  One for selected, one for in your possession, and one for not found yet.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\bmp\SBar\320x240</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>12/10/98  12:32p                 2,845 SBAR0-0.BMP</P>
<P>12/10/98  12:32p                 2,845 SBAR0-1.BMP</P>
<P>12/10/98  12:32p                 2,845 SBAR0-2.BMP</P>
<P>12/10/98  12:32p                 2,959 SBAR1-0.BMP</P>
<P>12/10/98  12:32p                 2,845 SBAR1-1.BMP</P>
<P>12/10/98  12:32p                 2,845 SBAR1-2.BMP</P>
<P>12/10/98  12:32p                 2,721 SBAR2-0.BMP</P>
<P>12/10/98  12:32p                 2,721 SBAR2-1.BMP</P>
<P>12/10/98  12:32p                 2,721 SBAR2-2.BMP</P>
<P>12/10/98  12:32p                 2,721 SBAR3-0.BMP</P>
<P>12/10/98  12:32p                 2,721 SBAR3-1.BMP</P>
<P>12/10/98  12:32p                 2,721 SBAR3-2.BMP</P>
<P>12/10/98  12:32p                 2,721 SBAR4-0.BMP</P>
<P>12/10/98  12:32p                 2,845 SBAR4-1.BMP</P>
<P>12/10/98  12:32p                 2,721 SBAR4-2.BMP</P>
<P>12/10/98  12:33p                 2,721 SBAR5-0.BMP</P>
<P>12/10/98  12:33p                 2,721 SBAR5-1.BMP</P>
<P>12/10/98  12:33p                 2,721 SBAR5-2.BMP</P>
<P>              20 File(s)         49,960 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069819">Directory of C:\Genesis3D\bmp\SBar\640x480*</A></P>
</FONT><FONT FACE="Arial"><P>This is the 640x480 status bar.  It contains four screen shots for each of the demonstration weapons.  It has the same three as the subdirectory above and a fourth one in red, ostensibly to indicate that you have the weapon selected but it is out of ammunition or charge.  While it is not used in the demonstration game there is an excellent tutorial in the Genesis Dojo which explains how to add this feature to your game.  </P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\bmp\SBar\640x480</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>12/09/98  04:21p                 7,971 SBAR0-0.BMP</P>
<P>12/09/98  04:21p                 7,971 SBAR0-1.BMP</P>
<P>12/09/98  04:21p                 7,971 SBAR0-2.BMP</P>
<P>12/09/98  04:21p                 7,971 SBAR0-3.BMP</P>
<P>12/09/98  04:21p                 7,971 SBAR1-0.BMP</P>
<P>12/09/98  04:21p                 7,971 SBAR1-1.BMP</P>
<P>12/09/98  04:21p                 7,971 SBAR1-2.BMP</P>
<P>12/09/98  04:21p                 7,971 SBAR1-3.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR2-0.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR2-1.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR2-2.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR2-3.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR3-0.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR3-1.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR3-2.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR3-3.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR4-0.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR4-1.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR4-2.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR4-3.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR5-0.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR5-1.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR5-2.BMP</P>
<P>12/09/98  04:21p                 7,483 SBAR5-3.BMP</P>
<P>              26 File(s)        183,496 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069820">Directory of C:\Genesis3D\bmp\Weapon*</A> </P>
</FONT><FONT FACE="Arial"><P>There are two bmp files in this subdirectory, one black and white the other colored, which are used for the flash that occurs when a weapon or item materializes in the game.</P>
<I>
</I></FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\bmp\Weapon</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>12/10/98  07:18p                 2,167 A_SPOT.BMP</P>
<P>12/10/98  07:17p                 2,167 SPOT_RED.BMP</P>
<P>               4 File(s)          4,334 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069821">Directory of C:\Genesis3D\doc*</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory and the three below it contain documentation provided by Eclipse on the Demonstration Game, Genesis3D Tools, and the Genesis3D API in HTML format.  The outer layer contains the starting index.html and references the subdirectories below for additional material.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\doc</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>12/16/98  11:08a                   441 3DSMaxGuide.htm</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          APIReference</P>
<P>12/16/98  05:47p                   385 APIReference.htm</P>
<P>12/16/98  05:47p                   357 APISummary.htm</P>
<P>11/15/98  11:53p                34,816 bot.doc</P>
<P>04/30/99  12:32p                 4,121 Drivers.htm</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          editor</P>
<P>02/25/99  11:55p                 5,949 EngineAPIs.htm</P>
<P>12/23/98  01:41p                   326 Features.htm</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          Images</P>
<P>05/10/99  04:15p                   437 index.html</P>
<P>04/30/99  12:34p                 2,133 Introduction.htm</P>
<P>04/30/99  12:36p                13,027 Manifest.htm</P>
<P>12/17/98  05:17p                   287 ReferenceBack.htm</P>
<P>04/29/99  01:05p                24,163 ReferenceIndex.htm</P>
<P>05/10/99  04:13p                 3,254 ReleaseNotes.htm</P>
<P>12/17/98  05:16p                   287 SummaryBack.htm</P>
<P>04/29/99  03:08p                 5,212 SummaryIndex.htm</P>
<P>05/11/99  05:46p                 3,387 toc.htm</P>
<P>04/30/99  11:39a                14,356 Tools.htm</P>
<P>05/10/99  04:13p                   295 TopHeader.htm</P>
<P>              23 File(s)        113,233 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069822">Directory of C:\Genesis3D\doc\APIReference*</A></P>
</FONT><FONT FACE="Arial"><P>The API reference is placed here, kept in a separate subdirectory broken down into twelve areas.  Within each area the critical function calls are explained, along with the parameters which are necessary to use and what is returned by each call.  There is a brief summary of the section and an overview of purpose for the section at the beginning.  The individual function calls are also referenced in the index allowing the user to go directly to any function call referenced.  At the time of this writing, this is still very much a work in progress, but all of it's major content was incorporated into the functional cross reference section of Volume 3 of this series.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\doc\APIReference</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>02/26/99  10:40a                 9,520 Camera.htm</P>
<P>01/10/99  08:59p                21,679 Engine.htm</P>
<P>12/18/98  10:23a                 3,961 Entity.htm</P>
<P>12/23/98  12:04p                52,120 Motion.htm</P>
<P>12/21/98  09:33a                25,069 Path.htm</P>
<P>12/17/98  08:54a                24,116 Quatern.htm</P>
<P>02/26/99  12:13a                 3,535 Ram.htm</P>
<P>12/16/98  01:37p                 1,803 Sample.htm</P>
<P>12/16/98  05:47p                14,068 Vec3d.htm</P>
<P>04/29/99  12:03p                44,432 VFile.htm</P>
<P>12/21/98  10:16a                22,287 World.htm</P>
<P>12/16/98  05:47p                26,811 XForm3d.htm</P>
<P>              14 File(s)        249,401 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069823">Directory of C:\Genesis3D\doc\editor*</A> </P>
</FONT><FONT FACE="Arial"><P>The GTest editor documentation is in this subdirectory. It explains how to use the Editor, its functions and capabilities.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\doc\editor</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>07/03/98  02:13p                   180 cnt0.gif</P>
<P>07/03/98  02:13p                   165 cnt1.gif</P>
<P>07/03/98  02:13p                   254 contents.gif</P>
<P>09/03/98  09:45a                 4,077 defaultgedit.html</P>
<P>07/03/98  02:13p                    60 gedit00090000.gif</P>
<P>09/03/98  09:45a                   906 geditAuto_rebuild.html</P>
<P>09/03/98  09:45a                 2,000 geditBasic_Operation.html</P>
<P>09/03/98  09:45a                 2,044 geditBrushes.html</P>
<P>09/03/98  09:45a                 1,520 geditBrush_and_Face_Modes.html</P>
<P>09/03/98  09:45a                 5,055 geditBrush_Attributes_Dialog.html</P>
<P>09/03/98  09:45a                 1,027 geditBSP_Settings.html</P>
<P>09/03/98  09:45a                 3,042 geditCamera_Mode.html</P>
<P>09/03/98  09:45a                 1,709 geditCompiling_and_Viewing_Your_Level.html</P>
<P>09/03/98  09:45a                   861 geditConsole.html</P>
<P>09/03/98  09:45a                 1,226 geditCut_Brushes_and_Brush_Order.html</P>
<P>09/03/98  09:45a                 1,910 geditEntities.html</P>
<P>09/03/98  09:45a                 1,516 geditEntity_Editor.html</P>
<P>09/03/98  09:45a                 1,402 geditEntity_Visibility_Dialog.html</P>
<P>09/03/98  09:45a                 1,259 geditFaces.html</P>
<P>09/03/98  09:45a                 3,882 geditFace_Attributes_Dialog.html</P>
<P>09/03/98  09:45a                 2,303 geditGeneral_Compile_Options.html</P>
<P>09/03/98  09:45a                 2,908 geditGroups.html</P>
<P>09/03/98  09:45a                 6,098 geditindex.html</P>
<P>09/03/98  09:45a                 2,657 geditLight_Settings.html</P>
<P>09/03/98  09:45a                 3,124 geditModels.html</P>
<P>09/03/98  09:45a                 2,245 geditOverview.html</P>
<P>09/03/98  09:45a                 1,902 geditQuick_Compile.html</P>
<P>09/03/98  09:45a                 3,463 geditSelect_Mode.html</P>
<P>09/03/98  09:45a                 4,779 geditShortcut_Keys.html</P>
<P>09/03/98  09:45a                 1,415 geditSky.html</P>
<P>09/03/98  09:45a                 2,732 geditTemplate.html</P>
<P>09/03/98  09:45a                 2,004 geditTemplate_Mode.html</P>
<P>09/03/98  09:45a                   911 geditTextures.html</P>
<P>09/03/98  09:45a                   982 geditThe_Camera_Entity.html</P>
<P>09/03/98  09:45a                 1,045 geditThe_Grid.html</P>
<P>09/03/98  09:45a                 3,271 geditThe_Initialization_File__GEDITIN.html</P>
<P>09/03/98  09:45a                   756 geditThe_Option_Pages.html</P>
<P>09/03/98  09:45a                 1,357 geditThe_Views.html</P>
<P>09/03/98  09:45a                   274 gedituntitled.html</P>
<P>09/03/98  09:45a                 8,509 geditUser_Defined_Entity_Header_Files.html</P>
<P>09/03/98  09:45a                 1,022 geditUser_Interface_Layout.html</P>
<P>09/03/98  09:45a                 1,105 geditVisibility_Settings.html</P>
<P>07/03/98  02:13p                   237 index.gif</P>
<P>07/03/98  02:13p                   162 index_a.gif</P>
<P>07/03/98  02:13p                   162 index_b.gif</P>
<P>07/03/98  02:13p                   163 index_c.gif</P>
<P>07/03/98  02:13p                   163 index_d.gif</P>
<P>07/03/98  02:13p                   159 index_e.gif</P>
<P>07/03/98  02:13p                   159 index_f.gif</P>
<P>07/03/98  02:13p                   165 index_g.gif</P>
<P>07/03/98  02:13p                   161 index_h.gif</P>
<P>07/03/98  02:13p                   162 index_i.gif</P>
<P>07/03/98  02:13p                   162 index_j.gif</P>
<P>07/03/98  02:13p                   162 index_k.gif</P>
<P>07/03/98  02:13p                   160 index_l.gif</P>
<P>07/03/98  02:13p                   162 index_m.gif</P>
<P>07/03/98  02:13p                   163 index_n.gif</P>
<P>07/03/98  02:13p                   162 index_o.gif</P>
<P>07/03/98  02:13p                   161 index_p.gif</P>
<P>07/03/98  02:13p                   164 index_q.gif</P>
<P>07/03/98  02:13p                   161 index_r.gif</P>
<P>07/03/98  02:13p                   164 index_s.gif</P>
<P>07/03/98  02:13p                   160 index_t.gif</P>
<P>07/03/98  02:13p                   163 index_u.gif</P>
<P>07/03/98  02:13p                   162 index_v.gif</P>
<P>07/03/98  02:13p                   163 index_w.gif</P>
<P>07/03/98  02:13p                   164 index_x.gif</P>
<P>07/03/98  02:13p                   161 index_y.gif</P>
<P>07/03/98  02:13p                   161 index_z.gif</P>
<P>09/03/98  09:45a                   145 logfile.html</P>
<P>07/03/98  02:13p                   188 next0.gif</P>
<P>07/03/98  02:13p                   190 next1.gif</P>
<P>07/03/98  02:13p                   186 prev0.gif</P>
<P>07/03/98  02:13p                   189 prev1.gif</P>
<P>              76 File(s)         94,303 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069824">Directory of C:\Genesis3D\doc\editor*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains only a single screen shot for the TPack utility and several screenshots of the Astudio interface.  They are referenced in the doc subdirectory in the tools description which is not yet complete.  </P>
<I>
</I></FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\doc\Images</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>04/30/99  10:06a                 4,862 ASBody.GIF</P>
<P>04/30/99  10:13a                 6,286 ASExtraMaterials.GIF</P>
<P>04/30/99  10:28a                 6,714 ASMotions.GIF</P>
<P>04/30/99  11:11a                 5,596 ASPaths.GIF</P>
<P>04/30/99  10:30a                 5,235 ASSettings.GIF</P>
<P>04/30/99  10:01a                 3,855 ASTarget.GIF</P>
<P>04/30/99  11:39a                 4,460 tpack.GIF</P>
<P>               9 File(s)         37,008 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069825">Directory of C:\Genesis3D\Genesis3D*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the uninstall file used to remove the Genesis3D installation from your computer.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\Genesis3D</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>05/17/99  06:35p                85,209 DeIsL1.isu</P>
<P>               3 File(s)         85,209 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069826">Directory of C:\Genesis3D\include</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the header files for the Genesis3D API.  It is the core set of functions that persons who wish to develop for Genesis3D need to use if they are not planning on modifying the sources for the engine.  These include files, along with the lib subdirectory below are all the necessary files for use of the Genesis3D graphics engine.  For those who either plan to pay the licensing fee or release their own sources the OpenSource subdirectories will be necessary.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\include</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>05/12/99  02:19p                23,801 actor.h</P>
<P>05/03/99  03:55p                 3,332 BASETYPE.H</P>
<P>05/03/99  04:06p                23,446 bitmap.h</P>
<P>04/26/99  10:53a                 5,570 body.h</P>
<P>04/27/99  11:53p                11,163 Errorlog.h</P>
<P>04/26/99  10:53a                 4,577 ExtBox.h</P>
<P>04/26/99  10:53a                13,334 font.H</P>
<P>05/13/99  08:27p                26,220 GENESIS.H</P>
<P>04/26/99  10:53a                 3,573 getypes.h</P>
<P>04/26/99  04:04p                 2,772 matrix33.h</P>
<P>04/26/99  10:53a                 9,662 motion.h</P>
<P>04/26/99  10:53a                 6,248 path.h</P>
<P>04/26/99  04:05p                 4,093 PhysicsJoint.h</P>
<P>05/13/99  02:08p                 8,618 PhysicsObject.h</P>
<P>04/26/99  04:04p                 3,183 PhysicsSystem.h</P>
<P>05/03/99  03:16p                 6,342 pixelformat.h</P>
<P>04/26/99  10:53a                 9,519 quatern.h</P>
<P>04/26/99  10:53a                 5,195 RAM.H</P>
<P>04/26/99  10:53a                 3,903 VEC3D.H</P>
<P>04/26/99  10:53a                 8,113 vfile.h</P>
<P>04/26/99  10:53a                 8,740 XFORM3D.H</P>
<P>              23 File(s)        191,404 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069827">Directory of C:\Genesis3D\levels*</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the level files and BSP files for the demonstration game as well as the .txl file that guides the color choices of each level.  Use of the GEdit program to create a new level will result in your new addition automatically being placed here.  Also, read the Objects subdirectory below.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\levels</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>04/30/99  01:16a             2,427,123 gedit.txl</P>
<P>05/11/99  06:12p             1,516,771 genvs.3dt</P>
<P>05/11/99  01:08p             4,377,430 genvs.bsp</P>
<P>05/11/99  06:14p             1,423,158 genvs2.3dt</P>
<P>05/11/99  04:09a             3,304,276 genvs2.bsp</P>
<P>               7 File(s)     13,048,758 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069828">Directory of C:\Genesis3D\lib*</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains both release and debug versions of the core Genesis3D functions for use by individuals who are not altering the Genesis source code.  It is referenced by the demonstration game and, if you decide to create new versions by modifying the OpenSources you should place the new versions here.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\lib</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>05/14/99  09:11p             1,253,774 genesis.lib</P>
<P>05/14/99  09:04p             3,750,244 genesisd.lib</P>
<P>05/14/99  09:09p               126,578 genesisi.lib</P>
<P>               5 File(s)      5,130,596 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069829">Directory of C:\Genesis3D\Objects*</A></P>
</FONT><I><FONT FACE="Arial"><P>This subdirectory is NOT created when you install the Genesis3D Software.  However, if you wish to create your own objects for later use with GEdit tool you must manually create  a subdirectory named Objects in this place. The GEdit tool looks for objects in this subdirectory  in order to use them.  If you create a 3d object in the GEdit tool it tries to place the new item in this subdirectory when you select Save or Save As.</P>
</I></FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069830">Directory of C:\Genesis3D\OpenSource*</A></P>
</FONT><FONT FACE="Arial"><P>This is the beginning of the OpenSource subdirectories which contain the sources for both the Genesis3D engine and its supporting tools.  The directory contains 8 text files which describe what additional files must be placed in certain subdirectories in order to exacly mimic the development layout used by Eclipse to build the software.  These files are from software not supplied by Eclipse - like MASM, DirectX, and the Glide SDK.</P>

<P>There is also a readme file which explains the purposes behind the layout and specifically why Eclipse chose to incorporate multiple copies of it's include files in the tools development area (it speeds compile times to make the tools separately.)</P>
</FONT><FONT FACE="Courier New">
</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>03/25/99  12:20p                12,884 Build.txt</P>
<P>04/26/99  11:37a                23,295 license.txt</P>
<P>03/24/99  02:12p                 2,509 ManifestDXSDK.txt</P>
<P>03/24/99  02:13p                 1,529 ManifestGlide.txt</P>
<P>03/24/99  02:11p                 1,080 ManifestMasm.txt</P>
<P>04/26/99  01:06p                 9,192 ManifestMAX.txt</P>
<P>03/24/99  02:07p                13,816 ManifestVC.txt</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          masm</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          msdev60</P>
<P>03/25/99  03:50p                 1,262 readme.txt</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          sdk</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Source</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          Tools</P>
<P>              15 File(s)         65,567 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069831">Directory of C:\Genesis3D\OpenSource\masm*</A></P>
</FONT><FONT FACE="Arial"><P>The MASM subdirectory actually contains a single file that directs you to read a document called Build.txt.  This document explains the rationale for the build process and indicates that this is where Eclipse typically installs its own copy of Microsoft Assembler (MASM).</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\masm</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>05/15/99  12:24a                    66 readme.txt</P>
<P>               3 File(s)             66 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069832">Directory of C:\Genesis3D\OpenSource\msdev60*</A></P>
</FONT><FONT FACE="Arial"><P>The Msdev60 subdirectory is similar to the MASM directory above.  It points to this location as the home for Microsoft Visual Studio 6.0</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\msdev60</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>05/15/99  12:24a                    66 readme.txt</P>
<P>               3 File(s)             66 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069833">Directory of C:\Genesis3D\OpenSource\sdk*</A></P>
</FONT><FONT FACE="Arial"><P>In the same fashion, the following two directories are the locations where graphical toolkits used by the Genesis engine and the compiler should be placed.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\sdk</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          DX6SDK</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          Glide</P>
<P>               4 File(s)              0 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069834">Directory of C:\Genesis3D\OpenSource\sdk\DX6SDK*</A></P>
</FONT><FONT FACE="Arial"><P>The sample program uses DirectX 6.0.  However, I have successfully compiled it with the newer version, 6.1.  There are features in the newer version which the engine does not yet take advantage of.  In fact, these features are among the possible improvements that could be made to the engine.  However, there will be an issue if the addition of these features will be limited to the DirectX implementation or if similar features would be hand coded for Glide.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\sdk\DX6SDK</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>05/15/99  12:24a                    66 readme.txt</P>
<P>               3 File(s)             66 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069835">Directory of C:\Genesis3D\OpenSource\sdk\Glide*</A></P>
</FONT><FONT FACE="Arial"><P>The Glide SDK is placed here.  Glide drivers are compiled and selected by the user at run time (just as the user can select DirectX drivers or software only drivers).  The Glide drivers do limit the feature set of the engine to those users who have 3DFX chipset cards, so additions here can cause the same issues as adding enhancements to the DirectX drivers.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\sdk\Glide</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>05/15/99  12:24a                    66 readme.txt</P>
<P>               3 File(s)             66 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069836">Directory of C:\Genesis3D\OpenSource\Source</A></P>
</FONT><FONT FACE="Arial"><P>This is it, the Holy Grail for game engine students.  The Genesis3D engine sources reside in this set of subdirectories.  Code is here for the engine and actors, bitmap graphics and graphics compression, 3D entities and math, fonts and files.  There is also a second, experimental , software-only driver under construction by Eclipse.</P>
<P>The outer subdirectory contains the basic engine source code and a set of make files for creating a debug and release version using Microsoft Visual C++ 6.0.  Additional files in each of the subdirectories are described below.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          Actor</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          Bitmap</P>
<P>04/26/99  10:52a                24,126 CAMERA.C</P>
<P>04/26/99  10:53a                 5,880 CAMERA.H</P>
<P>05/14/99  08:26p                19,014 CSNetMgr.c</P>
<P>05/13/99  08:27p                 5,104 CSNetMgr.h</P>
<P>03/25/99  12:05p                 1,612 drawbbox.c</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Engine</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Entities</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Font</P>
<P>05/04/99  05:02p                14,268 Ge.c</P>
<P>05/11/99  03:37p                14,971 Genesis.dsp</P>
<P>05/13/99  08:27p                26,220 GENESIS.H</P>
<P>05/11/99  04:28p                22,192 Genesis.mak</P>
<P>03/24/99  08:24a                 2,582 genesis.rc</P>
<P>05/11/99  04:29p                16,739 GenesisDLL.dsp</P>
<P>05/11/99  04:29p                23,750 GenesisDLL.mak</P>
<P>04/26/99  10:53a                 3,573 getypes.h</P>
<P>04/26/99  10:52a                29,282 list.c</P>
<P>04/26/99  10:53a                 9,212 list.h</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Math</P>
<P>05/15/99  12:22a                   181 mssccprj.scc</P>
<P>05/14/99  08:26p                27,476 NETPLAY.C</P>
<P>05/14/99  02:45a                 3,603 NETPLAY.H</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Physics</P>
<P>04/26/99  10:53a                 2,645 PTRTYPES.H</P>
<P>12/08/98  09:43a                   411 resource.h</P>
<P>04/26/99  10:52a                27,721 SOUND.C</P>
<P>04/26/99  10:53a                 3,234 SOUND.H</P>
<P>04/26/99  10:52a                 5,602 Sound3d.c</P>
<P>04/26/99  10:53a                 2,303 SOUND3D.H</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Support</P>
<P>04/26/99  10:52a                16,489 Tclip.c</P>
<P>04/26/99  10:53a                 2,694 tclip.h</P>
<P>04/26/99  10:52a                 2,149 timer.c</P>
<P>04/26/99  10:53a                 3,422 timer.h</P>
<P>04/26/99  10:52a                 3,910 tsc.c</P>
<P>04/26/99  10:53a                 2,665 tsc.h</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          VFile</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          World</P>
<P>              42 File(s)        323,030 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069837">Directory of C:\Genesis3D\OpenSource\Source\Actor</A> </P>
</FONT><FONT FACE="Arial"><P>The code in this section is used to create and move a character along a specified path.  It includes code for the "actor's" movement.  (Actors in this case refer to any model capable of movement - not just animated characters.)</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\Actor</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>05/12/99  02:33p                52,195 actor.c</P>
<P>05/12/99  02:19p                23,801 actor.h</P>
<P>04/26/99  10:52a                36,723 body.c</P>
<P>04/26/99  10:53a                 5,570 body.h</P>
<P>04/26/99  11:45a                 3,948 body._h</P>
<P>04/26/99  10:52a                11,155 bodyinst.c</P>
<P>04/26/99  10:53a                 4,254 bodyinst.h</P>
<P>04/26/99  10:52a                56,806 motion.c</P>
<P>04/26/99  10:53a                 9,662 motion.h</P>
<P>05/04/99  05:02p                42,401 path.c</P>
<P>04/26/99  10:53a                 6,248 path.h</P>
<P>04/26/99  10:52a                31,006 pose.c</P>
<P>04/26/99  10:53a                 8,021 pose.h</P>
<P>05/04/99  05:02p                43,043 puppet.c</P>
<P>04/26/99  10:53a                 4,127 puppet.h</P>
<P>04/26/99  10:52a                32,811 QKFrame.c</P>
<P>04/26/99  10:53a                 6,823 QKFrame.h</P>
<P>04/26/99  10:52a                16,010 strblock.c</P>
<P>04/26/99  10:53a                 2,994 strblock.h</P>
<P>04/26/99  10:52a                11,470 tkarray.c</P>
<P>04/26/99  10:53a                 5,188 tkarray.h</P>
<P>04/26/99  10:52a                19,568 tkevents.c</P>
<P>04/26/99  10:53a                 4,705 tkevents.h</P>
<P>04/26/99  10:52a                24,560 vkframe.c</P>
<P>04/26/99  10:53a                 5,937 vkframe.h</P>
<P>04/26/99  10:52a                 3,467 XFArray.c</P>
<P>04/26/99  10:53a                 3,077 xfarray.h</P>
<P>              29 File(s)        475,570 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069838">Directory of C:\Genesis3D\OpenSource\Source\Bitmap</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains code for creating and moving bitmap texture images.  It also calls the compression subdirectory beneath it to compress and expand bitmap palettes.</P>

</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\Bitmap</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>05/05/99  11:31a               124,990 bitmap.c</P>
<P>05/03/99  04:06p                23,446 bitmap.h</P>
<P>05/03/99  03:24p                 3,116 bitmap._h</P>
<P>04/26/99  11:46a                 6,134 bitmap.__h</P>
<P>05/05/99  12:01a                42,086 bitmap_blitdata.c</P>
<P>04/26/99  10:53a                 2,320 bitmap_blitdata.h</P>
<P>04/26/99  10:52a                13,801 bitmap_gamma.c</P>
<P>04/26/99  10:53a                 2,175 bitmap_gamma.h</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          Compression</P>
<P>05/04/99  01:23p                25,560 pixelformat.c</P>
<P>05/03/99  03:16p                 6,342 pixelformat.h</P>
<P>              13 File(s)        249,970 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069839">Directory of C:\Genesis3D\OpenSource\Source\Bitmap\Compression</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains code for using and optimizing various palettes (Genesis supports different video resolutions so palette translation is necessary between prerecorded bitmap images and the screens they may be displayed on.)  Genesis also uses 256 color palettes in its saved images and optimizes these, rolling them together,  in displaying the higher 16 bit video color depth of the final product.</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Directory of C:\Genesis3D\OpenSource\Source\Bitmap\Compression</P>

<P>05/17/99  06:32p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:32p        &lt;DIR&gt;          ..</P>
<P>04/26/99  10:52a                22,265 palcreate.c</P>
<P>04/26/99  10:53a                 2,636 palcreate.h</P>
<P>04/26/99  10:52a                14,015 palettize.c</P>
<P>04/26/99  10:53a                 2,586 palettize.h</P>
<P>04/26/99  10:52a                 7,308 paloptimize.c</P>
<P>04/26/99  10:53a                 2,207 paloptimize.h</P>
<P>04/26/99  10:53a                 3,801 utility.h</P>
<P>04/26/99  10:52a                 6,168 yuv.c</P>
<P>04/26/99  10:53a                 4,572 yuv.h</P>
<P>              11 File(s)         65,558 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069840">Directory of C:\Genesis3D\OpenSource\Source\Engine</A> </P>
</FONT><FONT FACE="Arial"><P>This is the outermost subdirectory of the actual engine.  It contains the engine code, code for manipulating the list of bitmap images, font display, and links to the two subdirectories beneath it which control video driver display and the Genesis logo display.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\Engine</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/28/99  06:34p                 9,690 BitmapList.c</P>
<P>04/26/99  10:53a                 2,861 BitmapList.h</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Drivers</P>
<P>05/04/99  05:02p                52,372 engine.c</P>
<P>04/26/99  10:53a                 5,335 engine.h</P>
<P>04/26/99  10:52a                63,532 fontbmp.c</P>
<P>04/26/99  10:52a             1,057,891 genesis3d.c</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Logo</P>
<P>05/10/99  05:28p                14,168 System.c</P>
<P>05/10/99  05:28p                 7,304 System.h</P>
<P>              12 File(s)      1,213,153 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069841">Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains common subroutines used by all the Genesis video drivers.  Genesis3D supports DirectX, Glide and a software only video driver.  There are two software video drivers provided.  SoftDrv2 is the latest driver and is used in the Gtest example program.  Beneath this subdirectory are subdirectories containing code for each of the video drivers.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/26/99  10:52a                 4,157 Bmp.c</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          D3DDrv</P>
<P>05/10/99  03:30p                16,061 Dcommon.h</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          GlideDrv</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          SoftDrv</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          SoftDrv2</P>
<P>               8 File(s)         20,218 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069842">Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers\D3DDrv</A> </P>
</FONT><FONT FACE="Arial"><P>In this subdirectory is the code for the DirectX Direct3D video drivers.  This code acts as a thin wrapper around the Microsoft code and provides consistency of calling convention between the DirectX, Glide and Software only versions of the driver.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers\D3DDrv</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>05/10/99  10:22p                23,182 D3dcache.cpp</P>
<P>05/10/99  06:41p                 3,877 D3dcache.h</P>
<P>05/08/99  11:06p                 7,360 D3ddrv.cpp</P>
<P>03/04/99  02:17p                 7,231 D3DDrv.dsp</P>
<P>04/26/99  10:53a                 2,100 D3DDRV.H</P>
<P>03/04/99  02:17p                 7,615 D3DDrv.mak</P>
<P>04/26/99  10:52a                15,019 D3D_ERR.CPP</P>
<P>04/26/99  10:53a                 2,179 D3D_ERR.H</P>
<P>05/08/99  11:06p                 8,217 D3d_fx.cpp</P>
<P>05/08/99  11:06p                 2,683 D3D_FX.H</P>
<P>05/10/99  10:21p                87,434 D3d_main.cpp</P>
<P>05/08/99  11:06p                 8,800 D3d_main.h</P>
<P>04/26/99  10:52a                 6,374 DDMemMgr.c</P>
<P>04/26/99  10:53a                 2,736 DDMemMgr.h</P>
<P>04/26/99  10:52a                 7,720 GSPAN.CPP</P>
<P>04/26/99  10:53a                 2,823 GSPAN.H</P>
<P>05/15/99  12:22a                   131 mssccprj.scc</P>
<P>05/09/99  01:28a                37,023 Pcache.cpp</P>
<P>04/26/99  10:53a                 2,286 Pcache.h</P>
<P>05/07/99  02:56p                 7,206 Render.cpp</P>
<P>05/07/99  02:56p                 2,394 RENDER.H</P>
<P>05/09/99  12:54a                 5,313 Scene.cpp</P>
<P>04/26/99  10:53a                 2,368 SCENE.H</P>
<P>05/10/99  10:21p                23,099 THandle.cpp</P>
<P>05/05/99  04:48p                 5,016 THandle.h</P>
<P>04/26/99  10:52a                17,803 tpage.cpp</P>
<P>04/26/99  10:53a                 3,587 TPage.h</P>
<P>              29 File(s)        301,576 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069843">Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers\GlideDrv</A> </P>
</FONT><FONT FACE="Arial"><P>In this subdirectory is the code for the Glide video drivers.  This code acts as a thin wrapper around the Glide code and provides consistency of calling convention between the DirectX, Glide and Software only versions of the driver.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers\GlideDrv</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/26/99  10:52a                20,816 GCache.c</P>
<P>04/26/99  10:53a                 3,404 GCache.h</P>
<P>05/11/99  03:35p                 8,858 GlideDrv.c</P>
<P>03/04/99  12:50p                 6,363 GlideDrv.dsp</P>
<P>04/26/99  10:53a                 2,023 GLIDEDRV.H</P>
<P>03/04/99  12:50p                 6,702 GlideDrv.mak</P>
<P>04/26/99  10:52a                11,290 GMain.c</P>
<P>04/26/99  10:53a                 2,839 GMain.h</P>
<P>04/26/99  10:52a                 5,923 GMemMgr.c</P>
<P>04/26/99  10:53a                 2,452 GMemMgr.h</P>
<P>04/26/99  10:52a                 7,767 GSpan.cpp</P>
<P>04/26/99  10:53a                 2,935 GSpan.h</P>
<P>04/26/99  10:52a                23,513 GThandle.c</P>
<P>04/26/99  10:53a                 5,778 GTHandle.h</P>
<P>05/15/99  12:22a                   135 mssccprj.scc</P>
<P>05/08/99  11:27p                29,377 Render.c</P>
<P>04/26/99  10:53a                 4,009 Render.h</P>
<P>              19 File(s)        144,184 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069844">Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers\SoftDrv</A> </P>
</FONT><FONT FACE="Arial"><P>In this subdirectory is the first of two software only versions of the video drivers.  This code acts as a thin wrapper around the Microsoft code and provides consistency of calling convention between the DirectX, Glide and Software only versions of the driver.</P>
<P>It was used more most of the development of Genesis3D and is highly robust, but it has been superceded by the SoftDrv2 version.  It is included here for completeness and for comparison purposes in case problems arise with the other driver. </P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers\SoftDrv</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/26/99  10:53a                 5,406 3dnowspan.h</P>
<P>04/26/99  10:55a               287,158 amdspan.asm</P>
<P>04/26/99  10:52a                48,025 dmodes.c</P>
<P>04/26/99  10:53a                 3,143 dmodes.h</P>
<P>04/26/99  10:52a                33,163 drawspan.c</P>
<P>04/26/99  10:53a                 3,293 drawspan.h</P>
<P>05/15/99  12:22a                   133 mssccprj.scc</P>
<P>04/26/99  10:52a                10,152 register.c</P>
<P>04/26/99  10:53a                 3,445 REGISTER.H</P>
<P>04/26/99  10:52a                71,866 render.c</P>
<P>04/26/99  10:53a                 4,614 RENDER.H</P>
<P>04/26/99  10:53a                10,329 SAL.H</P>
<P>04/26/99  10:52a                 6,309 scene.c</P>
<P>04/26/99  10:53a                 2,364 SCENE.H</P>
<P>05/12/99  04:23p                21,885 softdrv.c</P>
<P>03/04/99  02:18p                 7,738 SoftDrv.dsp</P>
<P>04/26/99  10:53a                 3,478 SOFTDRV.H</P>
<P>03/04/99  02:18p                 8,266 SoftDrv.mak</P>
<P>04/26/99  10:52a                 4,188 span.c</P>
<P>04/26/99  10:53a                 2,575 SPAN.H</P>
<P>04/26/99  10:52a                 2,642 system.c</P>
<P>04/26/99  10:53a                 1,978 SYSTEM.H</P>
<P>04/26/99  10:52a                58,376 W32SAL.CPP</P>
<P>04/26/99  10:52a               300,289 x86span555.c</P>
<P>04/26/99  10:53a                 4,700 x86span555.h</P>
<P>04/26/99  10:52a               330,685 x86span565.c</P>
<P>04/26/99  10:53a                 4,619 x86span565.h</P>
<P>              29 File(s)      1,240,819 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069845">Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers\SoftDrv2</A></P>
</FONT><FONT FACE="Arial"><P>In this subdirectory is the second of two software only versions of the video drivers.  This code acts as a thin wrapper around the Microsoft code and provides consistency of calling convention between the DirectX, Glide and Software only versions of the driver.</P>
<P>This is the latest version of the driver and is optimized for better performance and has been tested with a wide range of video cards. </P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\Engine\Drivers\SoftDrv2</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>05/12/99  04:25p                 5,487 CPUInfo.c</P>
<P>04/26/99  10:53a                 2,113 CPUInfo.h</P>
<P>04/26/99  10:52a                23,559 DDRAWDisplay.c</P>
<P>04/26/99  10:53a                 3,435 DDRAWDisplay.h</P>
<P>04/26/99  10:52a                21,153 DIBDisplay.c</P>
<P>04/26/99  10:53a                 3,528 DIBDisplay.h</P>
<P>04/26/99  10:52a                 7,801 display.c</P>
<P>04/26/99  10:53a                 3,772 display.h</P>
<P>04/26/99  10:52a                 4,319 DisplayModeInfo.c</P>
<P>04/26/99  10:53a                 3,081 DisplayModeInfo.h</P>
<P>04/26/99  10:52a                 6,356 DrawDecal.c</P>
<P>04/26/99  10:53a                 2,116 DrawDecal.h</P>
<P>05/15/99  12:22a                   135 mssccprj.scc</P>
<P>04/26/99  10:53a                 4,531 rop.h</P>
<P>04/29/99  07:45p                30,906 softdrv.c</P>
<P>04/26/99  10:53a                 2,318 Softdrv.h</P>
<P>04/06/99  06:07p                 7,825 SoftDrv2.dsp</P>
<P>04/06/99  06:07p                 8,149 SoftDrv2.mak</P>
<P>04/26/99  10:52a                19,290 span.c</P>
<P>04/26/99  10:53a                 2,508 Span.h</P>
<P>05/09/99  12:11a                 8,306 SpanBuffer.c</P>
<P>04/26/99  10:53a                 3,048 SpanBuffer.h</P>
<P>04/26/99  10:53a                 7,297 SpanEdges_Factory.h</P>
<P>04/26/99  10:53a                 7,257 Span_AffineLoop.h</P>
<P>05/09/99  12:08a                 8,183 Span_Factory.h</P>
<P>04/26/99  10:52a                13,401 SWTHandle.c</P>
<P>04/26/99  10:53a                 3,599 SWTHandle.h</P>
<P>04/26/99  10:52a                14,348 TRaster.c</P>
<P>04/26/99  10:53a                 3,873 traster.h</P>
<P>04/26/99  10:52a                13,167 Triangle.c</P>
<P>04/26/99  10:53a                14,352 triangle.h</P>
<P>              33 File(s)        259,213 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069846">Directory of C:\Genesis3D\OpenSource\Source\Engine\Logo</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains procedual code for the Genesis3D logo - creating the electrical arc and corona halo effect and the moving gears on the spash screen in the GTest demo program.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\Engine\Logo</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/26/99  10:52a               106,955 A_CORONA.c</P>
<P>04/26/99  10:52a               107,639 A_STREAK.c</P>
<P>04/26/99  10:52a               107,861 CORONA.c</P>
<P>04/28/99  11:36a                 9,026 electric.c</P>
<P>04/26/99  10:53a                 3,527 electric.h</P>
<P>05/11/99  03:42p                14,866 logo.c</P>
<P>04/26/99  10:52a               852,733 LogoActor.c</P>
<P>04/26/99  10:52a               105,805 streak.c</P>
<P>05/11/99  03:35p               272,444 WebUrl.c</P>
<P>              11 File(s)      1,580,856 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069847">Directory of C:\Genesis3D\OpenSource\Source\Entities</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the basic entity definitions for objects in the Genesis3D world.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\Entities</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/26/99  10:52a                29,763 Entities.c</P>
<P>04/26/99  10:53a                 5,894 ENTITIES.H</P>
<P>               4 File(s)         35,657 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069848">Directory of C:\Genesis3D\OpenSource\Source\Font</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the basic definitions and functions that can be used with text fonts in Genesis3D.  The engine supports the display of various TrueType fonts within a created game.</P>
</FONT><FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\Font</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/26/99  10:52a                42,455 font.c</P>
<P>04/26/99  10:53a                13,334 font.H</P>
<P>04/26/99  10:52a                 4,360 wgClip.c</P>
<P>04/26/99  10:53a                 2,421 wgClip.H</P>
<P>               6 File(s)         62,570 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069849">Directory of C:\Genesis3D\OpenSource\Source\Math</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains code for the basic math routines used throughout the engine.  It includes routines for vector and quaternions</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\Math</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/26/99  10:52a                 7,101 Box.c</P>
<P>04/26/99  10:53a                 3,027 Box.h</P>
<P>04/26/99  10:52a                 6,524 crc32.c</P>
<P>04/26/99  10:53a                 2,305 crc32.h</P>
<P>04/26/99  10:52a                14,114 ExtBox.c</P>
<P>04/26/99  10:53a                 4,577 ExtBox.h</P>
<P>05/04/99  05:02p                21,587 quatern.c</P>
<P>04/26/99  10:53a                 9,519 quatern.h</P>
<P>04/26/99  10:52a                 8,446 VEC3D.C</P>
<P>04/26/99  10:53a                 3,903 VEC3D.H</P>
<P>05/04/99  05:02p                24,404 Xform3d.c</P>
<P>04/26/99  10:53a                 8,740 XFORM3D.H</P>
<P>              14 File(s)        114,247 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069850">Directory of C:\Genesis3D\OpenSource\Source\Physics</A> </P>
</FONT><FONT FACE="Arial"><P>The contents of this subdirectory are the routines that make up the basic physics library for collision reactions and the fundamental 3D matrix math operations that determine movement in the game world.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\Physics</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/26/99  04:03p                 5,417 matrix33.c</P>
<P>04/26/99  04:04p                 2,772 matrix33.h</P>
<P>04/26/99  04:05p                 7,722 PhysicsJoint.c</P>
<P>04/26/99  04:05p                 4,093 PhysicsJoint.h</P>
<P>05/11/99  09:45p                27,872 PhysicsObject.c</P>
<P>05/13/99  02:08p                 8,618 PhysicsObject.h</P>
<P>05/11/99  09:47p                24,135 PhysicsSystem.c</P>
<P>04/26/99  04:04p                 3,183 PhysicsSystem.h</P>
<P>              10 File(s)         83,812 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069851">Directory of C:\Genesis3D\OpenSource\Source\Support</A> </P>
</FONT><FONT FACE="Arial"><P>The routines in this subdirectory comprise the memory management routines and error trapping routines used throughout the engine.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\Support</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>05/03/99  03:55p                 3,332 BASETYPE.H</P>
<P>04/27/99  11:49p                 5,749 ERRORLOG.C</P>
<P>04/27/99  11:53p                11,163 Errorlog.h</P>
<P>04/26/99  10:52a                 4,629 geAssert.c</P>
<P>04/26/99  10:53a                 2,968 geAssert.h</P>
<P>04/26/99  10:52a                 2,375 log.c</P>
<P>04/26/99  10:53a                 2,218 log.h</P>
<P>04/26/99  10:52a                 8,654 mempool.c</P>
<P>04/26/99  10:53a                 2,491 mempool.h</P>
<P>04/26/99  10:52a                15,407 RAM.C</P>
<P>04/26/99  10:53a                 5,195 RAM.H</P>
<P>04/26/99  10:52a                 1,904 ramdll.c</P>
<P>              14 File(s)         66,085 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069852">Directory of C:\Genesis3D\OpenSource\Source\Vfile</A> </P>
</FONT><FONT FACE="Arial"><P>Basic file handling is accomplished through the routines in this subdirectory including handling the manipulation of memory blocks and virtual files.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\VFile</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>05/04/99  05:12p                18,775 dirtree.c</P>
<P>04/26/99  10:53a                 3,764 dirtree.h</P>
<P>04/28/99  11:27a                20,367 fsdos.c</P>
<P>04/26/99  10:53a                 1,946 fsdos.h</P>
<P>04/26/99  10:52a                11,369 FSMEMORY.C</P>
<P>04/26/99  10:53a                 1,956 FSMEMORY.H</P>
<P>04/26/99  10:52a                20,007 fsvfs.c</P>
<P>04/26/99  10:53a                 1,970 fsvfs.h</P>
<P>04/26/99  10:52a                14,333 vfile.c</P>
<P>04/26/99  10:53a                 8,113 vfile.h</P>
<P>04/26/99  11:45a                 5,354 vfile._h</P>
<P>              13 File(s)        107,954 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069853">Directory of C:\Genesis3D\OpenSource\Source\World</A> </P>
</FONT><FONT FACE="Arial"><P>Code in this subdirectory primarily governs visibility in the game world.  It includes routines for manipulating light, surfaces, planes, fog effects, and the binary space partion tree (BSP tree) which is rapidly searched for objects which may be visible to the player.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Source\World</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/26/99  10:52a                 4,254 Fog.c</P>
<P>04/26/99  10:53a                 3,438 Fog.h</P>
<P>05/06/99  08:15p                35,122 Frustum.c</P>
<P>05/06/99  08:15p                 5,377 FRUSTUM.H</P>
<P>04/26/99  10:52a                18,084 Gbspfile.c</P>
<P>04/26/99  10:53a                10,659 GBSPFILE.H</P>
<P>05/12/99  05:16p                53,541 Light.c</P>
<P>05/11/99  10:24p                 4,655 LIGHT.H</P>
<P>05/06/99  07:17p                 7,487 Plane.c</P>
<P>05/06/99  07:17p                 3,067 PLANE.H</P>
<P>05/04/99  04:03p                17,807 Surface.c</P>
<P>04/26/99  10:53a                 4,337 SURFACE.H</P>
<P>05/04/99  05:02p                63,164 Trace.c</P>
<P>04/26/99  10:53a                 6,002 TRACE.H</P>
<P>04/26/99  10:52a                29,317 User.c</P>
<P>04/26/99  10:53a                 4,491 USER.H</P>
<P>05/04/99  05:02p                15,085 Vis.c</P>
<P>04/26/99  10:53a                 2,687 VIS.H</P>
<P>04/29/99  06:59p                15,853 WBitmap.c</P>
<P>04/26/99  10:53a                 4,244 WBitmap.h</P>
<P>05/12/99  12:57a                92,115 World.c</P>
<P>05/05/99  05:36p                 9,314 WORLD.H</P>
<P>              24 File(s)        410,100 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069854">Directory of C:\Genesis3D\OpenSource\Tools*</A></P>
</FONT><FONT FACE="Arial"><P>The Tools subdirectory is a container for individual subdirectories containing sources for all the tools supplied by Eclipse for use with the Genesis3D engine.  There is no source code in the outer directory, in fact, there are no files at all in the outer directory.</P>
<P>Note: As an optimization to reduce the compilation speed the Tools each contain their own copies of the main Genesis3D headers and compiled versions of the resultant libraries to link to.  This code is replicated for each Tool subdirectory and except where noted it should be identical for each tool.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ActView</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Exporters</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Fusion2</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          GBSPLib</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          GPreview</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          mkactor</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          TPack</P>
<P>               9 File(s)              0 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069855">Directory of C:\Genesis3D\OpenSource\Tools\ActView*</A> </P>
</FONT><FONT FACE="Arial"><P>This is the outer subdirectory for the ActView tool, which allows you to view, rotate, zoom, and animate ACT files.  It is useful for verifying the smoothness of an animation, but it does not contain functions for changing animations.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/28/99  10:50a                 6,625 ActView.dsp</P>
<P>03/24/99  09:31p                 6,830 ActView.mak</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Doc</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          GenesisSDK</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Main</P>
<P>05/15/99  12:22a                   117 mssccprj.scc</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          res</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Util</P>
<P>              10 File(s)         13,572 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069856">Directory of C:\Genesis3D\OpenSource\Tools\ActView\Doc*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains help files and screen shots on how to use the ActView tool.</P>
</FONT><FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView\Doc</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>09/16/98  10:25a                   663 ActView.CNT</P>
<P>09/16/98  10:40a                47,616 ActView.doc</P>
<P>09/16/98  10:40a                   475 ActView.err</P>
<P>09/16/98  02:34p                16,112 ACTVIEW.HLP</P>
<P>09/16/98  10:40a                 3,580 ActView.hpj</P>
<P>09/14/98  03:13p                   455 ActView.rbh</P>
<P>09/16/98  10:40a                    59 ActView.rta</P>
<P>09/16/98  10:40a                50,231 ActView.rtf</P>
<P>09/16/98  10:40a                 1,093 ActView.rtk</P>
<P>09/16/98  10:40a                 1,633 ActView.rts</P>
<P>09/14/98  11:36a                   246 ffend.bmp</P>
<P>09/14/98  11:51a                   246 ffframe.bmp</P>
<P>09/14/98  12:36p                   438 frame.bmp</P>
<P>09/14/98  12:40p                   566 move.bmp</P>
<P>09/14/98  11:55a                   246 pan.bmp</P>
<P>09/14/98  11:56a                   246 pause.bmp</P>
<P>09/14/98  11:35a                   246 play.bmp</P>
<P>09/14/98  11:59a                   246 rotate.bmp</P>
<P>09/14/98  12:00p                   246 rrframe.bmp</P>
<P>09/14/98  12:01p                   246 rrstart.bmp</P>
<P>09/14/98  12:03p                   246 stop.bmp</P>
<P>09/14/98  12:04p                   246 zoom.bmp</P>
<P>              24 File(s)        125,381 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069857">Directory of C:\Genesis3D\OpenSource\Tools\ActView\GenesisSDK*</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the Genesis3D headers and the debug and release libraries.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView\GenesisSDK</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          include</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          lib</P>
<P>               4 File(s)              0 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069858">Directory of C:\Genesis3D\OpenSource\Tools\ActView\GenesisSDK\include</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains a copy of the header files used by Actview in compilation.  It is the same as those in the outer include directory.  They are included here, separately, to speed compilation times and to separate the compilation of the ActView tool from that of the Genesis3D engine.  In a final release of a newly developed product they should be identical.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView\GenesisSDK\include</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                23,693 actor.h</P>
<P>05/04/99  01:20p                 3,332 BASETYPE.H</P>
<P>05/04/99  01:20p                23,446 bitmap.h</P>
<P>04/26/99  11:26a                 5,570 body.h</P>
<P>04/27/99  11:53p                11,163 Errorlog.h</P>
<P>04/26/99  11:26a                 4,577 ExtBox.h</P>
<P>04/26/99  11:26a                13,334 font.H</P>
<P>04/26/99  11:26a                26,019 GENESIS.H</P>
<P>04/26/99  11:26a                 3,573 getypes.h</P>
<P>04/26/99  04:04p                 2,772 matrix33.h</P>
<P>04/26/99  11:26a                 9,662 motion.h</P>
<P>04/26/99  11:26a                 6,248 path.h</P>
<P>04/26/99  04:05p                 4,093 PhysicsJoint.h</P>
<P>04/26/99  04:05p                 8,619 PhysicsObject.h</P>
<P>04/26/99  04:04p                 3,183 PhysicsSystem.h</P>
<P>05/04/99  01:20p                 6,342 pixelformat.h</P>
<P>04/26/99  11:26a                 9,519 quatern.h</P>
<P>04/26/99  11:26a                 5,195 RAM.H</P>
<P>04/26/99  11:26a                 3,903 VEC3D.H</P>
<P>04/26/99  11:26a                 8,113 vfile.h</P>
<P>04/26/99  11:26a                 8,740 XFORM3D.H</P>
<P>              23 File(s)        191,096 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069859">Directory of C:\Genesis3D\OpenSource\Tools\ActView\GenesisSDK\lib*</A> </P>
</FONT><FONT FACE="Arial"><P>The files in this subdirectory are the libraries used by ActView in compilation.  They are the same as those used in the Gtest game and the outer /lib subdirectory.  They are included here, separately, to speed compilation times and to separate the compilation of the ActView tool from that of the Genesis3D engine.  In a final release of a newly developed product they should be identical.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView\GenesisSDK\lib</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>05/10/99  10:57p             1,182,298 genesis.lib</P>
<P>05/10/99  10:50p             3,630,406 genesisd.lib</P>
<P>               4 File(s)      4,812,704 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069860">Directory of C:\Genesis3D\OpenSource\Tools\ActView\Main</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the main code for the ActView tool.  </P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView\Main</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/28/99  11:24a                58,315 actview.c</P>
<P>12/22/98  09:04p                13,498 ActView.rc</P>
<P>04/26/99  11:26a                54,837 blender.c</P>
<P>04/26/99  11:26a                 2,537 Blender.h</P>
<P>12/22/98  09:04p                 5,800 resource.h</P>
<P>               7 File(s)        134,987 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069861">Directory of C:\Genesis3D\OpenSource\Tools\ActView\res*</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the resources which are compiled into the ActView tool.  It is primarily a series of small icon files which are used to decorate the buttons with functional representations. </P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView\res</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>09/15/98  01:20p                19,478 actview.bmp</P>
<P>09/17/98  04:40p                   766 blend.ico</P>
<P>09/09/98  02:16p                 1,078 ffend.ico</P>
<P>09/14/98  12:05p                 1,078 ffframe.ico</P>
<P>09/10/98  05:53p                   766 irotate.ico</P>
<P>09/11/98  04:26p                   766 mainicon.ico</P>
<P>09/10/98  05:34p                   326 pan.cur</P>
<P>09/14/98  12:05p                   766 pan.ico</P>
<P>09/09/98  02:26p                 1,078 pause.ico</P>
<P>09/09/98  02:16p                 1,078 play.ico</P>
<P>09/10/98  05:52p                   326 rotate.cur</P>
<P>09/14/98  11:59a                   766 rotate.ico</P>
<P>09/14/98  12:05p                 1,078 rrframe.ico</P>
<P>09/14/98  12:05p                 1,078 rrstart.ico</P>
<P>09/14/98  12:05p                 1,078 stop.ico</P>
<P>09/10/98  05:57p                   326 zoom.cur</P>
<P>09/10/98  05:04p                   766 zoom.ico</P>
<P>              19 File(s)         32,598 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069862">Directory of C:\Genesis3D\OpenSource\Tools\ActView\Util</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains a series of basic utilities used by the ActView tools.  </P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\ActView\Util</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                 2,606 About.c</P>
<P>04/26/99  11:26a                 2,030 about.h</P>
<P>04/26/99  11:26a                 6,303 drvlist.c</P>
<P>04/26/99  11:26a                 2,028 drvlist.h</P>
<P>04/26/99  11:26a                 6,282 FilePath.c</P>
<P>04/26/99  11:26a                 3,939 FilePath.h</P>
<P>04/26/99  11:26a                 3,953 InstCheck.c</P>
<P>04/26/99  11:26a                 2,262 InstCheck.h</P>
<P>04/26/99  11:26a                 2,800 rcstring.c</P>
<P>04/26/99  11:26a                 2,444 rcstring.h</P>
<P>04/26/99  11:26a                 2,641 units.h</P>
<P>04/26/99  11:26a                 3,114 WinUtil.c</P>
<P>04/26/99  11:26a                 2,551 WinUtil.h</P>
<P>              15 File(s)         42,953 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069863">Directory of C:\Genesis3D\OpenSource\Tools\Exporters</A></P>
</FONT><FONT FACE="Arial"><P>The code in this subdirectory is used for the creation of the two .dle files which are plugged into 3D Studio max to enable it to export .ACT files.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\Exporters</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>03/23/99  05:06p                 2,066 3dseres.h</P>
<P>03/23/99  05:06p                15,087 3dsimp.h</P>
<P>03/23/99  05:06p                 2,342 3dsires.h</P>
<P>04/26/99  12:57p                 5,248 3dsmtl.cpp</P>
<P>03/23/99  05:06p                 8,336 Cfile.h</P>
<P>04/26/99  12:58p                98,710 gexp.cpp</P>
<P>03/23/99  05:06p                   122 gexp.def</P>
<P>03/24/99  09:03a                 9,474 gexp.dsp</P>
<P>03/23/99  05:06p                 3,244 gexp.h</P>
<P>03/24/99  09:03a                 9,427 gexp.mak</P>
<P>03/23/99  05:06p                 5,874 gexp.rc</P>
<P>03/23/99  05:06p                 1,316 Kfio.h</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          max2sdk</P>
<P>05/15/99  12:22a                   116 mssccprj.scc</P>
<P>03/23/99  05:06p                 6,160 Mtldef.h</P>
<P>03/23/99  05:06p                 6,887 Ofile.h</P>
<P>04/26/99  12:59p                14,967 Savemli.cpp</P>
<P>              19 File(s)        189,376 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069864">Directory of C:\Genesis3D\OpenSource\Tools\Exporters\max2sdk*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains a readme file which directs the developer to another text file. That file explains how to place critical files from the 3D Studio Max Software Development Kit into this subdirectory.  This is done in order to be able to create the exporters that are used by 3D Studio Max to generate ACT files.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\Exporters\max2sdk</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>05/15/99  12:24a                    66 readme.txt</P>
<P>               3 File(s)             66 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069865">Directory of C:\Genesis3D\OpenSource\Tools\Fusion2</A></P>
</FONT><FONT FACE="Arial"><P>This is the outermost level of the Genesis3D editor Gedit.  The name Fusion2 was a code name for the project during development and it remains.  (It probably was not used as the name of the actual editor because the name is trademarked by another software company for a database product.)  This is a large subdirectory containing virtually all the code for the editor.  There is a documentation subdirectory and the common include and library subdirectories beneath it for compilation.  Unlike most of the code, which is in basic C,  this tool is an MFC C++ development effort.  </P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:27a                 2,266 about.cpp</P>
<P>04/26/99  11:26a                 2,496 about.h</P>
<P>04/26/99  11:27a                 3,723 ActivationWatch.cpp</P>
<P>04/26/99  11:26a                 2,775 ActivationWatch.h</P>
<P>04/26/99  11:26a                11,958 array.c</P>
<P>04/26/99  11:26a                 4,121 array.h</P>
<P>04/26/99  11:26a                 6,930 box3d.c</P>
<P>04/26/99  11:26a                 4,076 box3d.h</P>
<P>04/26/99  11:26a                87,937 brush.c</P>
<P>04/26/99  11:26a                10,584 brush.h</P>
<P>04/26/99  11:27a                13,155 BrushAttributesDialog.cpp</P>
<P>04/26/99  11:26a                 3,712 BrushAttributesDialog.h</P>
<P>04/26/99  11:27a                16,065 BrushEntityDialog.cpp</P>
<P>04/26/99  11:26a                 4,209 BrushEntityDialog.h</P>
<P>04/26/99  11:27a                15,525 BrushGroupDialog.cpp</P>
<P>04/26/99  11:26a                 3,699 BrushGroupDialog.h</P>
<P>04/26/99  11:26a                41,955 BrushTemplate.c</P>
<P>04/26/99  11:26a                 5,914 BrushTemplate.h</P>
<P>04/26/99  11:27a                 6,032 ChildFrm.cpp</P>
<P>04/26/99  11:26a                 3,031 ChildFrm.h</P>
<P>04/26/99  11:27a                 3,933 ColorBtn.cpp</P>
<P>04/26/99  11:26a                 2,506 ColorBtn.h</P>
<P>04/26/99  11:27a                 8,373 CompileDialog.cpp</P>
<P>04/26/99  11:26a                 3,413 CompileDialog.h</P>
<P>04/26/99  11:27a                13,375 Compiler.cpp</P>
<P>04/26/99  11:26a                 3,526 Compiler.h</P>
<P>04/26/99  11:27a                 6,198 ConsoleTab.cpp</P>
<P>04/26/99  11:26a                 3,823 ConsoleTab.h</P>
<P>04/26/99  11:27a                 5,727 CreateArchDialog.cpp</P>
<P>04/26/99  11:26a                 3,079 CreateArchDialog.h</P>
<P>04/26/99  11:27a                 7,211 CreateBoxDialog.cpp</P>
<P>04/26/99  11:26a                 3,320 CreateBoxDialog.h</P>
<P>04/26/99  11:27a                 4,965 CreateConeDialog.cpp</P>
<P>04/26/99  11:26a                 3,077 CreateConeDialog.h</P>
<P>04/26/99  11:27a                 7,854 CreateCylDialog.cpp</P>
<P>04/26/99  11:26a                 3,166 CreateCylDialog.h</P>
<P>04/26/99  11:27a                 5,699 CreateSpheroidDialog.cpp</P>
<P>04/26/99  11:26a                 3,223 CreateSpheroidDialog.h</P>
<P>04/26/99  11:27a                 4,656 CreateStaircaseDialog.cpp</P>
<P>04/26/99  11:26a                 3,013 CreateStaircaseDialog.h</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Deliver</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          Doc</P>
<P>04/26/99  11:27a                19,344 EntitiesDialog.cpp</P>
<P>04/26/99  11:26a                 3,565 EntitiesDialog.h</P>
<P>04/26/99  11:27a                24,432 Entity.cpp</P>
<P>04/26/99  11:26a                 6,207 Entity.h</P>
<P>05/11/99  12:13p                24,771 EntityTable.cpp</P>
<P>04/26/99  11:26a                 4,842 EntityTable.h</P>
<P>04/26/99  11:27a                 3,837 EntityVisDlg.cpp</P>
<P>04/26/99  11:26a                 3,284 EntityVisDlg.h</P>
<P>04/26/99  11:26a                 3,670 EntTypeName.c</P>
<P>04/26/99  11:26a                 2,261 EntTypeName.h</P>
<P>04/26/99  11:27a                 5,355 EntView.cpp</P>
<P>04/26/99  11:26a                 2,707 EntView.h</P>
<P>04/26/99  11:26a                38,122 face.c</P>
<P>04/26/99  11:26a                 6,714 face.h</P>
<P>04/26/99  11:27a                30,053 FaceAttributesDialog.cpp</P>
<P>04/26/99  11:26a                 5,228 FaceAttributesDialog.h</P>
<P>04/26/99  11:26a                12,519 FaceList.c</P>
<P>04/26/99  11:26a                 3,858 facelist.h</P>
<P>04/26/99  11:26a                 6,411 FilePath.c</P>
<P>04/26/99  11:26a                 3,946 FilePath.h</P>
<P>12/16/97  01:00p                   221 FUSION.CFG</P>
<P>05/11/99  11:55a                17,093 FUSION.cpp</P>
<P>03/24/99  09:51p                16,818 Fusion.dsp</P>
<P>04/26/99  11:26a                 4,440 FUSION.h</P>
<P>03/24/99  09:51p                19,917 Fusion.mak</P>
<P>12/03/97  01:00a                   768 fusion.pal</P>
<P>05/12/99  03:16p                73,799 FUSION.rc</P>
<P>12/03/97  01:00a               810,244 fusion.wad</P>
<P>05/11/99  12:04p               172,156 FUSIONDoc.cpp</P>
<P>04/26/99  11:26a                15,985 FUSIONDoc.h</P>
<P>04/26/99  11:27a                 8,335 FusionTabControls.cpp</P>
<P>04/26/99  11:26a                 3,674 FusionTabControls.h</P>
<P>04/26/99  11:27a                58,724 FUSIONView.cpp</P>
<P>04/26/99  11:26a                 7,895 FUSIONView.h</P>
<P>04/26/99  11:26a                 8,319 Gbsplib.h</P>
<P>12/09/98  09:41a                   140 gedit.ini</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          GenesisSDK</P>
<P>04/26/99  11:27a                 4,618 GridSizeDialog.cpp</P>
<P>04/26/99  11:26a                 2,969 GridSizeDialog.h</P>
<P>04/26/99  11:27a                20,204 group.cpp</P>
<P>04/26/99  11:26a                 5,250 group.h</P>
<P>04/26/99  11:27a                15,701 KeyEditDlg.cpp</P>
<P>04/26/99  11:26a                 7,818 KeyEditDlg.h</P>
<P>04/26/99  11:27a                41,207 level.cpp</P>
<P>04/26/99  11:26a                 8,229 level.h</P>
<P>04/26/99  11:27a                 3,605 LevelOptions.cpp</P>
<P>04/26/99  11:26a                 3,263 LevelOptions.h</P>
<P>04/26/99  11:26a                19,731 List.c</P>
<P>04/26/99  11:26a                 5,390 list.h</P>
<P>04/26/99  11:27a                25,882 MainFrm.cpp</P>
<P>04/26/99  11:26a                 5,100 MainFrm.h</P>
<P>04/26/99  11:26a                41,878 model.c</P>
<P>04/26/99  11:26a                 6,693 model.h</P>
<P>04/26/99  11:27a                45,056 ModelDialog.cpp</P>
<P>04/26/99  11:26a                 5,394 ModelDialog.h</P>
<P>05/15/99  12:23a                   116 mssccprj.scc</P>
<P>04/26/99  11:26a                 2,214 Mydef.h</P>
<P>04/26/99  11:26a                 7,006 node.c</P>
<P>04/26/99  11:26a                 2,343 node.h</P>
<P>04/26/99  11:26a                17,027 Parse3dt.c</P>
<P>04/26/99  11:26a                 3,302 Parse3dt.h</P>
<P>04/26/99  11:27a                 3,581 PreferencesDialog.cpp</P>
<P>04/26/99  11:26a                 3,329 PreferencesDialog.h</P>
<P>04/26/99  11:26a                 9,972 Prefs.c</P>
<P>04/26/99  11:26a                 3,361 prefs.h</P>
<P>04/26/99  11:26a               293,605 render.c</P>
<P>04/26/99  11:26a                 6,211 render.h</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          res</P>
<P>03/24/99  12:07p                23,939 resource.h</P>
<P>09/23/97  12:21p                   141 resource.hm</P>
<P>04/26/99  11:26a                 4,611 SelBrushList.c</P>
<P>04/26/99  11:26a                 2,698 SelBrushList.h</P>
<P>04/26/99  11:26a                 4,381 SelFaceList.c</P>
<P>04/26/99  11:26a                 2,595 SelFaceList.h</P>
<P>04/26/99  11:27a                10,261 SkyDialog.cpp</P>
<P>04/26/99  11:26a                 4,516 SkyDialog.h</P>
<P>04/26/99  11:26a                 3,271 stack.c</P>
<P>04/26/99  11:26a                 2,718 stack.h</P>
<P>04/26/99  11:26a                 2,855 StdAfx.h</P>
<P>04/30/99  04:35p                14,696 TextureDialog.cpp</P>
<P>04/26/99  05:49p                 3,358 TextureDialog.h</P>
<P>04/26/99  11:26a                10,118 typeio.c</P>
<P>04/26/99  11:26a                 5,381 typeio.h</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          TypeParser</P>
<P>04/26/99  11:27a                 6,869 undostack.cpp</P>
<P>04/26/99  11:26a                 2,808 undostack.h</P>
<P>04/26/99  11:26a                 2,913 units.h</P>
<P>04/26/99  11:26a                 5,241 util.c</P>
<P>04/26/99  11:26a                 2,580 util.h</P>
<P>04/26/99  11:27a                 5,147 WadFile.cpp</P>
<P>04/26/99  11:26a                 2,226 WadFile.h</P>
<P>             135 File(s)      2,523,332 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069866">Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\Deliver*</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains a number of items that are required in order to use the Genesis Editor, including the Texture Packing utility, the gedit.ini file (which establishes the defaults for the program, the txl file for establishing colors, and the font file for creating text.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\Deliver</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>06/14/97  07:12p                15,116 font.gfx</P>
<P>12/09/98  09:41a                   140 gedit.ini</P>
<P>05/29/98  05:16p               872,424 gedit.txl</P>
<P>11/20/97  02:53p                 4,876 spot.gfx</P>
<P>08/21/98  10:43a               305,152 tpack.exe</P>
<P>               7 File(s)      1,197,708 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069867">Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\Doc*</A> </P>
</FONT><FONT FACE="Arial"><P>The doc subdirectory file contains doc, txt and rtf files which document GEdit.  RoboHelp was used to generate the actual Help file and the HTML subdirectory below. </P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\Doc</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>07/26/88  10:00a               132,382 AWK.EXE</P>
<P>09/03/98  09:44a                 3,333 CVT.BAT</P>
<P>06/18/98  11:08a                   962 docco.txt</P>
<P>01/22/98  03:44p                 7,809 entities.txt</P>
<P>09/02/98  07:06p                   100 fixfont.awk</P>
<P>07/03/98  01:28p                 1,292 gedit.cnt</P>
<P>07/03/98  01:32p                19,968 gedit.doc</P>
<P>07/28/98  01:45p                   778 gedit.err</P>
<P>09/02/98  07:03p                36,528 GEDIT.HLP</P>
<P>07/03/98  02:22p                 3,475 gedit.hpj</P>
<P>07/03/98  01:33p                   500 gedit.rbh</P>
<P>07/03/98  01:32p                    59 gedit.rta</P>
<P>07/03/98  01:32p                 7,701 gedit.rtf</P>
<P>07/03/98  01:32p                    59 gedit.rtk</P>
<P>07/03/98  01:32p                   599 gedit.rts</P>
<P>07/28/98  01:40p                93,696 gedit2.doc</P>
<P>07/03/98  01:32p                   202 gedit2.rbh</P>
<P>07/28/98  01:40p                    59 gedit2.rta</P>
<P>07/28/98  01:40p               111,110 gedit2.rtf</P>
<P>07/28/98  01:40p                 2,127 gedit2.rtk</P>
<P>07/28/98  01:40p                 3,184 gedit2.rts</P>
<P>07/02/98  04:34p                19,456 howdoi.doc</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          html</P>
<P>              25 File(s)        445,379 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069868">Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\Doc\html*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains an HTML version of the Help file generated by RoboHelp.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\Doc\html</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>07/03/98  02:13p                   180 cnt0.gif</P>
<P>07/03/98  02:13p                   165 cnt1.gif</P>
<P>07/03/98  02:13p                   254 contents.gif</P>
<P>09/03/98  09:45a                 4,077 defaultgedit.html</P>
<P>07/03/98  02:13p                    60 gedit00090000.gif</P>
<P>09/03/98  09:45a                   906 geditAuto_rebuild.html</P>
<P>09/03/98  09:45a                 2,000 geditBasic_Operation.html</P>
<P>09/03/98  09:45a                 2,044 geditBrushes.html</P>
<P>09/03/98  09:45a                 1,520 geditBrush_and_Face_Modes.html</P>
<P>09/03/98  09:45a                 5,055 geditBrush_Attributes_Dialog.html</P>
<P>09/03/98  09:45a                 1,027 geditBSP_Settings.html</P>
<P>09/03/98  09:45a                 3,042 geditCamera_Mode.html</P>
<P>09/03/98  09:45a                 1,709 geditCompiling_and_Viewing_Your_Level.html</P>
<P>09/03/98  09:45a                   861 geditConsole.html</P>
<P>09/03/98  09:45a                 1,226 geditCut_Brushes_and_Brush_Order.html</P>
<P>09/03/98  09:45a                 1,910 geditEntities.html</P>
<P>09/03/98  09:45a                 1,516 geditEntity_Editor.html</P>
<P>09/03/98  09:45a                 1,402 geditEntity_Visibility_Dialog.html</P>
<P>09/03/98  09:45a                 1,259 geditFaces.html</P>
<P>09/03/98  09:45a                 3,882 geditFace_Attributes_Dialog.html</P>
<P>09/03/98  09:45a                 2,303 geditGeneral_Compile_Options.html</P>
<P>09/03/98  09:45a                 2,908 geditGroups.html</P>
<P>09/03/98  09:45a                 6,098 geditindex.html</P>
<P>09/03/98  09:45a                 2,657 geditLight_Settings.html</P>
<P>09/03/98  09:45a                 3,124 geditModels.html</P>
<P>09/03/98  09:45a                 2,245 geditOverview.html</P>
<P>09/03/98  09:45a                 1,902 geditQuick_Compile.html</P>
<P>09/03/98  09:45a                 3,463 geditSelect_Mode.html</P>
<P>09/03/98  09:45a                 4,779 geditShortcut_Keys.html</P>
<P>09/03/98  09:45a                 1,415 geditSky.html</P>
<P>09/03/98  09:45a                 2,732 geditTemplate.html</P>
<P>09/03/98  09:45a                 2,004 geditTemplate_Mode.html</P>
<P>09/03/98  09:45a                   911 geditTextures.html</P>
<P>09/03/98  09:45a                   982 geditThe_Camera_Entity.html</P>
<P>09/03/98  09:45a                 1,045 geditThe_Grid.html</P>
<P>09/03/98  09:45a                 3,271 geditThe_Initialization_File__GEDITIN.html</P>
<P>09/03/98  09:45a                   756 geditThe_Option_Pages.html</P>
<P>09/03/98  09:45a                 1,357 geditThe_Views.html</P>
<P>09/03/98  09:45a                   274 gedituntitled.html</P>
<P>09/03/98  09:45a                 8,509 geditUser_Defined_Entity_Header_Files.html</P>
<P>09/03/98  09:45a                 1,022 geditUser_Interface_Layout.html</P>
<P>09/03/98  09:45a                 1,105 geditVisibility_Settings.html</P>
<P>07/03/98  02:13p                   237 index.gif</P>
<P>07/03/98  02:13p                   162 index_a.gif</P>
<P>07/03/98  02:13p                   162 index_b.gif</P>
<P>07/03/98  02:13p                   163 index_c.gif</P>
<P>07/03/98  02:13p                   163 index_d.gif</P>
<P>07/03/98  02:13p                   159 index_e.gif</P>
<P>07/03/98  02:13p                   159 index_f.gif</P>
<P>07/03/98  02:13p                   165 index_g.gif</P>
<P>07/03/98  02:13p                   161 index_h.gif</P>
<P>07/03/98  02:13p                   162 index_i.gif</P>
<P>07/03/98  02:13p                   162 index_j.gif</P>
<P>07/03/98  02:13p                   162 index_k.gif</P>
<P>07/03/98  02:13p                   160 index_l.gif</P>
<P>07/03/98  02:13p                   162 index_m.gif</P>
<P>07/03/98  02:13p                   163 index_n.gif</P>
<P>07/03/98  02:13p                   162 index_o.gif</P>
<P>07/03/98  02:13p                   161 index_p.gif</P>
<P>07/03/98  02:13p                   164 index_q.gif</P>
<P>07/03/98  02:13p                   161 index_r.gif</P>
<P>07/03/98  02:13p                   164 index_s.gif</P>
<P>07/03/98  02:13p                   160 index_t.gif</P>
<P>07/03/98  02:13p                   163 index_u.gif</P>
<P>07/03/98  02:13p                   162 index_v.gif</P>
<P>07/03/98  02:13p                   163 index_w.gif</P>
<P>07/03/98  02:13p                   164 index_x.gif</P>
<P>07/03/98  02:13p                   161 index_y.gif</P>
<P>07/03/98  02:13p                   161 index_z.gif</P>
<P>09/03/98  09:45a                   145 logfile.html</P>
<P>07/03/98  02:13p                   188 next0.gif</P>
<P>07/03/98  02:13p                   190 next1.gif</P>
<P>07/03/98  02:13p                   186 prev0.gif</P>
<P>07/03/98  02:13p                   189 prev1.gif</P>
<P>              76 File(s)         94,303 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069869">Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\GenesisSDK*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the Genesis3D headers and the debug and release libraries.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\GenesisSDK</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          include</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          lib</P>
<P>               4 File(s)              0 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069870">Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\GenesisSDK\include</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains a copy of the header files used by GEdit in compilation.  It is the same as those in the outer include directory.  They are included here, separately, to speed compilation times and to separate the compilation of the GEdit tool from that of the Genesis3D engine.  In a final release of a newly developed product they should be identical.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\GenesisSDK\include</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                23,693 actor.h</P>
<P>05/03/99  03:55p                 3,332 BASETYPE.H</P>
<P>05/03/99  04:06p                23,446 bitmap.h</P>
<P>04/26/99  11:26a                 5,570 body.h</P>
<P>04/27/99  11:53p                11,163 Errorlog.h</P>
<P>04/26/99  11:26a                 4,577 ExtBox.h</P>
<P>04/26/99  11:26a                13,334 font.H</P>
<P>04/26/99  11:26a                26,019 GENESIS.H</P>
<P>04/26/99  11:26a                 3,573 getypes.h</P>
<P>04/26/99  11:26a                 9,662 motion.h</P>
<P>04/26/99  11:26a                 6,248 path.h</P>
<P>05/03/99  03:16p                 6,342 pixelformat.h</P>
<P>04/26/99  11:26a                 9,519 quatern.h</P>
<P>04/26/99  11:26a                 5,195 RAM.H</P>
<P>04/26/99  11:26a                 3,903 VEC3D.H</P>
<P>04/26/99  11:26a                 8,113 vfile.h</P>
<P>04/26/99  11:26a                 8,740 XFORM3D.H</P>
<P>              19 File(s)        172,429 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069871">Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\GenesisSDK\lib*</A></P>
</FONT><FONT FACE="Arial"><P>The files in this subdirectory are the libraries used by GEdit in compilation.  They are the same as those used in the Gtest game and the outer /lib subdirectory.  They are included here, separately, to speed compilation times and to separate the compilation of the GEdit tool from that of the Genesis3D engine.  In a final release of a newly developed product they should be identical.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\GenesisSDK\lib</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>05/11/99  04:23a             1,182,298 genesis.lib</P>
<P>05/11/99  04:16a             3,630,406 genesisd.lib</P>
<P>               4 File(s)      4,812,704 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069872">Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\res*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains all the resources used by the GEdit program including buttons, cursors and icons.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\res</P>

<P>05/17/99  06:33p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:33p        &lt;DIR&gt;          ..</P>
<P>09/23/97  12:21p                   766 actor.ico</P>
<P>02/17/98  05:58p                   766 arch.ico</P>
<P>11/07/97  12:57p                   326 arrow.cur</P>
<P>07/22/98  02:11p                 2,102 camera.bmp</P>
<P>02/17/98  05:58p                   766 cone.ico</P>
<P>11/06/97  11:29a                   766 Cross_m.cur</P>
<P>02/17/98  05:58p                   766 cube.ico</P>
<P>09/23/97  12:21p                16,502 cylinder.bmp</P>
<P>02/17/98  05:58p                   766 cylinder.ico</P>
<P>07/23/98  07:25p                 2,102 default.bmp</P>
<P>07/20/98  05:35p                   326 eyedropper.cur</P>
<P>03/17/98  10:10a                 1,078 ffend.ico</P>
<P>03/17/98  10:10a                 1,078 ffframe.ico</P>
<P>09/23/97  12:21p                 1,078 FUSION.ico</P>
<P>09/23/97  12:21p                   398 FUSION.rc2</P>
<P>09/23/97  12:21p                 1,078 FUSIONDoc.ico</P>
<P>04/21/98  05:49p                   958 groupbar.bmp</P>
<P>09/23/97  12:21p                 8,310 hollowbo.bmp</P>
<P>09/23/97  12:21p                 8,310 hollowsp.bmp</P>
<P>03/17/98  09:58a                 1,078 icoPlay.ico</P>
<P>02/17/98  05:58p                   766 libobj.ico</P>
<P>07/30/98  02:13p                 2,102 light.bmp</P>
<P>09/23/97  12:21p                   766 light.ico</P>
<P>07/22/98  02:11p                 2,102 modelorg.bmp</P>
<P>09/23/97  12:21p                   766 playstart.ico</P>
<P>11/06/97  04:15p                   326 pointer.cur</P>
<P>03/17/98  10:10a                 1,078 rrframe.ico</P>
<P>03/17/98  10:11a                 1,078 rrstart.ico</P>
<P>09/23/97  12:21p                 8,310 solidbox.bmp</P>
<P>09/23/97  12:21p                 8,310 solidsph.bmp</P>
<P>02/17/98  05:58p                   766 sphere.ico</P>
<P>07/22/98  02:11p                 2,102 spotlight.bmp</P>
<P>02/17/98  05:58p                   766 stairs.ico</P>
<P>03/17/98  10:10a                 1,078 stop.ico</P>
<P>01/07/99  12:20p                 1,558 Toolbar.bmp</P>
<P>10/13/98  12:52p                 1,318 toolbar1.bmp</P>
<P>11/17/96  12:00a                 1,758 Whoosh.wav</P>
<P>              39 File(s)         84,270 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069873">Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\TypeParser</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains all the header and code files for the Genesis Editor parsing routines. Gedit can read and parse both its own files and Quake style .map files.  It uses the resulting data to build a BSP tree of the walls, floors, ceilings and objects comprising the game level<I>.  </I>This data can be used to display the level in a variety of views and allows the level designer to manipulate the varoius objects in the level. </P>
<I>
</I></FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\Fusion2\TypeParser</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                28,444 cparser.c</P>
<P>04/26/99  11:26a                 3,705 cparser.h</P>
<P>04/26/99  11:26a                14,727 cscanner.c</P>
<P>04/26/99  11:26a                 2,338 cscanner.h</P>
<P>04/26/99  11:26a                 2,471 HASH.C</P>
<P>04/26/99  11:26a                 1,950 HASH.H</P>
<P>04/26/99  11:26a                 3,319 iden.C</P>
<P>04/26/99  11:26a                 2,293 iden.H</P>
<P>04/26/99  11:26a                 7,782 scanner.c</P>
<P>04/26/99  11:26a                 3,867 scanner.h</P>
<P>04/26/99  11:26a                 4,125 symtab.c</P>
<P>04/26/99  11:26a                 2,907 symtab.h</P>
<P>04/26/99  11:26a                 7,975 type.c</P>
<P>04/26/99  11:26a                 3,436 type.h</P>
<P>              16 File(s)         89,339 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069874">Directory of C:\Genesis3D\OpenSource\Tools\GBSPLib</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the code for building the Binary Space Partition tree used by the Genesis3D game engine.  The code in this library takes the layout of the floors, walls, ceilings and objects in the room and uses it to create a binary tree that can be rapidly searched by the Geneis3D engine at game time to determine what objects are visible to the player at any given location.  The Genesis3D engine combines both Binary Space Partitioning and Portal technology to provide very fast search and rendering times.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\GBSPLib</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>05/06/99  04:57p                33,486 Brush2.cpp</P>
<P>04/26/99  11:26a                 3,817 BRUSH2.H</P>
<P>04/26/99  11:27a                12,486 BSP.CPP</P>
<P>04/26/99  11:26a                 7,944 BSP.H</P>
<P>04/26/99  11:27a                37,771 Bsp2.cpp</P>
<P>03/04/98  03:19p                 1,903 build.bat</P>
<P>04/26/99  11:27a                11,681 Fill.Cpp</P>
<P>04/26/99  11:26a                 1,993 Fill.h</P>
<P>04/26/99  11:27a                18,427 GBSPFILE.CPP</P>
<P>04/26/99  11:26a                11,213 GBSPFILE.H</P>
<P>04/26/99  11:27a                 7,622 Gbsplib.cpp</P>
<P>03/24/99  04:14p                 7,680 GBSPLib.dsp</P>
<P>04/26/99  11:26a                 4,143 Gbsplib.h</P>
<P>03/24/99  04:14p                 8,563 GBSPLib.mak</P>
<P>04/26/99  11:27a                30,268 GBSPPREP.CPP</P>
<P>04/26/99  11:26a                 2,132 GBSPPREP.H</P>
<P>04/26/99  11:27a                17,026 Leaf.cpp</P>
<P>04/26/99  11:26a                 2,314 Leaf.h</P>
<P>05/11/99  12:09a                44,204 LIGHT.CPP</P>
<P>05/10/99  09:15p                 6,411 LIGHT.H</P>
<P>04/26/99  11:27a                20,468 MAP.CPP</P>
<P>04/26/99  11:26a                 4,324 MAP.H</P>
<P>04/26/99  11:27a                 4,545 MATHLIB.CPP</P>
<P>04/26/99  11:26a                 2,709 MATHLIB.H</P>
<P>05/15/99  12:23a                   117 mssccprj.scc</P>
<P>05/10/99  09:15p                43,352 POLY.CPP</P>
<P>04/26/99  11:26a                 3,692 POLY.H</P>
<P>04/26/99  11:27a                18,225 PORTALS.CPP</P>
<P>04/26/99  11:26a                 2,379 PORTALS.H</P>
<P>04/26/99  11:27a                12,020 PortFile.cpp</P>
<P>04/26/99  11:27a                46,179 RAD.CPP</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          SDKShare</P>
<P>04/26/99  11:27a                10,298 TEXTURE.CPP</P>
<P>04/26/99  11:26a                 3,240 TEXTURE.H</P>
<P>04/26/99  11:27a                12,534 TJunct.cpp</P>
<P>04/26/99  11:27a                 4,479 Utils.cpp</P>
<P>04/26/99  11:26a                 2,241 Utils.h</P>
<P>04/26/99  11:27a                18,954 VIS.CPP</P>
<P>04/26/99  11:26a                 3,326 VIS.H</P>
<P>04/26/99  11:27a                16,250 VISFLOOD.CPP</P>
<P>              42 File(s)        500,416 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069875">Directory of C:\Genesis3D\OpenSource\Tools\GBSPLib\SDKShare*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the Genesis3D headers and the debug and release libraries.  The header files in this subdirectory do differ from the other similar tool subdirectories.  The changes are detailed below.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\GBSPLib\SDKShare</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          Include</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          Lib</P>
<P>               4 File(s)              0 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069876">Directory of C:\Genesis3D\OpenSource\Tools\GBSPLib\SDKShare\Include</A></P>
</FONT><FONT FACE="Arial"><P>Although the include subdirectory is similar to most of the other include subdirectories for the other tools,  this subdirectory lacks the actor.h, body.h, ExtBox.h  and font.h files.  In addition it adds Dcommon.h - a header file of common data routines containing much of the same information found in the previous four files along with special functions for manipulating that data which is only required for this tool.  They are specificially left out of the other tool files and the engine to avoid "code bloat", speed compile times and enhance performance.</P>
</FONT><FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\GBSPLib\SDKShare\Include</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>05/03/99  03:55p                 3,332 BASETYPE.H</P>
<P>05/03/99  04:06p                23,446 bitmap.h</P>
<P>05/10/99  03:30p                16,061 Dcommon.h</P>
<P>04/27/99  11:53p                11,163 Errorlog.h</P>
<P>05/13/99  08:27p                26,220 GENESIS.H</P>
<P>04/26/99  10:53a                 3,573 getypes.h</P>
<P>04/26/99  10:53a                 9,662 motion.h</P>
<P>04/26/99  10:53a                 6,248 path.h</P>
<P>05/03/99  03:16p                 6,342 pixelformat.h</P>
<P>04/26/99  10:53a                 9,519 quatern.h</P>
<P>04/26/99  10:53a                 5,195 RAM.H</P>
<P>04/26/99  10:53a                 3,903 VEC3D.H</P>
<P>04/26/99  10:53a                 8,113 vfile.h</P>
<P>04/26/99  10:53a                 8,740 XFORM3D.H</P>
<P>              16 File(s)        141,517 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069877">Directory of C:\Genesis3D\OpenSource\Tools\GBSPLib\SDKShare\Lib*</A> </P>
</FONT><FONT FACE="Arial"><P>The files in this subdirectory are the libraries used by GBSPLib portion of GEdit in compilation.  They are the same as those used in the Gtest game and the outer /lib subdirectory.  They are included here, separately, to speed compilation times and to separate the compilation of GBSPLib which is called by the GEdit tool from that of the Gedit itself and the Genesis3D engine.  In a final release of a newly developed product they <U>must</U> be identical.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\GBSPLib\SDKShare\Lib</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>03/25/99  12:47p             1,123,596 genesis.lib</P>
<P>03/25/99  12:40p             3,428,610 genesisd.lib</P>
<P>               4 File(s)      4,552,206 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069878">Directory of C:\Genesis3D\OpenSource\Tools\GPreview</A></P>
</FONT><FONT FACE="Arial"><P>Code in this library is used to create a simple Genesis3D level viewer.  </P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\GPreview</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>01/13/99  02:58p                 1,336 cursor.BMP</P>
<P>04/09/99  02:23p                 5,119 drvlist.c</P>
<P>04/09/99  01:35p                   207 drvlist.h</P>
<P>03/10/99  01:43p                 8,208 function.c</P>
<P>03/16/98  11:55a                 2,145 function.h</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          genesissdk</P>
<P>04/09/99  01:54p                30,474 gpreview.c</P>
<P>04/01/99  04:05p                 4,665 GPreview.dsp</P>
<P>03/17/99  12:57p                 4,995 GPreview.mak</P>
<P>04/09/99  02:19p                 2,302 gpreview.rc</P>
<P>05/15/99  12:23a                   119 mssccprj.scc</P>
<P>03/17/99  12:47p                   627 resource.h</P>
<P>01/13/99  05:32p                 5,303 Spot.bmp</P>
<P>              15 File(s)         65,500 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069879">Directory of C:\Genesis3D\OpenSource\Tools\GPreview\genesissdk*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the Genesis3D headers and the debug and release libraries.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\GPreview\genesissdk</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          include</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          lib</P>
<P>               4 File(s)              0 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069880">Directory of C:\Genesis3D\OpenSource\Tools\GPreview\genesissdk\include</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains a copy of the header files used by GPreview in compilation.  It is the same as those in the outer include directory.  They are included here, separately, to speed compilation times and to separate the compilation of the GPreview tool from that of the Genesis3D engine.  In a final release of a newly developed product they should be identical.</P>
</FONT><FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\GPreview\genesissdk\include</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                23,693 actor.h</P>
<P>04/26/99  11:26a                 2,685 BASETYPE.H</P>
<P>04/26/99  11:26a                21,977 bitmap.h</P>
<P>04/26/99  11:26a                 5,570 body.h</P>
<P>04/26/99  11:26a                11,081 Errorlog.h</P>
<P>04/26/99  11:26a                 4,577 ExtBox.h</P>
<P>04/26/99  11:26a                13,334 font.H</P>
<P>04/26/99  11:26a                26,019 GENESIS.H</P>
<P>04/26/99  11:26a                 3,573 getypes.h</P>
<P>04/26/99  11:26a                 9,662 motion.h</P>
<P>04/26/99  11:26a                 6,248 path.h</P>
<P>04/26/99  11:26a                 6,424 pixelformat.h</P>
<P>04/26/99  11:26a                 9,519 quatern.h</P>
<P>04/26/99  11:26a                 5,195 RAM.H</P>
<P>04/26/99  11:26a                 3,903 VEC3D.H</P>
<P>04/26/99  11:26a                 8,113 vfile.h</P>
<P>04/26/99  11:26a                 8,740 XFORM3D.H</P>
<P>              19 File(s)        170,313 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069881">Directory of C:\Genesis3D\OpenSource\Tools\GPreview\genesissdk\lib*</A></P>
</FONT><FONT FACE="Arial"><P>The files in this subdirectory are the libraries used by GPreview in compilation.  They are the same as those used in the Gtest game and the outer /lib subdirectory.  They are included here, separately, to speed compilation times and to separate the compilation of the GPreview tool from that of the Genesis3D engine.  In a final release of a newly developed product they should be identical.</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Directory of C:\Genesis3D\OpenSource\Tools\GPreview\genesissdk\lib</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>03/25/99  04:13p             1,123,596 genesis.lib</P>
<P>03/25/99  04:06p             3,428,610 genesisd.lib</P>
<P>               4 File(s)      4,552,206 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069882">Directory of C:\Genesis3D\OpenSource\Tools\mkactor*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory is used to create the Genesis3D tools, Actor Studio, and ActBuild.  These tools are used to create ACT files from 3D Studio Max files.  Actor Studio is a windows based program for working on a single model.  ActBuild is a batch translation version.</P>

<P>The outer subdirectory contains the Microsoft  "dsp" and "make" files for compiling the programs. It should be noted here that the mkactor subdirectory name here is a bit misleading since there is also a mkactor subdirectory beneath this one which contains code for making and parsing actor scripts.  The subdirectory name here should have probably been something else more informative.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ActBuild</P>
<P>03/22/99  05:44p                 7,898 ActBuild.dsp</P>
<P>03/22/99  05:44p                 9,171 ActBuild.mak</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          AStudio</P>
<P>03/24/99  09:37p                11,460 AStudio.dsp</P>
<P>03/24/99  09:37p                13,792 AStudio.mak</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          common</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          Debug</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          fmtactor</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          GenesisSDK</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          mkactor</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          mkbody</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          mkmotion</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          mop</P>
<P>05/15/99  12:24a                   193 mssccprj.scc</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          Release</P>
<P>              18 File(s)         42,514 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069883">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\ActBuild</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the header and C source for the ActBuild program.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\ActBuild</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                 6,270 ActBuild.c</P>
<P>04/26/99  11:26a                 2,405 ActBuild.h</P>
<P>               4 File(s)          8,675 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069884">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\AStudio</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory is the base directory for the Actor Studio application.  Actor Studio is an MFC Windows Application and consists of several header, C and C++ files.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\AStudio</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                 5,075 AOptions.c</P>
<P>04/26/99  11:26a                 2,786 AOptions.h</P>
<P>04/26/99  11:26a                43,144 AProject.c</P>
<P>04/26/99  11:26a                 7,231 AProject.h</P>
<P>04/26/99  11:27a                 7,747 AStudio.cpp</P>
<P>04/26/99  11:26a                 3,116 AStudio.h</P>
<P>12/16/98  02:57p                19,223 AStudio.rc</P>
<P>04/26/99  11:27a                 7,428 BodyDlg.cpp</P>
<P>04/26/99  11:26a                 3,486 BodyDlg.h</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          HLP</P>
<P>04/26/99  11:27a                 2,791 LogoPage.cpp</P>
<P>04/26/99  11:26a                 3,079 LogoPage.h</P>
<P>04/26/99  11:26a                49,089 make.c</P>
<P>04/26/99  11:26a                 2,447 make.h</P>
<P>10/22/98  06:39p                 1,632 MakeHelp.bat</P>
<P>04/26/99  11:27a                 6,791 MakeHelp.cpp</P>
<P>04/26/99  11:26a                 2,456 MakeHelp.h</P>
<P>04/26/99  11:27a                17,919 MaterialsDlg.cpp</P>
<P>04/26/99  11:26a                 4,085 MaterialsDlg.h</P>
<P>04/26/99  11:27a                20,668 MotionsDlg.cpp</P>
<P>04/26/99  11:26a                 4,269 MotionsDlg.h</P>
<P>04/26/99  11:26a                 8,684 mxscript.c</P>
<P>04/26/99  11:26a                 2,489 mxscript.h</P>
<P>04/26/99  11:27a                 2,674 MyFileDlg.cpp</P>
<P>04/26/99  11:26a                 1,997 MyFileDlg.h</P>
<P>04/26/99  11:27a                 3,134 NewPrjDlg.cpp</P>
<P>04/26/99  11:26a                 2,985 NewPrjDlg.h</P>
<P>04/26/99  11:27a                 4,324 PathsDlg.cpp</P>
<P>04/26/99  11:26a                 3,368 PathsDlg.h</P>
<P>04/26/99  11:27a                 3,195 PropPage.cpp</P>
<P>04/26/99  11:26a                 3,090 PropPage.h</P>
<P>04/26/99  11:27a                27,468 PropSheet.cpp</P>
<P>04/26/99  11:26a                 5,345 PropSheet.h</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          RES</P>
<P>11/04/98  01:26p                 7,741 resource.h</P>
<P>04/26/99  11:27a                 5,712 SettingsDlg.cpp</P>
<P>04/26/99  11:26a                 3,584 SettingsDlg.h</P>
<P>04/26/99  11:27a                 1,951 StdAfx.cpp</P>
<P>04/26/99  11:26a                 2,672 StdAfx.h</P>
<P>04/26/99  11:27a                 5,661 TargetDlg.cpp</P>
<P>04/26/99  11:26a                 3,455 TargetDlg.h</P>
<P>04/26/99  11:27a                 3,057 TextInputDlg.cpp</P>
<P>04/26/99  11:26a                 3,062 TextInputDlg.h</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          Util</P>
<P>              46 File(s)        320,110 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069885">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\AStudio\HLP*</A></P>
</FONT><FONT FACE="Arial"><P>The HLP subdirectory contains the Help files for the Actor Studio Application.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\AStudio\HLP</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>10/14/98  04:05p                 3,891 AfxDlg.rtf</P>
<P>10/14/98  04:05p                   121 AStudio.cnt</P>
<P>10/22/98  05:44p                 5,992 ASTUDIO.HLP</P>
<P>10/22/98  05:44p                 1,625 AStudio.hm</P>
<P>10/22/98  06:40p                 2,287 AStudio.hpj</P>
<P>10/22/98  05:44p                 1,023 AStudio.LOG</P>
<P>10/14/98  04:11p                     0 AStudio.ph</P>
<P>               9 File(s)         14,939 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069886">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\AStudio\RES*</A></P>
</FONT><FONT FACE="Arial"><P>The RES Subdirectory contains the resources - icons and bitmaps - for the Actor Studio Application</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\AStudio\RES</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>10/14/98  04:29p                19,478 ACTVIEW.BMP</P>
<P>11/16/98  11:08p                   766 AStudio.ico</P>
<P>10/14/98  04:05p                   399 AStudio.rc2</P>
<P>               5 File(s)         20,643 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069887">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\AStudio\Util</A></P>
</FONT><FONT FACE="Arial"><P>The Util subdirectory contains several general utility routines for use by the Actor Studio application including string routines, and array routines and a file path routine.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\AStudio\Util</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                12,293 Array.c</P>
<P>04/26/99  11:26a                 4,028 ARRAY.H</P>
<P>04/26/99  11:26a                 6,202 FilePath.c</P>
<P>04/26/99  11:26a                 3,861 FilePath.h</P>
<P>04/26/99  11:26a                 2,806 RCSTRING.C</P>
<P>04/26/99  11:26a                 2,470 RCSTRING.H</P>
<P>04/26/99  11:26a                 5,289 UTIL.C</P>
<P>04/26/99  11:26a                 2,544 UTIL.H</P>
<P>              10 File(s)         39,493 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069888">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\common</A></P>
</FONT><FONT FACE="Arial"><P>The common subdirectory contains routines that are shared by both the Actor Studio and ActBuild programs.  These include matrix math routines, a set of utilities to issue return codes, and routines to create, build, and destroy an animated model.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\common</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                10,709 maxmath.c</P>
<P>04/26/99  11:26a                 2,287 maxmath.h</P>
<P>04/26/99  11:26a                 8,659 mkutil.c</P>
<P>04/26/99  11:26a                 2,466 mkutil.h</P>
<P>04/26/99  11:26a                 5,313 TDBody.c</P>
<P>04/26/99  11:26a                 2,269 TDBody.h</P>
<P>               8 File(s)         31,703 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069889">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\Debug*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains a single text file stating that the debug versions of the code will be created here.</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\Debug</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>03/24/99  09:48p                    40 Debug.txt</P>
<P>               3 File(s)             40 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069890">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\fmtactor</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the header and C code for the functions used by ActBuild and Actor Studio.  It is the basic description of the format of an actor script file and includes routines for creating, destroying and parsing actor script instructions.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\fmtactor</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                10,630 fmtactor.c</P>
<P>04/26/99  11:26a                 2,229 fmtactor.h</P>
<P>               4 File(s)         12,859 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069891">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\GenesisSDK*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the Genesis3D headers and the debug and release libraries.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\GenesisSDK</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          include</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          lib</P>
<P>               4 File(s)              0 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069892">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\GenesisSDK\include</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains a copy of the header files used by both ActBuild and AStudio in compilation.  It is the same as those in the outer include directory.  They are included here, separately, to speed compilation times and to separate the compilation of the code from that of the Genesis3D engine.  In a final release of a newly developed product they should be identical. </P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\GenesisSDK\include</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                23,693 actor.h</P>
<P>04/26/99  11:26a                 2,685 BASETYPE.H</P>
<P>04/26/99  11:26a                21,977 bitmap.h</P>
<P>04/26/99  11:26a                 5,570 body.h</P>
<P>04/26/99  11:26a                11,081 Errorlog.h</P>
<P>04/26/99  11:26a                 4,577 ExtBox.h</P>
<P>04/26/99  11:26a                13,334 font.H</P>
<P>04/26/99  11:26a                26,019 GENESIS.H</P>
<P>04/26/99  11:26a                 3,573 getypes.h</P>
<P>04/26/99  11:26a                 9,662 motion.h</P>
<P>04/26/99  11:26a                 6,248 path.h</P>
<P>04/26/99  11:26a                 6,424 pixelformat.h</P>
<P>04/26/99  11:26a                 9,519 quatern.h</P>
<P>04/26/99  11:26a                 5,195 RAM.H</P>
<P>10/28/98  12:53p                 1,232 strblock.h</P>
<P>04/26/99  11:26a                 3,903 VEC3D.H</P>
<P>04/26/99  11:26a                 8,113 VFILE.H</P>
<P>04/26/99  11:26a                 8,740 XFORM3D.H</P>
<P>              20 File(s)        171,545 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069893">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\GenesisSDK\lib*</A></P>
</FONT><FONT FACE="Arial"><P>The files in this subdirectory are the libraries used by both Astudio and ActBuild in compilation.  They are the same as those used in the Gtest game and the outer /lib subdirectory.  They are included here, separately, to speed compilation times and to separate the compilation of these tools from that of the Genesis3D engine.  In a final release of a newly developed product they should be identical.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\GenesisSDK\lib</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>03/25/99  12:47p             1,123,596 genesis.lib</P>
<P>03/25/99  12:40p             3,428,610 genesisd.lib</P>
<P>               4 File(s)      4,552,206 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069894">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\mkactor</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the header and C code for the functions used by ActBuild and Actor Studio to create, destroy and parse actor scripts.</P>
<I>
</I></FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\mkactor</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                 9,717 mkactor.c</P>
<P>04/26/99  11:26a                 2,452 mkactor.h</P>
<P>               4 File(s)         12,169 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069895">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\mkbody</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the header and C code for the functions used by ActBuild and Actor Studio to parse a 3D Studio Max file and a Physique file with the appropriate textures to create an actor body.</P>
<I>
</I></FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\mkbody</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:27a                63,821 mkbody.cpp</P>
<P>04/26/99  11:26a                 2,446 mkbody.h</P>
<P>04/26/99  11:26a                12,194 vph.c</P>
<P>04/26/99  11:26a                 1,934 vph.h</P>
<P>               6 File(s)         80,395 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069896">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\mkmotion</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the header and C code for the functions used by ActBuild and Actor Studio to move and 3D Studio generated ACT file.</P>
<I>
</I></FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\mkmotion</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                30,613 mkmotion.c</P>
<P>04/26/99  11:26a                 2,468 mkmotion.h</P>
<P>               4 File(s)         33,081 bytes</P>
</FONT><I><FONT FACE="Arial"><P>&nbsp;</P>
</I></FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069897">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\mop</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the header and C code for the functions used by ActBuild and Actor Studio to create logs of character motions.</P>
<I>
</I></FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\mop</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                 7,323 Log.c</P>
<P>04/26/99  11:26a                 2,900 Log.h</P>
<P>04/26/99  11:26a                14,268 mopshell.c</P>
<P>04/26/99  11:26a                 2,452 mopshell.h</P>
<P>04/26/99  11:26a                14,747 pop.c</P>
<P>04/26/99  11:26a                 1,945 pop.h</P>
<P>               8 File(s)         43,635 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069898">Directory of C:\Genesis3D\OpenSource\Tools\mkactor\Release*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains a single text file stating that Release versions of the code will be created here.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\mkactor\Release</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>03/24/99  09:48p                    42 Release.txt</P>
<P>               3 File(s)             42 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069899">Directory of C:\Genesis3D\OpenSource\Tools\Tpack*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains compile instructions for the texture packing utility, Tpack,</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\TPack</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>03/10/99  05:09p                 1,283 build.bat</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          GenesisSDK</P>
<P>05/15/99  12:24a                   113 mssccprj.scc</P>
<P>03/10/99  02:12p                   572 pull.bat</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          res</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          Source</P>
<P>03/05/99  03:56p                 5,321 TPack.dsp</P>
<P>03/10/99  01:55p                 5,265 TPack.mak</P>
<P>              10 File(s)         12,554 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069900">Directory of C:\Genesis3D\OpenSource\Tools\TPack\GenesisSDK*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the Genesis3D headers and the debug and release libraries.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\TPack\GenesisSDK</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          include</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          lib</P>
<P>               4 File(s)              0 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069901">Directory of C:\Genesis3D\OpenSource\Tools\TPack\GenesisSDK\include</A> </P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains a copy of the header files used by TPack in compilation.  It is the same as those in the outer include directory.  They are included here, separately, to speed compilation times and to separate the compilation of the code from that of the Genesis3D engine.  In a final release of a newly developed product they should be identical. </P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\TPack\GenesisSDK\include</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/26/99  11:26a                23,693 actor.h</P>
<P>04/26/99  11:26a                 2,685 BASETYPE.H</P>
<P>04/26/99  11:26a                21,977 bitmap.h</P>
<P>04/26/99  11:26a                 5,570 body.h</P>
<P>04/26/99  11:26a                11,081 Errorlog.h</P>
<P>04/26/99  11:26a                 4,577 ExtBox.h</P>
<P>04/26/99  11:26a                13,334 font.H</P>
<P>04/26/99  11:26a                26,019 GENESIS.H</P>
<P>04/26/99  11:26a                 3,573 getypes.h</P>
<P>04/26/99  11:26a                 9,662 motion.h</P>
<P>04/26/99  11:26a                 6,248 path.h</P>
<P>04/26/99  11:26a                 6,424 pixelformat.h</P>
<P>04/26/99  11:26a                 9,519 quatern.h</P>
<P>04/26/99  11:26a                 5,195 RAM.H</P>
<P>04/26/99  11:26a                 3,903 VEC3D.H</P>
<P>04/26/99  11:26a                 8,113 vfile.h</P>
<P>04/26/99  11:26a                 8,740 XFORM3D.H</P>
<P>              19 File(s)        170,313 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069902">Directory of C:\Genesis3D\OpenSource\Tools\TPack\GenesisSDK\lib*</A></P>
</FONT><FONT FACE="Arial"><P>The files in this subdirectory are the libraries used by TPack in compilation.  They are the same as those used in the Gtest game and the outer /lib subdirectory.  They are included here, separately, to speed compilation times and to separate the compilation of this tool from that of the Genesis3D engine.  In a final release of a newly developed product they should be identical.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\TPack\GenesisSDK\lib</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>03/25/99  12:47p             1,123,596 genesis.lib</P>
<P>03/25/99  12:40p             3,428,610 genesisd.lib</P>
<P>               4 File(s)      4,552,206 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069903">Directory of C:\Genesis3D\OpenSource\Tools\TPack\res<I>*</A></P>
</I></FONT><FONT FACE="Arial"><P>This subdirectory contains a single icon file that is used when the TPack utility is minimized</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\TPack\res</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>03/09/99  09:44a                   766 mainicon.ico</P>
<P>               3 File(s)            766 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069904">Directory of C:\Genesis3D\OpenSource\Tools\TPack\Source</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains the resource header file and the C code for the TPack program.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\OpenSource\Tools\TPack\Source</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>03/09/99  10:16a                 6,075 resource.h</P>
<P>04/26/99  11:26a                23,165 TPack.c</P>
<P>03/09/99  10:16a                 3,597 TPack.rc</P>
<P>               5 File(s)         32,837 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069905">Directory of C:\Genesis3D\Redist*</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains a single Microsoft file, CTL3D32.DLL that is necessary for the running of the example program and is not present on all systems in this version.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\Redist</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>10/31/97  11:40a                27,136 CTL3D32.DLL</P>
<P>               3 File(s)         27,136 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069906">Directory of C:\Genesis3D\src</A></P>
</FONT><FONT FACE="Arial"><P>The src directory contains the entire source in the GTest example program.  It has four subdirectories in addition to the outer directory.  The outer directory contains code for Network management, the console, and video selection.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\src</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/29/99  01:02a                 3,949 AutoSelect.c</P>
<P>04/18/99  03:06p                 1,655 AutoSelect.h</P>
<P>07/27/98  07:02p                 2,104 bolt.bmp</P>
<P>05/12/99  02:08p                 7,901 BUFFER.C</P>
<P>05/12/99  02:08p                 3,062 BUFFER.H</P>
<P>07/23/98  09:41p                 2,880 CD.C</P>
<P>08/13/97  08:07p                   517 CD.H</P>
<P>05/14/99  09:14p                96,298 Client.c</P>
<P>05/14/99  08:35p                 8,073 CLIENT.H</P>
<P>05/13/99  02:53p                17,222 CONSOLE.C</P>
<P>05/13/99  12:08p                 3,791 CONSOLE.H</P>
<P>07/30/98  09:57a                 2,104 corona.BMP</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          DrvMenu</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          FX</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          Game</P>
<P>05/13/99  12:55p                41,202 GameMgr.c</P>
<P>05/13/99  12:55p                 6,764 Gamemgr.h</P>
<P>05/14/99  08:05p                31,253 Genvs.c</P>
<P>05/11/99  03:06p                39,973 GMENU.C</P>
<P>04/14/99  01:59p                 3,554 GMENU.H</P>
<P>04/27/99  11:57p                10,621 GTest.dsp</P>
<P>04/27/99  11:57p                13,977 GTest.mak</P>
<P>05/15/99  12:19a                 7,065 GTestd.txt</P>
<P>05/15/99  12:21a                 7,670 GTestr.txt</P>
<P>05/14/99  08:33p                 8,700 Host.c</P>
<P>05/12/99  07:09p                 3,391 HOST.H</P>
<P>04/07/99  12:28a                 2,245 ipaddr.c</P>
<P>04/07/99  12:33a                   169 ipaddr.h</P>
<P>04/14/99  02:33p                34,457 MENU.C</P>
<P>04/14/99  02:33p                 5,086 MENU.H</P>
<P>04/14/99  02:33p                 4,918 MENUITEM.H</P>
<P>05/10/99  12:36p                 7,401 modelist.c</P>
<P>04/23/99  02:57p                 2,220 ModeList.h</P>
<P>05/15/99  12:17a                   105 mssccprj.scc</P>
<P>05/13/99  08:58p                10,096 NetMgr.c</P>
<P>05/13/99  06:03p                 6,399 NetMgr.h</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          Procedurals</P>
<P>05/14/99  11:14p                96,653 Server.c</P>
<P>05/14/99  06:47p                 7,023 Server.h</P>
<P>07/29/98  04:05p                 2,104 Terminus.BMP</P>
<P>04/14/99  12:00a                 8,951 TEXT.C</P>
<P>04/13/99  11:30p                 1,666 TEXT.H</P>
<P>04/16/99  01:48a                 2,033 VidMode.c</P>
<P>04/16/99  01:38a                 1,688 VidMode.h</P>
<P>              46 File(s)        516,940 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069907">Directory of C:\Genesis3D\src\DrvMenu</A></P>
</FONT><FONT FACE="Arial"><P>When the sample game begins the user selects, which video driver and which video mode they wish to use.  This code is used to implement the user's selections.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\src\DrvMenu</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>04/15/99  05:11p                 6,585 DRVLIST.C</P>
<P>04/15/99  05:11p                 1,566 DRVLIST.H</P>
<P>04/15/99  04:10p                   783 genvs.rc</P>
<P>04/15/99  02:44p                   593 RESOURCE.H</P>
<P>               6 File(s)          9,527 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069908">Directory of C:\Genesis3D\src\FX</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains various animated lighting effects including coronas, smoke, and particle trails, electric bolts, and dynamic lights.  These effects are used in the first two levels of the sample game.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\src\FX</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>01/13/99  07:05p                 4,992 corona.c</P>
<P>01/05/99  06:56p                 2,242 corona.h</P>
<P>04/28/99  12:12a                 4,838 DynLight.c</P>
<P>01/13/99  07:13p                 1,981 DynLight.h</P>
<P>04/19/99  11:55a                17,198 electric.c</P>
<P>01/05/99  07:09p                 2,628 electric.h</P>
<P>03/18/99  01:31p                21,373 Fx.c</P>
<P>03/18/99  01:31p                 3,736 Fx.h</P>
<P>04/28/99  12:12a                 2,440 ModelCtl.c</P>
<P>01/13/99  07:13p                   614 ModelCtl.h</P>
<P>              12 File(s)         62,042 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069909">Directory of C:\Genesis3D\src\Game</A></P>
</FONT><FONT FACE="Arial"><P>The game subdirectory contains the main routines for the game as well as the AI code for the "bots" which can be placed into the game, and the code for the individual weapons.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\src\Game</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>05/04/99  04:01p                 8,788 Attacker.c</P>
<P>11/11/98  11:22p                   609 bit.h</P>
<P>05/05/99  02:39p               163,086 bot.c</P>
<P>04/22/99  02:36p                 1,385 bot.h</P>
<P>10/19/98  11:23a                 1,206 botact.h</P>
<P>10/13/98  12:30p                   384 botmatch.h</P>
<P>03/18/99  01:31p                 2,818 Game.h</P>
<P>05/10/99  06:53p                 5,814 Genvs.h</P>
<P>05/04/99  03:17p                15,520 Genvsi.c</P>
<P>05/04/99  03:17p                12,006 Genvsi.h</P>
<P>05/04/99  03:20p                67,674 GMain.c</P>
<P>04/19/99  02:32p                 7,783 GMain.h</P>
<P>04/28/99  12:29a                 7,354 Gplayer.h</P>
<P>05/05/99  02:40p                28,759 Items.c</P>
<P>05/05/99  02:40p                 7,079 Level.c</P>
<P>01/05/99  06:00p                10,951 PathPt.c</P>
<P>01/05/99  01:55p                 1,755 pathpt.h</P>
<P>01/05/99  06:46p                35,630 Track.c</P>
<P>11/15/98  11:13p                 3,825 track.h</P>
<P>03/23/99  02:13p                32,993 Weapons.c</P>
<P>01/05/99  06:31p                 2,719 _bot.c</P>
<P>11/11/98  11:22p                   799 _bot.h</P>
<P>              24 File(s)        418,937 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069910">Directory of C:\Genesis3D\src\Procedurals</A></P>
</FONT><FONT FACE="Arial"><P>This subdirectory contains code for procedural code for the various special effects, including those in the FX directory.  These effects can be seen in the third demo level of the program.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\src\Procedurals</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>12/22/98  04:36p                 8,676 bumpmap.c</P>
<P>12/04/98  08:22p                   148 bumpmap.h</P>
<P>03/18/99  01:31p                22,772 ElectricFx.c</P>
<P>03/18/99  01:31p                 1,501 ElectricFx.h</P>
<P>12/04/98  06:48p                   116 example.prc</P>
<P>02/14/99  11:29p                 6,717 fire.c</P>
<P>12/04/98  07:09p                   145 fire.h</P>
<P>05/12/99  01:28a                19,420 gebmutil.c</P>
<P>02/22/99  04:19p                 1,820 gebmutil.h</P>
<P>03/22/99  07:31p                20,910 particles.c</P>
<P>12/05/98  03:34p                   160 particles.h</P>
<P>03/10/99  02:16p                14,454 plasma.c</P>
<P>12/06/98  10:41p                   151 plasma.h</P>
<P>12/22/98  10:47a                 1,523 procedural.h</P>
<P>05/12/99  01:28a                15,122 proceng.c</P>
<P>12/10/98  06:13p                 1,035 proceng.h</P>
<P>01/15/99  05:53p                   813 proceng_tables.c</P>
<P>02/15/99  06:22p                 5,917 procutil.c</P>
<P>02/15/99  06:22p                 2,325 procutil.h</P>
<P>01/15/99  06:11p                 1,901 setformat.c</P>
<P>01/15/99  05:53p                   160 setformat.h</P>
<P>03/18/99  01:31p                17,644 smoke.c</P>
<P>03/18/99  01:31p                 1,490 smoke.h</P>
<P>03/18/99  01:31p                12,676 Water.c</P>
<P>03/18/99  01:31p                 1,490 Water.h</P>
<P>              27 File(s)        159,086 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069911">Directory of C:\Genesis3D\Tools</A></P>
</FONT><FONT FACE="Arial"><P>The Tools subdirectory contains two files, a header and a C source file, which are an example of how to build an "Actor".  The example actor was initially a "drill".  The textures used for this example are created recursively by the drill code and placed in a "maps" subdirectory. Which has not been included for some time in the download, but the code in the example is still a useful example.  You must simply create a maps subdirectory for the code to be written into if you decide to use the code, or change the location.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\Tools</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>11/18/98  01:18p                16,969 drill.c</P>
<P>09/03/98  12:59a                   466 drill.h</P>
<P>               4 File(s)         17,435 bytes</P>
</FONT><FONT FACE="Arial" SIZE=4><P><A NAME="_Toc454069912">Directory of C:\Genesis3D\wav*</A></P>
</FONT><FONT FACE="Arial"><P>The wav subdirectory contains sound effects used in the demonstration game.</P>

</FONT><FONT FACE="Courier New" SIZE=1><P>Directory of C:\Genesis3D\wav</P>

<P>05/17/99  06:34p        &lt;DIR&gt;          .</P>
<P>05/17/99  06:34p        &lt;DIR&gt;          ..</P>
<P>07/27/98  01:26p                84,060 blaster.WAV</P>
<P>07/28/98  04:20p                26,442 blasterbang.WAV</P>
<P>07/26/98  04:26p                12,232 Bounce.wav</P>
<P>07/03/98  04:06p                58,988 die.wav</P>
<P>07/26/98  04:40p               161,748 DoorOpen.wav</P>
<P>07/28/98  04:16p                31,690 grenade.wav</P>
<P>05/15/99  12:17a                18,732 hurt1.wav</P>
<P>05/15/99  12:17a                16,940 hurt2.wav</P>
<P>05/15/99  12:17a                18,732 hurt3.wav</P>
<P>05/15/99  12:17a                16,940 hurt4.wav</P>
<P>07/26/98  04:49p                50,318 itemspwn.wav</P>
<P>07/03/98  04:39p                14,718 jump.wav</P>
<P>04/16/98  12:02p                   786 KeyPress.wav</P>
<P>07/09/98  11:29a                22,858 lockload.wav</P>
<P>07/28/98  04:22p               132,106 loopbzzt.wav</P>
<P>10/02/96  10:44a                41,416 MImpact.wav</P>
<P>12/30/97  04:09p                26,554 MLaunch.wav</P>
<P>07/26/98  06:00p                26,482 onebzzt.wav</P>
<P>07/03/98  03:11p                29,518 PickupHealth.wav</P>
<P>07/26/98  05:41p                67,338 plyrspwn.wav</P>
<P>07/26/98  07:31p                13,654 shredder.wav</P>
<P>07/03/98  03:15p                60,030 WeaponPickup.wav</P>
<P>              24 File(s)        932,282 bytes</P>
</FONT><B><FONT FACE="Arial Black" SIZE=5><P ALIGN="CENTER">&nbsp;</P>
<P ALIGN="CENTER"><A NAME="_Toc454069913">Genesis3D API Documentation</A></A></P>
</B></FONT><I><FONT FACE="Arial"><P>&nbsp;</P>
</I></FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069914">Genesis3D API and Tools Documentation</A></P>
</B></FONT><FONT FACE="Arial">
<I><P>Author's Note: This is one of the earliest of the Genesis3D documents produced by Eclipse.  I have included it here because of the insight it offers into the design process and thinking of the developers when the engine was being created. Readers should view these pages in this light, especially since several of the items mentioned as future efforts are actually completed in the 1.0 release. In the original release a series of tables was included describing the various functions in the Include directory.  I have expanded that original table bringing it up to date and adding any information provided in the 1.0 Release documentation and included it in the third volume of this series. </P>

</I><P>The Genesis3D&nbsp;Engine APIs and tools make up the programmers half of the SDK for game and application development. This document is intended to provide information about the Tools and APIs to people interested in developing their own applications or extending the demo application that we have provided. The documentation here is being updated frequently, so it is a good idea to check our web site frequently to get the latest updates. Also, make sure that you read the readme.txt file in the installation for last minute updates regarding the tools.</P>
<P>Please check our web site often for documentation updates: http://www.Genesis3D.com.</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P><A NAME="_Toc446558898">Contents</A></P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=623>
<TR><TD WIDTH="21%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>API Overview</FONT></TD>
<TD WIDTH="79%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>An area by area overview of the engine APIs. Go here to get a description of what we intended for the APIs and to see how they are supposed to fit together.</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>Engine APIs By Area</FONT></TD>
<TD WIDTH="79%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>A list of links to the APIs ordered by their areas of functionality. Go here if you want a rapid index into the function reference manual.</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>Using The Animation Tools</FONT></TD>
<TD WIDTH="79%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>A guide to how to use our 3DS Max exporters and conversion utilities for building Actors.</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>Tool Writer Support</FONT></TD>
<TD WIDTH="79%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>A description of what you need in order to build Actors using the Actor API.</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" COLOR="#ffffff"><P><A NAME="APIOverview"></A>API&nbsp;Overview</P>
</FONT><FONT FACE="Arial">
<P>The Genesis3D APIs area broken into several areas of functionality. Some of the areas are dependent on one another, but we've made strong efforts to ensure that there is as little dependency as possible. In some cases, we've specifically designed the system to be kept separated. For example, the SoundSystem APIs know nothing about the Engine or World except for one non-critical place. This is to enable people to use their own sound system if they decide that ours is not sufficient for their needs.</P>
<P>This overview section is intended to communicate what each set of APIs is both capable of doing, and is <I>supposed</I> to do. APIs live and die by their ease of use and consistency, and we feel that the documentation should provide clear paths for people to follow. It is very difficult to build an API that has only one way to be used and is still powerful. This can lead to confusion in the workplace about what the APIs are supposed to do.</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>Basic Data Types</P>
</FONT><FONT FACE="Arial"><P>There are a number of very basic datatypes that Genesis3D defines. These are all implemented in basetype.h, and serve the purpose of clearly defining the size of data fields, and/or isolating machine specific types that might need to change in the future. The types defined there are:</P>
<P>geBoolean </P>
<P>geFloat </P>
<P>int32 </P>
<P>int16 </P>
<P>int8 </P>
<P>uint32 </P>
<P>uint16 </P>
<P>uint8 </P>
<P>These datatypes are used throughout all of the other Genesis3D&nbsp;APIs.</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>3D&nbsp;Math (geVec3d, geXForm3d and Quaternion)</P>
</FONT><FONT FACE="Arial"><P>Basic 3D&nbsp;math operations have been provided in the form of support for vectors, 3D&nbsp;transforms and quaternions. These three datatypes constitute the bulk of the coordinate system management APIs. Note that in all of the APIs below, we have designed the implementation so that it is safe to pass the same parameter into a source and destination parameter. For example, if a function is supposed to transform one vector to another, the output vector may be the same as the input vector. &nbsp;It is safe to rely upon this behaviour for all of the APIs.</P>
<P>geVec3d is a simple 3D vector type with normal vector operations. The reference section provides ample documentation on these APIs.</P>
<P>geXForm3d is a transform object designed to convert from one coordinate system to another. Please note that this object is NOT designed to be a generic 4x4 matrix for normal math operations. While it can perform in that capacity, the geXForm3d was designed to manage coordinate system transforms, and hence has some restrictions built into it. Also, the debug versions of the APIs include asserts that enforce these restrictions on the transforms.</P>
<P>The geXForm3d has most of the standard transform APIs, plus a few additional conventions imposed over the transform. The Genesis3D coordinate system is a right handed coordinate system, and there are some features of the transform that are particularly interesting in an application setting. If you take the transpose of the transform, the basis vectors form an orthonormal system with the interesting property that the X vector, when added to a camera position will move the camera subjectively left/right, the Y&nbsp;vector will move up/down, and the Z vector will move in/out. These are completely subjective motions, but they are very useful to applications. Consequently, we have provided APIs to extract from the transforms their 'Left', 'Up' and 'In' vectors. Also, a transform may be built from an orthonormal system of these vectors directly.</P>
<P>Note that the geXForm3d structure is fully defined in the header file. This was done because we felt it critical that developers be able to create the transforms both on the stack, and in arrays. This is something we could not accomplish if we had provided create and destroy APIs for the transforms, and made the data types completely opaque.You MUST&nbsp;NOT&nbsp;use the members of the geXForm3d structure directly. &nbsp;We are likely to change them in the future, and we will not be supporting direct access to them. Also, you should not write the geXForm3d structures directly to disk. Rather, you should extract the basis vectors and translation, and write those to disk. This will save you from potential structure size differences in future versions of Genesis3D.</P>
<P>The Quaternion datatype is a fully featured quaternion. The APIs follow rigidly the mathematical formulations for Quaternions, with the exception of the interpolation and conversion APIs. The interpolation APIs are arbitrary, and have no fixed mathematical definition. The conversion APIs convert back and forth from geXForm3d objects, and there is arbitration in the quaternion code to resolve the ambiguities inherent in converting from 3 dimensional space to 4 dimensional space.</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>Engine and Driver Systems</P>
</FONT><FONT FACE="Arial"><P>The baseline rendering support is provided through the Engine and Driver systems. These manage the hardware specific parts of rendering, including driver categories&nbsp;(Glide, D3D and Software). The Engine APIs include directly exposed 2D decal APIs that are intended to be used for UI elements such as menus. No other drawing APIs are directly exposed through the engine or drivers.</P>
<P>The drivers are meta-drivers that are used to encapsulate the 3D&nbsp;drawing support that we are using. Genesis3D currently supports Glide, D3D and software rasterizers. The initialization and functionality of each of these is abstracted into higher levels drivers the Eclipse Entertaiment provides.</P>
<P>Before using any other subsystems (except math), you need to create a geEngine object. Once the engine is created, you can get a driver system from it, and query that system for which drivers are supported. Once you've picked a driver, and mode, and told the engine to use them, you can begin all drawing operations available.</P>
<P>The geEngine API is a frame based API, meaning that you tell the geEngine when to start a render frame, and when to end the frame. In between these calls, you may do all your drawing operations. <B>Note</B>: Texture loading operations, including loading and unloading of Actors, <B>MUST NOT</B>&nbsp;be done in between a BeginFrame/EndFrame pair.</P>
<P>There are currently 3 different main drivers: Glide, D3D and software. Each has its own characteristics that bear some mention.</P>
<P>The Glide driver has support for both Voodoo and Voodoo 2 built into it. The driver detects which support you have and adapts accordingly. If you have a Voodoo 2 card, we will use 2 texture mapping units on the card, rendering the world through one unit, and the light maps through the other. This will give very significant performance benefits. Debugging your applications under the Glide driver is also convenient, as the Glide drivers are enormously forgiving. You can switch from the full screen app back to the debugger at any time with Ctrl-F9, without lockups. A caveat to using the Glide driver: on this driver, all world textures are loaded to the card in 8bit palettized form. They are not cached in system memory. Hence, if your world textures (textures used to texture the static geometry of the world) exceed 1.5 megabytes on a 4MB Voodoo card, your performance may suffer. It is also possible that the level will fail to load for lack of texture memory. We have never seen this happen, but it is possible. The lightmaps are not included in the count for this purpose.</P>
<P>The D3D drivers support the most cards. There are advantages and disadvantages to the D3D drivers. The D3D drivers are slightly slower than the Glide drivers on comparable cards. The D3D drivers are more difficult to debug under, as you tend to lockup when you are in full screen mode. Also, the D3D drivers take longer to initialize for large levels, because of the time involved in creating surfaces for the various textures in the world (lightmap surfaces are numerous). On the plus side, the D3D drivers support many cards, and they do support windowed mode on 3D hardware which supports windowed mode. In addition, we do not load world textures arbitrarily to the video memory; they are cached along with lightmaps, so you do not have the world texture limitation that our Glide driver has.</P>
<P>The software driver works on all known hardware, but has limitations. We do not support alpha blending, and the frame rate is slower than that of native hardware drivers. We do support RGB lighting. The software driver supports both full screen and windowed mode, and some stretch modes which you can use to dramatically improve performance at the cost of some quality. If you have an AMD machine with 3D-Now technology, the driver will take advantage of this for greater performance.</P>
<P>When you load the engine, and query the drivers, each driver present on the machine will attempt to determine if it can run. If it passes the tests, then the driver will appear in the enumeration APIs. Otherwise, the driver will not appear. For both Glide and software, the tests are trivial. For D3D, however, there is much more flexibility in what is supported in a card, and what is not, so there are a number of tests done before we will accept a card. These are the requirements for a D3D driver to be accepted:</P>
<P>[requirements here]</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>Cameras</P>
</FONT><FONT FACE="Arial"><P>Cameras define the context from which rendering is done. When you render a world, you must pass in a camera which is the viewpoint from which the world is rendered.</P>
<P>A geCamera is created with a clipping rect on the screen to which it is bound. From then on, most applications will only ever need to set the transform of the camera to yield the desired effect. Therefore, most applications will only ever need the following three APIs:</P>
<P>geCamera_Create </P>
<P>geCamera_Destroy </P>
<P>geCamera_SetXForm </P>
<P>You can render multiple views of the world in a single frame by rendering the world through two different cameras between a geEngine_BeginFrame/geEngine_EndFrame pair. The two cameras need to be using separate clipping rectangles. This can be used to build rearview mirrors, or following cameras.</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>The World</P>
</FONT><FONT FACE="Arial"><P>The engine renders a geWorld object, which in turn contains a number of things. First and foremost, the geWorld&nbsp;object contains the static world geometry which has been defined by the editor. Beyond this, the world manages textures, Actors, entities and dynamic lights. Anything that is created with the geWorld_&nbsp;APIs is owned by the world and will be managed by the world, including being destroyed with the world is destroyed.</P>
<P>To best start the discussion about the world, and what a developer can do with it, we need to define a few terms:</P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=623>
<TR><TD WIDTH="23%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>Model</FONT></TD>
<TD WIDTH="77%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>A collection of geometry which can be manipulated independently of other models. The Editor creates models. Models may have keyframed motions.</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>Light Style</FONT></TD>
<TD WIDTH="77%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>A lighting brightness pattern defined by the programmer which is applied to lightmaps tagged with that style.</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>Entity Set</FONT></TD>
<TD WIDTH="77%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>A set of entites, grouped by the type of the entity. The types are defined by the developer.</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>Entity</FONT></TD>
<TD WIDTH="77%" VALIGN="MIDDLE">
<FONT FACE="Arial"><P>A developer defined block of data.</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" COLOR="#ffffff"><P>Static World Data</P>
</FONT><FONT FACE="Arial"><P>The base of the world is the world model. This is static geometry, which has been prelit. This geometry never moves with relation to itself once it has been created. The level designer may build additional models which are prelit, which may or may not have keyframe data. These serve most commonly for doors, and the like. These pieces of geometry can move with respect to each other, and the world model. In general, we refer to these models as models, and to the world model as the world, when we are talking about geometry.</P>
<P>The world, as edited by the level designer, also contains application specific data. This is data the format of which has been determined by the developer. The editor understands certain keywords in header files, and parses C&nbsp;header files to provide templates for that data in the world editor. Thus the level designer can place entities into the world which match the structures in the header files. The developer can then retrieve those entities at runtime through a set of APIs. Treat the data that is in the entities as streamed data. The data can contain pointers to other entities, so the programmer can use the resulting data directly at runtime. The editor and engine handle the streaming of the data so that the data structures are consitent when the world is loaded. See the editor documentation for a detailed description of the syntax for defining entity types in header files.</P>
<P>When you load a world with geWorld_Create, you get a bunch of geometry, plus lighting information, visibility information and entities. The geometry and lighting information are managed almost exclusively be the engine, with the optional exception of geWorld_Model objects and lighting styles.</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>Dynamic World Data</P>
</FONT><FONT FACE="Arial"><P>Once loaded in the application, the world becomes a repository for a number of runtime data. Amoung these, are dynamic lights, fog lights, user polygons and actors. These items are all owned by a world, and when the world is destroyed, the items are destroyed. These items are also added to the world only at runtime, through the geWorld_ APIs.</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>Dynamic Lights</P>
</FONT><FONT FACE="Arial"><P>Dynamic lights are an additional lighting pass which is done at runtime. The developer can create up to 32 dynamic lights, and control the position, radius and color of the light, on a frame by frame basis. The engine updates all of the lightmaps for the world with the dynamic lights, each frame. Dynamic lights are always omni lights.</P>
<P>Dynamic lights may optionally cast shadows. The shadows currently are cast only off of static world geometry. Models and actors are not taken into account when casting shadows with dynamic lights.</P>
<P>Dynamic lights have a computational cost associated with them that should not be ignored. The larger the light, the more lightmaps need to be updated each frame, so increasing the size of a light affects performance on an n-squared basis. In addition, shadows are quite expensive to calculate. If you have enabled shadow casting for a dynamic light, you should take additional care about the size of the dynamic light.</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>Fog</P>
</FONT><FONT FACE="Arial"><P>Fog lights are similar to dynamic lights in terms of control. They have color, size and position, which can be updated on a frame by frame basis. Fog lights are always spherical. Fog lights are an additional update of the lightmaps, with a slight difference: the lightmaps that are updated are affected by your camera position. The engine fogs the lightmaps that are behind the influence of the fog, based on the radius and falloff of the fog light, resulting in the texture being obscured. The result is a good local fog effect. Note that performance of the fog light is n-squared in terms of the size of the fog light. Be careful to keep your fog lights of reasonable radius. If you need to cover a wide area, it is better to use several small fog lights, than one large one.</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>User Polygons</P>
</FONT><FONT FACE="Arial"><P>In addition to the higher level rendering support that the engine provides (world and actors), there are APIs to allow the developer to add arbitrary polygons to a scene. There are two types of polygons that the developer may add: textured points, and arbitrary. See the Engine section for a note about decals.</P>
<P>Textured points can also be considered sprites. The API takes a texture, and a 3D&nbsp;location, and ensures that the texture is drawn to face the camera that is being used to render the world. This is basically a convenience API for something that most applications want to do.</P>
<P>You may add arbitrary polygons to the world's rendering queue. In this case, you specify a list of vertices in 3D space, along with RGB values and texture coordinates. The APIs let you specify whether or not the polygon should be textured, or gouraud shaded, and whether there should be transparency. The engine handles projection and clipping into the camera that is being used to render the scene.</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>Textures</P>
</FONT><FONT FACE="Arial"><P>There is support for loading your own individual textures for drawing with the user polygon APIs. The APIs currently support loading an Eclipse specific format. See the documentation on the BMP2GFX tool for conversion. This support will eventually be replaced with more cohesive texture or material library support, at which point the GFX format will be retired.</P>
<P>Textures are loaded into a world, and then drawn with separate APIs. Textures must be 8bit palettized bitmaps for conversion. Palette index 255 is reserved for transparency. &nbsp;Any pixels that are that index will be masked out. Internally the textures are converted to 16bit, depending on the hardware that you are running. Textures must be square, with dimensions being powers of 2.</P>
<P>Alpha masks are supported for textures. When loading a texture, you can provide an additional mask texture which is a grey scale mask which will be combined with the texture to form an alpha channel. Hardware which supports alpha blending will support this natively. In the software rasterizer, the alpha mask is processed to convert pixels within the low range of transparency to completely transparent, while the other pixels become completely opaque. &nbsp;In otherwords, in the software rasterizer, the alpha mask becomes a ranged transparency mask.</P>
<B><P>Note</B>: Textures <B>must not</B> be loaded in between calls to geEngine_BeginFrame and geEngine_EndFrame.</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>Sound and 3D&nbsp;Sound</P>
</FONT><FONT FACE="Arial"><P>We have included support for sound in the engine APIs, though we have made an attempt to keep these APIs separated from the world APIs so that you can install your own sound system if you so choose. The sound system provided uses Direct Sound for mixing, and provides a simple interface to hide the more bulky DSound interfaces. Currently, only WAV files are supported.</P>
<P>The APIs provide for loading WAV files as sound definitions, and then playing multiple instances of those sounds efficiently. The sounds can be parameterized at play time with regard to their volume, frequency and panning, and whether or not they should loop.</P>
<P>There is separate support for determining the volume, frequency and panning of a sound based upon its location in the world with respect to a camera. We have kept this support distinct from the sound system proper so that if you wish you may override the sound system implementation and use our sound positioning API. In the future, we will be adding support to modify a sound's parameters based upon not just position in the world, but the shape of the surrounding geometry (echo).</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>Paths and Motions</P>
</FONT><FONT FACE="Arial"><P>Paths and motions are used internally by two systems:&nbsp;Actors and Model keyframing. The Path and Motion APIs allow you to build individual keyframed and blended keyframed sequences, respectively.</P>
<P>The Path is an object which contains key-frames keyed to time. You have complete freedom to manipulate the key-frames. Two channels are supported: rotation and translation. Several interpolation modes are provided for blending between keys. You can blend with linear interpolation, hermite or SQUAD. Internally, Paths use quaternion operations, so there are no problems with singularities.</P>
<P>The Motion object is a collection of Paths, Events and sub-motions. Events are just string tags that are assigned to a particular time. They are used to annotate Paths so that you can trigger arbitrary events from a motion at a given time, which may be a design dependent time. There are APIs for extracting the event tags at a particular time. The Motion object includes the ability to blend multiple sub-motions together to get a hierarchical motion. This aspect of the Motion is used to drive the animation system in the Actors.</P>
<P>The models in the World Editor are key-framed and stored in Motions. This is done for two reasons: we wanted to have support for Events in the model animations, and at some point in time, we anticipate adding hierarchical animation to world geometry in the editor. Hence Paths were not the correct choice for the animation of world models.</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>Actors</P>
</FONT><FONT FACE="Arial"><P>Actors are skeletal animated meshes. The Actor APIs allow for loading an Actor into the world, cueing motions within an Actor, and doing collision detection against Actors.</P>
<P>Actors that are rendered in the world have support for various lighting forms. There is floor lighting, which is taken directly off the floor point immediately below the actor, and used as an ambient light. There is an arbitrary ambient light, and there is support for taking the light from the nearest dynamic lights in the world. The dynamic lights light the Actors directionally, which can be used to great effect.</P>
<P>Actors have a range of APIs to be used for animation. At the simplest, you can cue a simple motion, and set the Actor to different poses within that animation. This can be used to make simple Quake-like animation sequences. At the other end of the spectrum, you can cue multiple motions within an Actor, and blend them together to get entirely new motions. This can be used to create very organic looking characters with a nearly infinite variety of motions. The second method is hard to control in your application, but the results are worth it.</P>
<P>The complete Actor API supports construction of Actors from the ground up. These APIs can be used by tool makers to build exporters for Actors. A section in this document is dedicated to this purpose, and includes sample code for the Actor APIs to do exactly this.<A NAME="geCamera_Create"><A NAME="AnimationTools"></A></A></P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P> Animation Tools</P>
</FONT><FONT FACE="Arial"><P>Included in the SDK are tools for exporting geometry and animation from 3DS&nbsp;Max version 2.x and converting the results to animation data for the engine to consume in the form of Actors. The tools and process are documented here.</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>Preparing A Mesh For Exporting</P>
</FONT><FONT FACE="Arial"><P>In order to build a mesh for exporting, you must have the following:</P>
<P>3DS&nbsp;Max version 2.x </P>
<P>Character Studio 2.0 (Physique/Biped) </P>
<P>Install our plugins for 3DS&nbsp;Max. There are two plugins: <B>keyexp.dle</B> and <B>nfoexp.dle</B>. They have to be placed in the plugins directory for Max.</P>
<P>Once you have built your mesh, follow these steps:</P>
<P>Build bones (either Max bones or Biped bones) for your mesh</P>
<P>Physique the mesh to the bones using rigid vertices. If you don't use rigid attachments, the tools will fail on your model. You must physique the entire mesh.</P>
<P>Animate the bones</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P>Exporting Your Animations</P>
</FONT><FONT FACE="Arial"><P>Export a single frame as a reference frame, using the NFO exporter. We recommend a DaVinci pose. This will yield an NFO file.</P>
<P>Export each motion individually, using the KEY exporter. This will yield a set of KEY files.</P>
<P>Run <B>mkbody.exe</B> to convert the NFO file to a BDY file.</P>
<P>Run <B>mkmotion.exe</B> on each KEY file to convert them to MOT files. Mkmotion requires you to pass in the BDY file that you created with the last step as a parameter.</P>
<P>Optionally, run <B>mop.exe</B> on your MOT files to optimize them. &nbsp;This will radically reduce their size.</P>
<P>Run <B>mkactor.exe</B> with the BDY&nbsp;file and any set of the MOT files. This will build your Actor file (ACT). The resulting ACT file is a text format file, and is rather bulky, and slow to load.</P>
<P>Create a binary version of the ACT file using <B>fmtactor.exe</B>.</P>
<P>The textures for Actors are not packed into the actor file. Instead, the materials that you have referenced in 3DS&nbsp;Max in the materials editor are the names of the bitmaps that will be loaded by the Actor when it loads. The bitmap files must be 8bit palettized, and converted to GFX files with BMP2GFX.EXE. See the discussion about textures in the engine API documentation for clarification about the tools, and transparent colors in textures.</P>
<P>Motions can be flagged with events. Events are taken from the note track in 3DS&nbsp;Max. You can attach a note track to any bone. The text of the note is inserted directly into the motion as the event. It should be a single line of text only. Do not put in any empty line of text as this will confuse the current tools.</P>
<P>Smoothing groups are supported in the renderer for Actors, so use them freely to improve the appearance of your models.</P>
</FONT><FONT FACE="Arial" COLOR="#ffffff"><P><A NAME="Tool_WriterSupport"></A>Tool Writer Support</P>
</FONT><FONT FACE="Arial"><P>This section is intended to provide a very basic overview of what is required to build Actors from the ground up. This is so that 3rd party tool makers can build exporters for their tools to output Actors for Genesis3D to consume.</P>
<P>Included in the SDK are the complete Actor APIs, over and above what are found in Genesis.h. The APIs in Genesis.h are intended to be used to manipulate Actors that have already been constructed, and are being used in an application. The complete Actor APIs include the APIs for adding elements to the Actors, and writing those Actors to disk.</P>
<P>To use the full Actor API, you need to use the following include files:</P>
<P>path.h </P>
<P>motion.h </P>
<P>body.h </P>
<P>actor.h </P>
<P>The Path, Motion and Actor headers are more complete versions of those APIs found in Genesis.h, while body.h is a support file needed only to support Actors that are being rendered or constructed.</P>
<P>We are not exposing or supporting the internal rendering mechanisms or APIs in the Actor subsystem. These headers have been provided for the express purpose of generating Actors.</P>
<P>Included in the SDK is a code fragment that demonstrates how to use the Actor APIs to build an ACT file from the ground up. See the files Tools\drill.h and Tools\drill.c in the distribution.</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc446558899"><A NAME="_Toc454069915">Genesis3D Library Header Files</A></A></P>
</B></FONT><FONT FACE="Arial"><P>The header files here are broken up alphabetically within the subdirectories in which they are found. The purpose of each subdirectory is covered in the Game File Structure Layout section above.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069916">Include Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>The header files in this subdirectory comprise the links necessary to create applications using the Genesis3D engine with the pre-created libraries provided by Eclipse.  These are the only include files you need in order to create an application with Genesis3D if you are not going to attempt to modify the game engine.  For a list of the functions contained in these headers see Volume 3 of this series.</P>

<P>This subdirectory is repeated several times in the individual Tools subdirectories as an aid to speeding the compilation process and to separate the compilation of the Tools from that of the engine and the demonstration game.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558900"><A NAME="_Toc454069917">Actor.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  ACTOR.H                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige                                                             */</P>
<P>/*  Description:  Actor interface                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>/*   Actor</P>
<P>&#9;</P>
<P>&#9;This object is designed to support character animation.</P>
<P>&#9;There are two basic objects to deal with.  </P>
<P>&#9;</P>
<P>&#9;Actor Definition (geActor_Def)</P>
<P>&#9;&#9;A geActor_Def embodies the geometry (polygon, and bone information), </P>
<P>&#9;&#9;and a library of motions that can be applied to that geometry.</P>

<P>&#9;Actor</P>
<P>&#9;&#9;A geActor is an instance of an actor definition.  The definition is used for </P>
<P>&#9;&#9;the geometry, but all additional settings, such as the bone pose, lighting information,</P>
<P>&#9;&#9;and cuing information is unique for a geActor.</P>
<P>// GENESIS_PRIVATE_API</P>
<P>&#9;An Actor Definition is created either from an existing Actor Definition file, or from scratch by </P>
<P>&#9;first creating a geBody and geMotions and selecting these into an Actor.  If the Actor Definition</P>
<P>&#9;is constructed from scratch, the objects selected into it (via SetBody and AddMotion) are</P>
<P>&#9;then 'owned' by the actor and will be destroyed along with the Actor when it is destroyed.</P>
<P>    Of course, when the Actor is loaded from a file, the Body and Motion it creates as it is</P>
<P>&#9;loaded are cleaned up when the Actor is destroyed.</P>

<P>&#9;Once an Actor is created, prepare it for rendering and animating by calling </P>
<P>&#9;Actor_RenderPrep().  This must be called (and it must succeed) before any render or</P>
<P>&#9;pose setting functions can be called.</P>
<P>// GENESIS_PUBLIC_API</P>

<P>&#9;There are two ways to use an Actor.</P>
<P>&#9;Direct Control</P>
<P>&#9;&#9;One method is to directly control the skeleton configuration.  Use _SetPose() to set its </P>
<P>&#9;&#9;skeleton using a geMotion animation.  The pose is positioned in world space relative to the </P>
<P>&#9;&#9;transform given in SetPose().  Whenever a new skeleton pose is required, call _SetPose() </P>
<P>&#9;&#9;to reposition the skeleton for a new point in time. </P>

<P>&#9;&#9;More complex positioning can be achieved by blending more than one animation.  Use</P>
<P>&#9;&#9;_BlendPose() after a _SetPose() to blend the second geMotion into the first.  Additional</P>
<P>&#9;&#9;blends can be applied by additional _BlendPose() calls.  Each blend is performed on the</P>
<P>&#9;&#9;the existing skeleton (the results of any previous blends).</P>
<P>&#9;Cuing</P>
<P>&#9;&#9;Another method is to 'cue' up motions that are applied with parameterized blending over time.</P>
<P>&#9;&#9;A cued motion takes effect 'now' in time.  The Actor advances in time and repositions itself</P>
<P>&#9;&#9;according to its currently cued motions with a call to _AnimationStep().  AnimationStep() </P>
<P>&#9;&#9;redefines what the actor thinks 'now' is.  This causes historical cues to be forgotten, and </P>
<P>&#9;&#9;motions that are no longer valid are cleaned up.  AnimationTestStep() can be used to position </P>
<P>&#9;&#9;the actor for potential queries with its currently cued motions at some arbitrary future time </P>
<P>&#9;&#9;- relative to the last AnimationTestStep() call.  AnimationNudge() applies a given transform </P>
<P>&#9;&#9;'instantly' to the current actor's cue list.  This is usefull for moving the actor as a </P>
<P>&#9;&#9;result of a collision with another object.</P>

<P>&#9;If a motion contains joint information that does not exactly match the Actor's skeleton </P>
<P>&#9;joints, only the joints that match by name are applied.  So a geMotion can be applied to</P>
<P>&#9;a portion of the Actor, or a geMotion that has more joint information than the skeleton can</P>
<P>&#9;be applied and the extra joint information is ignored.  </P>
<P>&#9; </P>
<P>&#9;Examples of this:  If the Actor is a biped and has no tail, but the motion is for a </P>
<P>&#9;biped with a tail, the geMotion can be applied, but the tail information will be ignored.</P>
<P>&#9;Also if there is a geMotion for only a left arm, it can be applied and it will only affect</P>
<P>&#9;the left arm of the Actor, and consequently its left hand and fingers, but no other </P>
<P>&#9;bones that are not children of the affected bones will be changed.</P>

<P>&#9; &#9;</P>
<P>*/</P>
<P>#ifndef GE_ACTOR_H</P>
<P>#define GE_ACTOR_H</P>

<P>#include "genesis.h"&#9;&#9;&#9;&#9;</P>
<P>#include "basetype.h"</P>
<P>#include "extbox.h"</P>
<P>#include "bitmap.h"</P>

<P>#include "Motion.h"</P>

<P>#ifdef GE_WORLD_H</P>
<P>#include "camera.h"</P>
<P>#include "Frustum.h"</P>
<P>#endif</P>

<P>#include "Body.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>// GENESIS_PUBLIC_APIS</P>

<P>#ifndef GE_ACTOR_ENUMS</P>
<P>#define GE_ACTOR_ENUMS</P>
<P>typedef enum </P>
<P>{</P>
<P>&#9;&#9;GE_ACTOR_BLEND_LINEAR,&#9;&#9;// Treats the blending amount as a linear value</P>
<P>&#9;&#9;GE_ACTOR_BLEND_HERMITE&#9;&#9;// Applies a parametric smoothing curve to the blending amount</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//  so that a linear change in BlendAmount parameters will</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//  result in a smooth (non-linear) change in blending.</P>
<P>} geActor_BlendingType;</P>

<P>#endif</P>

<P>typedef struct geActor geActor;&#9;&#9;&#9;// an instance of an actor</P>
<P>typedef struct geActor_Def geActor_Def;&#9;&#9;// the deinition of an actor's geometry/bone structure</P>

<P>&nbsp;</P>
<P>// GENESIS_PRIVATE_APIS</P>

<P>//---------------------------------------------------------------------------------</P>
<P>//   Creation/Destruction functions</P>
<P>//---------------------------------------------------------------------------------</P>
<P>&#9;// Create an 'empty' Actor Definition.</P>
<P>GENESISAPI geActor_Def *GENESISCC geActor_DefCreate(void);</P>

<P>&#9;// Create an Actor Definition from a file image.</P>
<P>GENESISAPI geActor_Def *GENESISCC geActor_DefCreateFromFile(geVFile *pFile);</P>

<P>&#9;// Create an additional reference (owner) for the Actor_Definition</P>
<P>GENESISAPI void GENESISCC geActor_DefCreateRef(geActor_Def *pActorDefinition);</P>

<P>&#9;// Destroy a geActor_Def (its geBody and its geMotions)  Actors that rely on this definition become invalid.</P>
<P>&#9;// can fail if there are actors still referencing this definition.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_DefDestroy(geActor_Def **pActorDefinition);</P>

<P>&#9;// Create an Actor instance associated with the given Actor Definition </P>
<P>GENESISAPI geActor *GENESISCC geActor_Create(geActor_Def *ActorDefinition);</P>

<P>&#9;// Create an additional reference (owner) for the Actor</P>
<P>GENESISAPI void GENESISCC geActor_CreateRef(geActor *Actor);</P>

<P>&#9;// Give the Actor Definition a Body.  geActor becomes responsible for its destruction.</P>
<P>&#9;// sets up default materials as referenced by the Body.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_SetBody( geActor_Def *ActorDefinition, geBody *geBodyGeometry);</P>

<P>&#9;// Adds a geMotion to the Actor Definition's library.  The ActorDefinition becomes responsible for its destruction.</P>
<P>&#9;// returns the library index to the new geMotion.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AddMotion(geActor_Def *ActorDefinition, geMotion *M, int *Index);</P>

<P>&#9;// Destroy an Actor.  </P>
<P>GENESISAPI void GENESISCC geActor_Destroy(geActor **pA);</P>

<P>GENESISAPI geBoolean GENESISCC geActor_DefIsValid(const geActor_Def *A);</P>
<P>GENESISAPI geBoolean GENESISCC geActor_IsValid(const geActor *A);</P>

<P>// GENESIS_PUBLIC_APIS</P>
<P>//---------------------------------------------------------------------------------</P>
<P>//   Queries </P>
<P>//---------------------------------------------------------------------------------</P>
<P>// GENESIS_PRIVATE_APIS</P>

<P>&#9;// In general: Objects retuned from Get functions should not not be destroyed. </P>
<P>&#9;// if ownership is desired, call the objects _CreateRef() function to create another owner. </P>
<P>&#9;// (An 'owner' has access to the object regardless of the number of other owners, and </P>
<P>&#9;// an owner must call the object's _Destroy() function to relinquish ownership )</P>

<P>&#9;// Returns the Actor Definition associated with Actor A</P>
<P>GENESISAPI geActor_Def *GENESISCC geActor_GetActorDef(const geActor *A);</P>

<P>&#9;// Writes an existing geActor to a file image.  Returns GE_TRUE on success, GE_FALSE on failure.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_DefWriteToFile(const geActor_Def *A, geVFile *pFile);</P>
<P>&#9;</P>
<P>&#9;// Returns a geBody pointer from the geActor </P>
<P>GENESISAPI geBody *GENESISCC geActor_GetBody(const geActor_Def *ActorDefinition);</P>

<P>&#9;// Returns GE_TRUE if the actor definition has a bone named 'Name'</P>
<P>GENESISAPI geBoolean GENESISCC geActor_DefHasBoneNamed(const geActor_Def *Ad, const char *Name );</P>

<P>&#9;// Selects a blending type.  BlendingType only affects the meaning of the </P>
<P>&#9;// BlendAmount parameter for the blend functions.  Can be changed anytime.</P>
<P>GENESISAPI void GENESISCC geActor_SetBlendingType( geActor *A, geActor_BlendingType BlendingType );</P>

<P>// GENESIS_PUBLIC_APIS</P>

<P>&#9;// Returns the number of geMotions in the geActors geMotion library.</P>
<P>GENESISAPI int GENESISCC geActor_GetMotionCount(const geActor_Def *ActorDefinition);</P>

<P>&#9;// Returns a geMotion pointer from the geActors geMotion library</P>
<P>&#9;//   This is an aliased pointer - Not a copy.  Changes to this motion will be reflected</P>
<P>&#9;//   in the actor.  Destroying this return motion will confuse the actor.</P>
<P>&#9;// Index must be in range [0..geActor_GetMotionCount-1]</P>
<P>GENESISAPI geMotion *GENESISCC geActor_GetMotionByIndex(const geActor_Def *ActorDefinition, int Index );</P>

<P>&#9;// Returns a geMotion pointer from the geActors geMotion library</P>
<P>&#9;//   This is an aliased pointer - Not a copy.  Changes to this motion will be reflected</P>
<P>&#9;//   in the actor.  Destroying this return motion will confuse the actor.</P>
<P>&#9;// if there is no motion that matches the given name, the return value will be NULL</P>
<P>GENESISAPI geMotion *GENESISCC geActor_GetMotionByName(const geActor_Def *ActorDefinition, const char *Name );</P>

<P>&#9;// Returns a motion name given an ActorDef and a motion index.</P>
<P>GENESISAPI const char *GENESISCC geActor_GetMotionName(const geActor_Def *ActorDefinition, int Index );</P>

<P>&#9;// Returns the number of materials for an instance of an actor.</P>
<P>GENESISAPI int GENESISCC geActor_GetMaterialCount(const geActor *A);</P>

<P>&#9;// Returns the current material for an instance of an actor</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetMaterial(const geActor *Actor, int MaterialIndex,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap **Bitmap, geFloat *Red, geFloat *Green, geFloat *Blue);</P>

<P>&#9;// Allows a material to be overriden in an actor instance</P>
<P>GENESISAPI geBoolean GENESISCC geActor_SetMaterial(geActor *Actor, int MaterialIndex,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap *Bitmap,  geFloat Red,  geFloat Green,  geFloat Blue);</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&#9;// Gets the current transform for a single bone in A.  (actor space-&gt;world space transform)</P>
<P>&#9;// with a NULL BoneName, this returns the current 'root' transform</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetBoneTransform(const geActor *A, const char *BoneName, geXForm3d *Transform);</P>
<P>&#9;</P>
<P>&#9;// Gets the extent box (axial-aligned bounding box) for a given bone (for the current pose)</P>
<P>&#9;// if BoneName is NULL, gets the a general bounding box from the body of the actor if it has been set.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetBoneExtBox(const geActor *A,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; const char *BoneName,geExtBox *ExtBox);</P>

<P>&#9;// Gets the non-axial-aligned bounding box for a given bone (for the current pose)</P>
<P>&#9;//  The box is specified by a corner, and</P>
<P>&#9;//  a non-normalized orientation transform.  Add DX,DY,DZ components </P>
<P>&#9;//  of the orientation to get other corners of the box</P>
<P>&#9;// if BoneName is NULL, gets the a general bounding box from the body of the actor if it has been set.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetBoneBoundingBox(const geActor *A,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; const char *BoneName,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; geVec3d *Corner,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; geVec3d *DX,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; geVec3d *DY,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; geVec3d *DZ);</P>

<P>&#9;// Gets the current axial-aligned bounding box for an actor's bone configuration</P>
<P>&#9;// takes all bones into account</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetDynamicExtBox( const geActor *A, geExtBox *ExtBox);</P>
<P>&#9;</P>
<P>&#9;// Gets an assigned general non changing bounding box from the actor</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetExtBox(const geActor *A, geExtBox *ExtBox);</P>

<P>&#9;// Sets an assigned general non changing bounding box from the actor</P>
<P>GENESISAPI geBoolean GENESISCC geActor_SetExtBox(geActor *A, const geExtBox *ExtBox,</P>
<P>&#9;&#9;&#9;&#9;&#9;const char *CenterBoxOnThisNamedBone);&#9;&#9;// NULL uses root position of actor</P>

<P>&#9;// Gets the rendering hint bounding box from the actor</P>
<P>&#9;//   if the RenderHintExtBox is disabled, Enabled is GE_FALSE, and the box returned has zero dimensions, </P>
<P>&#9;//   centered at the root position of the actor.  If the RenderHintExtBox is enabled, Enabled is</P>
<P>&#9;//   GE_TRUE, and the box returned is the one set with _SetRenderHintExtBox, offset by the </P>
<P>&#9;//   bone position of the bone named in _SetRenderHintExtBox().</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetRenderHintExtBox(const geActor *A, geExtBox *Box, geBoolean *Enabled);</P>

<P>&#9;// Sets a rendering hint bounding box from the actor.  Increases performance by </P>
<P>&#9;//   enabling the rendering of the actor to occur only if the box is visible.</P>
<P>&#9;//   If the box is not visible, a detailed analysis of the actor's current geometry is avoided.</P>
<P>&#9;//   This does allow errors to occur: </P>
<P>&#9;//   If the actor has a bit of geometry that extends outside this box for some</P>
<P>&#9;//   animation, that extended geometry may not be drawn, if the box if off-screen.   </P>
<P>&#9;//   If the render hint box is not set, the engine will make no conservative assumptions </P>
<P>&#9;//   about the visibility of an actor - it will always be drawn if any portion of it is</P>
<P>&#9;//   visible.</P>
<P>&#9;//   To attach the box to the 'root' bone, pass NULL for CenterBoxOnThisNamedBone</P>
<P>&#9;//   For disabling the hint box: (disabled is default) pass Box with zero mins and maxs</P>
<P>GENESISAPI geBoolean GENESISCC geActor_SetRenderHintExtBox(geActor *A, const geExtBox *Box,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const char *CenterBoxOnThisNamedBone );</P>

<P>&nbsp;</P>
<P>&#9;// Returns the pointer which was set with geActor_SetUserData.  NULL if not set.</P>
<P>GENESISAPI void *GENESISCC geActor_GetUserData(const geActor *A);</P>

<P>&#9;// Sets the actors user data pointer to the given value.  For clients only.</P>
<P>GENESISAPI void GENESISCC geActor_SetUserData(geActor *A, void *UserData);</P>

<P>&nbsp;</P>
<P>//--------------------------------------------------------------------------------</P>
<P>//   Posing and Rendering</P>
<P>//--------------------------------------------------------------------------------</P>

<P>// GENESIS_PRIVATE_APIS</P>

<P>#ifdef GE_WORLD_H</P>
<P>&#9;// Prepares the geActor for rendering and posing.  Call Once once the actor is fully created.</P>
<P>&#9;// Must be called prior to render/pose/setworldtransform </P>
<P>geBoolean GENESISCC geActor_RenderPrep( geActor *A, geWorld *World);</P>

<P>&#9;// Draws the geActor.  (RenderPrep must be called first)</P>
<P>geBoolean GENESISCC geActor_RenderThroughFrustum(const geActor *A, geEngine *Engine, geWorld *World, geCamera *Camera, Frustum_Info *FInfo);</P>
<P>geBoolean GENESISCC geActor_Render(const geActor *A, geEngine *Engine, geWorld *World, geCamera *Camera);</P>
<P>#endif</P>

<P>// GENESIS_PUBLIC_APIS</P>

<P>&#9;// Poses the actor in its default pose</P>
<P>&#9;// Transform is where to position the root for this pose.</P>
<P>&#9;//  if Transform is NULL, the root for the pose is assumed to be the root of the actor.</P>
<P>GENESISAPI void GENESISCC geActor_ClearPose(geActor *A, const geXForm3d *Transform);</P>

<P>&#9;// Poses the actor using given motion M at a time offset of Time</P>
<P>&#9;// Transform is where to position the root for this pose.</P>
<P>&#9;//  if Transform is NULL, the root for the pose is assumed to be the root of the actor.</P>
<P>GENESISAPI void GENESISCC geActor_SetPose(geActor *A, const geMotion *Motion, geFloat Time, const geXForm3d *Transform);</P>

<P>&#9;// Blends the current pose of the geActor with </P>
<P>&#9;//  a new pose using motion M at a time offset of Time</P>
<P>&#9;// A BlendAmount of 0 will result in the existing pose, A BlendAmount of 1 will</P>
<P>&#9;// result in the new pose from M.  The BlendingType set by _SetBlendingType() determines</P>
<P>&#9;// the blending function between 0 and 1</P>
<P>&#9;// Transform is where to position the root for this pose.</P>
<P>&#9;//  if Transform is NULL, the root for the pose is assumed to be the root of the actor.</P>
<P>GENESISAPI void GENESISCC geActor_BlendPose(geActor *A, const geMotion *Motion, geFloat Time,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d *Transform, geFloat BlendAmount);</P>

<P>&nbsp;</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetBoneAttachment(const geActor *A, const char *BoneName, geXForm3d *Transform);</P>
<P>GENESISAPI geBoolean GENESISCC geActor_SetBoneAttachment(geActor *A, const char *BoneName, geXForm3d *Transform);</P>

<P>// GENESIS_PRIVATE_APIS</P>

<P>GENESISAPI geBoolean GENESISCC geActor_Attach( geActor *Slave,  const char *SlaveBoneName,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geActor *Master, const char *MasterBoneName, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d *Attachment);</P>

<P>GENESISAPI void GENESISCC geActor_Detach(geActor *Slave);</P>

<P>&nbsp;</P>
<P>// GENESIS_PUBLIC_APIS</P>
<P>GENESISAPI geBoolean GENESISCC geActor_SetLightingOptions(geActor *A,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean UseFillLight,&#9;&#9;&#9;&#9;// GE_TRUE or GE_FALSE</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *FillLightNormal,&#9;&#9;// normalized vector</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat FillLightRed,&#9;&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat FillLightGreen,&#9;&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat FillLightBlue,&#9;&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat AmbientLightRed,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat AmbientLightGreen,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat AmbientLightBlue,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean AmbientLightFromFloor,&#9;// GE_TRUE or GE_FALSE</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int MaximumDynamicLightsToUse,&#9;&#9;// 0 for none</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const char *LightReferenceBoneName, //NULL for root</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean PerBoneLighting);&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// if GE_TRUE, then dynamic lighting attenuation and direction is computed</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// for each bone.  if GE_FALSE, then the computations are relative to the </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// single bone named by the LightReferenceBoneName</P>

<P>GENESISAPI geBoolean GENESISCC geActor_GetLightingOptions(const geActor *A,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean *UseFillLight,&#9;&#9;&#9;// GE_TRUE or GE_FALSE</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *FillLightNormal,&#9;&#9;&#9;// normalized vector</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *FillLightRed,&#9;&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *FillLightGreen,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *FillLightBlue,&#9;&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *AmbientLightRed,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *AmbientLightGreen,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *AmbientLightBlue,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean *UseAmbientLightFromFloor,// GE_TRUE or GE_FALSE</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int *MaximumDynamicLightsToUse,&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const char **LightReferenceBoneName,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean *PerBoneLighting);&#9;&#9;// NULL for root</P>

<P>&nbsp;</P>
<P>GENESISAPI void GENESISCC geActor_SetScale(geActor *A, geFloat ScaleX,geFloat ScaleY,geFloat ScaleZ);</P>

<P>GENESISAPI geBoolean GENESISCC geActor_SetShadow(geActor *A, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;geBoolean DoShadow, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;geFloat Radius,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geBitmap *ShadowMap,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const char * BoneName);</P>

<P>//  Animation Cuing API:</P>
<P>// high level Actor animation:  The principle is that motions can be applied to an actor</P>
<P>// and the actor will keep track of which motions are currently appropriate.  Call </P>
<P>//&#9;_AnimationStep() to compute a new pose for an elapsed time interval.  The new pose</P>
<P>//  will take into account all motions that are 'currently' cued up to be set or blended.</P>

<P>&nbsp;</P>
<P>&#9;// cue up a new motion.  The motion begins at the current time.  The motion can be </P>
<P>&#9;// blended in or out over time and time scaled.  If the return value is GE_FALSE, the </P>
<P>&#9;// animation was not cued up (failure implies Actor is incompletely initialized).</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AnimationCue( </P>
<P>&#9;&#9;geActor *A,&#9;&#9;&#9;&#9;&#9;&#9;// actor to apply animation to</P>
<P>&#9;&#9;geMotion *Motion,&#9;&#9;&#9;&#9;// motion to Cue</P>
<P>&#9;&#9;geFloat TimeScaleFactor,&#9;&#9;// time scale to apply to cued motion</P>
<P>&#9;&#9;geFloat TimeIntoMotion,&#9;&#9;&#9;// time offset to begin motion with (Not TimeScaled)</P>
<P>&#9;&#9;geFloat BlendTime,&#9;&#9;&#9;&#9;// time to apply a blend. </P>
<P>&#9;&#9;geFloat BlendFromAmount,&#9;&#9;// blend value at current time</P>
<P>&#9;&#9;geFloat BlendToAmount,&#9;&#9;&#9;// blend value after BlendTime time has elapsed</P>
<P>&#9;&#9;const geXForm3d *MotionTransform);&#9;// local transform to adjust motion by (NULL implies NO transform)</P>

<P>&#9;// removes the last animation cue that was cued up.  Can be called repeatedly to successively</P>
<P>&#9;// remove older and older cues.  Returns GE_TRUE when a cue was removed, GE_FALSE if there </P>
<P>&#9;// are no cues to remove.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AnimationRemoveLastCue( geActor *A );</P>

<P>&#9;// applies a time step to actor A.  re-poses the actor according to all currently applicable</P>
<P>&#9;// Animation Cues. (failure implies Actor is incompletely initialized)</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AnimationStep(geActor *A, geFloat DeltaTime );</P>

<P>&#9;// applies a 'temporary' time step to actor A.  re-poses the actor according to all </P>
<P>&#9;// currently appliciable cues.  (failure implies Actor is incompletely initialized)</P>
<P>&#9;// DeltaTime is always relative to the the last AnimationStep()</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AnimationTestStep(geActor *A, geFloat DeltaTime);</P>

<P>&#9;// optimized version of geActor_AnimationStep.  Limits calculations to the bone named BoneName, and it's </P>
<P>&#9;// parents.  BoneName will be correctly computed, but the other bones will be wrong.  This is usefull for </P>
<P>&#9;// moving and animating an actor that is not actually visible.  Rendering and queries will be 'optimized'</P>
<P>&#9;// until the actor is given any pose or animation that doesn't go through geActor_AnimationStepBoneOptimized() or </P>
<P>&#9;//  geActor_AnimationTestStepBoneOptimized().  BoneName can be NULL to compute only 'root' bone.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AnimationStepBoneOptimized(geActor *A, geFloat DeltaTime, const char *BoneName );</P>

<P>&#9;// optimized version of geActor_AnimationTestStep.  Limits calculations to the bone named BoneName, and it's </P>
<P>&#9;// parents.  BoneName will be correctly computed, but the other bones will be wrong.  This is usefull for </P>
<P>&#9;// moving and animating an actor that is not actually visible.  Rendering and queries will be 'optimized'</P>
<P>&#9;// until the actor is given any pose or animation that doesn't go through geActor_AnimationStepBoneOptimized() or </P>
<P>&#9;//  geActor_AnimationTestStepBoneOptimized().  BoneName can be NULL to compute only 'root' bone.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AnimationTestStepBoneOptimized(geActor *A, geFloat DeltaTime, const char *BoneName);</P>

<P>&nbsp;</P>
<P>&#9;// applies an 'immediate' offset to the animated actor</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AnimationNudge(geActor *A, geXForm3d *Offset);</P>

<P>&nbsp;</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetAnimationEvent(geActor *A,&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;const char **ppEventString);&#9;&#9;// Return data, if return value is GE_TRUE</P>

<P>&#9;// returns number of actors that are currently created.</P>
<P>GENESISAPI int GENESISCC geActor_GetCount(void);</P>

<P>// GENESIS_PRIVATE_APIS</P>
<P>&#9;// call setscale and setshadow after preparing the actor for rendering (renderprep)</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558901"><A NAME="_Toc454069918">Basetype.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  BASETYPE.H                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:                                                                             */</P>
<P>/*  Description: Basic type definitions and calling convention defines                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_BASETYPE_H</P>
<P>#define GE_BASETYPE_H</P>
<P> </P>
<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>/******** The Genesis Calling Conventions ***********/ </P>

<P>#define&#9;GENESISCC&#9;_fastcall</P>

<P>#if&#9;defined(BUILDGENESIS) &amp;&amp; defined(GENESISDLLVERSION)</P>
<P>  #define GENESISAPI&#9;_declspec(dllexport)</P>
<P>#else</P>
<P>  #if&#9;defined(GENESISDLLVERSION)</P>
<P>    #define GENESISAPI&#9;_declspec(dllimport)</P>
<P>  #else</P>
<P>    #define GENESISAPI</P>
<P>  #endif</P>
<P>#endif</P>

<P>/******** The Basic Types ****************************/</P>

<P>typedef signed int geBoolean;</P>
<P>#define GE_FALSE&#9;(0)</P>
<P>#define GE_TRUE&#9;&#9;(1)</P>

<P>typedef float geFloat;</P>

<P>#ifndef NULL</P>
<P>#define NULL&#9;((void *)0)</P>
<P>#endif</P>

<P>typedef signed long     int32;</P>
<P>typedef signed short    int16;</P>
<P>typedef signed char     int8 ;</P>
<P>typedef unsigned long  uint32;</P>
<P>typedef unsigned short uint16;</P>
<P>typedef unsigned char  uint8 ;</P>

<P>/******** Macros on Genesis basic types *************/</P>

<P>#define GE_ABS(x)&#9;&#9;&#9;&#9;( (x) &lt; 0 ? (-(x)) : (x) )</P>
<P>#define GE_CLAMP(x,lo,hi)&#9;&#9;( (x) &lt; (lo) ? (lo) : ( (x) &gt; (hi) ? (hi) : (x) ) )</P>
<P>#define GE_CLAMP8(x)&#9;&#9;&#9;GE_CLAMP(x,0,255)</P>
<P>#define GE_CLAMP16(x)&#9;&#9;&#9;GE_CLAMP(x,0,65536)</P>
<P>#define GE_BOOLSAME(x,y)&#9;&#9;( ( (x) &amp;&amp; (y) ) || ( !(x) &amp;&amp; !(y) ) )</P>

<P>#define GE_EPSILON&#9;&#9;&#9;&#9;((geFloat)0.000797f)</P>
<P>#define GE_FLOATS_EQUAL(x,y)&#9;( GE_ABS((x) - (y)) &lt; GE_EPSILON )</P>
<P>#define GE_FLOAT_ISZERO(x)&#9;&#9;GE_FLOATS_EQUAL(x,0.0f)</P>

<P>#define&#9;GE_PI&#9;&#9;&#9;&#9;&#9;((geFloat)3.14159265358979323846f)</P>

<P>/****************************************************/</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P> </P>
<P> </P>
<P> </P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558902"><A NAME="_Toc454069919">Bitmap.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>#ifndef BITMAP_H</P>
<P>#define BITMAP_H</P>

<P>/****************************************************************************************/</P>
<P>/*  Bitmap.h                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description:  Abstract Bitmap system                                                */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#include "basetype.h"</P>
<P>#include "pixelformat.h"</P>
<P>#include "vfile.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>/***********************************************************************************/</P>

<P>typedef struct geBitmap&#9;&#9;&#9;geBitmap;</P>
<P>typedef struct geBitmap_Palette&#9;geBitmap_Palette;</P>

<P>typedef struct geBitmap_Info</P>
<P>{</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;&#9;Width;</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;&#9;Height;</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;&#9;Stride;&#9;&#9;// stride is in *pixels* ; it is the step to the next line : Stride &gt;= Width</P>
<P>&#9;gePixelFormat&#9;&#9;&#9;Format;</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;&#9;MinimumMip;&#9;//*including* minimumMip == 0 often</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;&#9;MaximumMip;&#9;//*including* maximumMip == nummips-1</P>
<P>&#9;geBoolean&#9;&#9;&#9;&#9;HasColorKey;</P>
<P>&#9;uint32&#9;&#9;&#9;&#9;&#9;ColorKey;&#9;// meaningless unless HasColorKey ; the ColorKey is a Pixel in Format</P>
<P>&#9;geBitmap_Palette *&#9;&#9;Palette;</P>
<P>} geBitmap_Info;</P>

<P>/***********************************************************************************/&#9;&#9;</P>
<P>// Bitmap methods</P>

<P>// see a big comment at the end of this file</P>

<P>/************************************************************************/</P>

<P>GENESISAPI geBitmap *&#9;GENESISCC&#9;geBitmap_Create(int Width, int Height, int MipCount, gePixelFormat Format ); </P>
<P>GENESISAPI void&#9;&#9;&#9;GENESISCC&#9;geBitmap_CreateRef(geBitmap *Bmp);</P>

<P>GENESISAPI geBitmap *&#9;GENESISCC&#9;geBitmap_CreateFromInfo(const geBitmap_Info * pInfo);</P>

<P>GENESISAPI geBitmap *&#9;GENESISCC&#9;geBitmap_CreateFromFile( geVFile *F );</P>
<P>GENESISAPI geBitmap *&#9;GENESISCC&#9;geBitmap_CreateFromFileName(const geVFile *BaseFS,const char *Name);</P>
<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_WriteToFile( const geBitmap *Bmp, geVFile *F );</P>
<P>GENESISAPI geBoolean&#9;GENESISCC&#9;geBitmap_WriteToFileName(const geBitmap * Bmp,const geVFile *BaseFS,const char *Name);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// BaseFS is not really const if it is a virtual file;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//  it *is* const if it is a dos directory</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_Destroy(geBitmap **Bmp);</P>
<P>&#9;// returns whether Bmp was actually destroyed : not success/failure</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_GetInfo(const geBitmap *Bmp, geBitmap_Info *Info, geBitmap_Info *SecondaryInfo);</P>
<P>&#9;//LockForWrite returns data in Info's format</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_Blit(const&#9;geBitmap *Src, int SrcPositionX, int SrcPositionY,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap *Dst, int DstPositionX, int DstPositionY,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int SizeX, int SizeY );</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_BlitMip(const geBitmap * Src, int SrcMip, geBitmap * Dst, int DstMip );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// don't use this with Src == Dst, use UpdateMips instead !</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_BlitBitmap(const geBitmap * Src, geBitmap * Dst);</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_BlitBestMip(const geBitmap * Src, geBitmap * Dst);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// blits the largest mip from Src that fits in Dst</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_LockForRead(&#9;&#9;// a non-exclusive lock</P>
<P>&#9;const geBitmap *&#9;Bmp,</P>
<P>&#9;geBitmap **&#9;&#9;&#9;Target,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MinimumMip,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MaximumMip,</P>
<P>&#9;gePixelFormat &#9;&#9;Format,</P>
<P>&#9;geBoolean&#9;&#9;&#9;RespectColorKey,</P>
<P>&#9;uint32&#9;&#9;&#9;&#9;ColorKey);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// not really const, stores lock-count, but *data* is const</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// will do a format conversion!</P>

<P>GENESISAPI geBoolean&#9;GENESISCC&#9;geBitmap_LockForReadNative(</P>
<P>&#9;const geBitmap *&#9;Bmp,</P>
<P>&#9;geBitmap **&#9;&#9;&#9;Target,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MinimumMip,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MaximumMip);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// lock for read in a format that gaurantee no conversions</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// then do GetInfo on the locks to see what you have!</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_LockForWrite(&#9;// an exclusive lock</P>
<P>&#9;geBitmap *&#9;&#9;&#9;Bmp,</P>
<P>&#9;geBitmap **&#9;&#9;&#9;Target,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MinimumMip,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MaximumMip);</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_LockForWriteFormat(</P>
<P>&#9;geBitmap *&#9;&#9;&#9;Bmp,</P>
<P>&#9;geBitmap **&#9;&#9;&#9;Target,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MinimumMip,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MaximumMip,</P>
<P>&#9;gePixelFormat &#9;&#9;Format);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Format must be one of the two returned in GetInfo !!</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_UnLock(geBitmap *Bmp);&#9;// must be done on All locked mips</P>
<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_UnLockArray(geBitmap **Locks,int Size);</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_SetFormat(geBitmap *Bmp, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;gePixelFormat NewFormat, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean RespectColorKey, uint32 ColorKey,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geBitmap_Palette * Palette);</P>
<P>&#9;// _SetFormat may cause you to lose color information!</P>
<P>&#9;// SetFormat does a conversion!</P>
<P>&#9;// if NewFormat is palettized and Palette is NULL, we create a palette for the bitmap!</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_SetFormatMin(geBitmap *Bmp,gePixelFormat NewFormat);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// the Min version keeps colorkey &amp; palette from the old format</P>

<P>GENESISAPI geBoolean&#9;GENESISCC&#9;geBitmap_SetColorKey(geBitmap *Bmp, geBoolean HasColorKey, uint32 ColorKey, geBoolean Smart);</P>
<P>&#9;// SetColorKey discards old colorkey information!</P>
<P>&#9;//&#9;does not do a conversion (changes the colorkey in the current data</P>
<P>&#9;// if 'Smart' is on, we don't set HasColorKey to true unless it is actually used!</P>

<P>GENESISAPI geBoolean&#9;GENESISCC&#9;geBitmap_GetAverageColor(const geBitmap *Bmp,int *pR,int *pG,int *pB);</P>
<P>&#9;// tells you the average color; computes it and caches it out</P>

<P>GENESISAPI geBitmap_Palette * &#9;GENESISCC&#9;geBitmap_GetPalette(const geBitmap *Bmp);</P>
<P>GENESISAPI geBoolean&#9;&#9;&#9;GENESISCC&#9;geBitmap_SetPalette(geBitmap *Bmp, const geBitmap_Palette *Palette);</P>
<P>&#9;// _SetPal tries to _CreateRef your Palette, so no copy occurs &amp; palettes may be shared</P>
<P>&#9;// you may _Destroy() palette after using it to set (though its bits may not be freed)</P>
<P>&#9;//&#9;(hence Palette is *not* const)</P>
<P>&#9;// Warning : SetPalette on any mip changes the palette of ALL mips !</P>
<P>&#9;// see Palette note at _UnLock</P>
<P>&#9;// _SetPal destroys the bitmap's original palette and refs the new one, </P>
<P>&#9;//&#9;&#9;so if you setpal with the bitmap's palette, there is no net change in ref counts (good!)</P>

<P>GENESISAPI geBoolean&#9;GENESISCC&#9;geBitmap_HasAlpha(const geBitmap * Bmp);</P>
<P>&#9;// returns true if bitmap has *any* type of alpha</P>

<P>GENESISAPI geBitmap *&#9;GENESISCC&#9;geBitmap_GetAlpha(const geBitmap *Bmp);</P>
<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_SetAlpha(geBitmap *Bmp, const geBitmap *AlphaBmp);</P>
<P>&#9;// we Ref the AlphaBmp, so you may destroy it after calling Set()</P>
<P>&#9;// it may be NULL</P>
<P>&#9;// there's only one Alpha per bitmap (for the top Mip) right now</P>

<P>GENESISAPI geBoolean&#9;GENESISCC&#9;geBitmap_SetGammaCorrection(geBitmap *Bmp,geFloat Gamma,geBoolean Apply);</P>
<P>&#9;// this Gamma does not change the *original* (system/secondary) bits</P>
<P>&#9;//&#9;it only affects the appearance when drawn</P>
<P>&#9;// note : if you write to the gamma corrected bits, you must gamma correct manually if you</P>
<P>&#9;//&#9;wish to fit in smoothly with the previous data</P>
<P>&#9;// warning : if you use this function with many different gammas, performance will suffer!</P>
<P>&#9;//&#9;use one global gamma for all bitmaps!  try to let the engine manage gamma for you,</P>
<P>&#9;//&#9;via geEngine_SetGamma !</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_SetPreferredFormat(geBitmap *Bmp,gePixelFormat Format);</P>
<P>GENESISAPI gePixelFormat&#9;GENESISCC&#9;geBitmap_GetPreferredFormat(const geBitmap *Bmp);</P>

<P>GENESISAPI void *&#9;&#9;GENESISCC&#9;geBitmap_GetBits(geBitmap *Bmp);&#9;// works only on a Lock()</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_RefreshMips(geBitmap *Bmp);&#9;// rebuilds mips; *tries* to be smart &amp; not overwrite manually-fixed mips</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// RefreshMips does *not* build mips that don't exist</P>
<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_UpdateMips(geBitmap *Bmp,int SourceMip,int TargetMip);&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// will create the target if it doesn't exist;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// will overwrite manually-fixed mips!</P>
<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_SetMipCount(geBitmap *Bmp,int Count);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// creates or destroys to match the new count</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_ClearMips(geBitmap *Bmp);&#9;// Destroy all mips (except the first) !</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// use with care! this is not polite!</P>

<P>// Shortcuts</P>
<P>GENESISAPI int&#9;&#9;&#9;GENESISCC&#9;geBitmap_Width(const geBitmap *Bitmap);</P>
<P>GENESISAPI int&#9;&#9;&#9;GENESISCC&#9;geBitmap_Height(const geBitmap *Bitmap);</P>
<P>GENESISAPI uint32&#9;&#9;GENESISCC&#9;geBitmap_MipBytes(const geBitmap * Bitmap,int mip);</P>

<P>/**</P>
<P>*</P>
<P>* if Bitmap is a lock for read, functions that modify it return failure</P>
<P>* if Bitmap is a lock for write, functions that modify it attempt to</P>
<P>*&#9;modify the owner of the lock</P>
<P>*</P>
<P>* warning : if you lock multiple mips for write, and then modify one of the mips</P>
<P>*&#9;&#9;(such as via SetPalette) it may affect the owner and all sibling mips!</P>
<P>*&#9;&#9;doing different SetPalettes with different palettes on different locked mips </P>
<P>*&#9;&#9;has undefined behavior!</P>
<P>*</P>
<P>**/</P>

<P>#ifdef _DEBUG</P>
<P>GENESISAPI uint32&#9;&#9;GENESISCC&#9;geBitmap_Debug_GetCount(void);</P>

<P>&#9;// assert this is zero before you shutdown !</P>

<P>#endif</P>

<P>/***********************************************************************************/</P>

<P>typedef enum</P>
<P>{</P>
<P>&#9;GE_BITMAP_STREAMING_ERROR=0,</P>
<P>&#9;GE_BITMAP_STREAMING_NOT,</P>
<P>&#9;GE_BITMAP_STREAMING_STARTED,</P>
<P>&#9;GE_BITMAP_STREAMING_IDLE,</P>
<P>&#9;GE_BITMAP_STREAMING_CHANGED,</P>
<P>&#9;GE_BITMAP_STREAMING_DATADONE,</P>
<P>&#9;GE_BITMAP_STREAMING_DONE,</P>
<P>} geBitmap_StreamingStatus;</P>

<P>GENESISAPI geBitmap_StreamingStatus GENESISCC geBitmap_GetStreamingStatus(const geBitmap *Bmp);</P>

<P>&#9;&#9;/** on a file which is streaming, the sequence of returns looks like :</P>

<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_IDLE</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_CHANGED</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_IDLE</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_IDLE</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_CHANGED</P>
<P>&#9;&#9;&#9;...</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_DONE</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_NOT</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_NOT</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_NOT</P>
<P>&#9;&#9;&#9;...</P>

<P>&#9;&#9;Status &gt;= GE_BITMAP_STREAMING_STARTED means streaming has started &amp; is in progress</P>

<P>&#9;&#9;the user should never see _STARTED or _DATADONE</P>

<P>&#9;&#9;***/</P>

<P>/***********************************************************************************/</P>

<P>// palette methods :</P>

<P>GENESISAPI geBitmap_Palette * &#9;GENESISCC&#9;geBitmap_Palette_Create(gePixelFormat Format,int Size);</P>

<P>GENESISAPI geBitmap_Palette * &#9;GENESISCC&#9;geBitmap_Palette_CreateCopy(const geBitmap_Palette *Palette);</P>

<P>GENESISAPI geBitmap_Palette *&#9;GENESISCC&#9;geBitmap_Palette_CreateFromFile(geVFile *F);</P>

<P>GENESISAPI geBitmap_Palette *&#9;GENESISCC&#9;geBitmap_Palette_CreateFromBitmap(geBitmap * Bmp,geBoolean Slow);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// does GetPalette, and if NULL, then</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// it create an optimal palette for a</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//&#9;non-palettized bitmap</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//&#9;(this is a create, you must destroy later!)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// put Slow == TRUE for higher quality &amp; slower</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_SortColors(geBitmap_Palette * P,geBoolean Slower);</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_CreateRef(geBitmap_Palette *Palette);</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_Destroy(geBitmap_Palette ** ppPalette);</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_WriteToFile(const geBitmap_Palette *Palette,geVFile *F);</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_SetFormat(geBitmap_Palette * Palette,gePixelFormat Format);</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_Copy(const geBitmap_Palette * Src,geBitmap_Palette * Target);</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_GetInfo(const&#9;geBitmap_Palette *P,geBitmap_Info *Into);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// get the info as if it were a bitmap; Into-&gt;Height == 1</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_Lock(geBitmap_Palette *Palette, void **pBits, gePixelFormat *pFormat,int *pSize);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// pFormat &amp; pSize are optional</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_UnLock(geBitmap_Palette *Palette);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// palette unlock does NOT notify the bitmap that the palette has changed.</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// call Bitmap_SetPalette() with the same palette pointer </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// &#9;to tell the bitmap that it must to some processing</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// (don't worry, it won't duplicate it or copy it onto itself)</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_GetData(const geBitmap_Palette *P,      void *Into,gePixelFormat Format,int Colors);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_SetData(      geBitmap_Palette *P,const void *From,gePixelFormat Format,int Colors);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// does Lock/UnLock for you</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// From and Into are arrays of Colors*gePixelFormat_BytesPerPel bytes</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_SetEntryColor(      geBitmap_Palette *P,int Color,int R,int G,int B,int A);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_GetEntryColor(const geBitmap_Palette *P,int Color,int *R,int *G,int *B,int *A);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Set/Get does Lock/Unlock for you ; these are slow! do not use these to work on all the colors!</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_SetEntry(      geBitmap_Palette *P,int Color,uint32 Pixel);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_GetEntry(const geBitmap_Palette *P,int Color,uint32 *Pixel);</P>

<P>/***********************************************************************************/</P>

<P>/************************************************************************</P>

<P>A brief tutorial on the Bitmap system, by Charles Bloom, cbloom@eclipsegames.com</P>

<P>The Bitmap is a smart wrapper for complex functionality.  You give it hints to</P>
<P>the opaque Bitmap object, and it tries its best to follow those hints, but it</P>
<P>may not always do so.  The Bitmap is the owner of its bits; you must Lock the</P>
<P>bitmap to get permission to touch those bits, and UnLock to tell the bitmap</P>
<P>you are done.  The format may change between two Locks.  Bitmaps can also be</P>
<P>multiply owned, so you should account for the fact that others may touch your</P>
<P>bitmap between your uses.</P>

<P>The Bitmap contains one or two pixel-sets representing an image.  The "primary" is</P>
<P>a fast-blitting version of the image, and the "secondary" is a storage version</P>
<P>(eventually wavelet compressed) which can be used to rebuild the primary if it is</P>
<P>freed or damaged.  Both cary a generalized format.</P>

<P>Let's do an example.  I want to load a bitmap, set it up for drawing with the</P>
<P>genesis Engine, and then blit some interactive stuff into it.</P>

<P>************************************************************************/</P>

<P>#if 0</P>
<P>// {</P>
<P>//-----------------------------------------------------------------------------</P>

<P>void Init(geEngine * Engine);</P>
<P>void Shutdown(void);</P>
<P>void Draw(void);</P>
<P>void DrawPolite(void);</P>

<P>static geBitmap * myBM = NULL;</P>
<P>static geEngine * myEngine = NULL;</P>

<P>void Init(geEngine * Engine)</P>
<P>{</P>
<P>geBoolean success;</P>
<P>geBitmap_Info Info;</P>

<P>&#9;myEngine = Engine;&#9;// this is not looked well upon; for ease of demonstration only!</P>
<P>&#9;assert(Engine);</P>

<P>&#9;myBM = geBitmap_CreateFromFileName(NULL,"mybitmap.bmp");</P>

<P>&#9;// CreateFromFile can load windows BMP files, or custom GeBm files.</P>

<P>&#9;assert(myBM);</P>

<P>&#9;// get the main info; I don't care about the secondary, so leave it NULL</P>

<P>&#9;success = geBitmap_GetInfo(myBM,&amp;Info,NULL);</P>
<P>&#9;assert(success);</P>

<P>&#9;// make sure I loaded a bitmap in the format I understand !</P>

<P>&#9;if ( Info.Format == GE_PIXELFORMAT_8BIT_PAL )</P>
<P>&#9;{</P>
<P>&#9;&#9;// I want palette index 255 to act as transparency, so I must use SetColorKey</P>

<P>&#9;&#9;success = geBitmap_SetColorKey(myBM,GE_TRUE,255);</P>
<P>&#9;&#9;assert(success);</P>

<P>&#9;&#9;// just for fun, let's modify the palette:</P>
<P>&#9;&#9;if (1)</P>
<P>&#9;&#9;{</P>
<P>&#9;&#9;geBitmap_Palette * Pal;</P>

<P>&#9;&#9;&#9;// get the palette ; I don't care if its primary or secondary, so</P>
<P>&#9;&#9;&#9;/// I don't use the Info.Palette field</P>

<P>&#9;&#9;&#9;Pal = geBitmap_GetPalette(myBM);</P>
<P>&#9;&#9;&#9;assert(Pal);</P>

<P>&#9;&#9;&#9;// I'm only fiddling one entry, so don't bother with a full Lock() UnLock()</P>
<P>&#9;&#9;&#9;//  sequence on the palette</P>

<P>&#9;&#9;&#9;// make palette index zero bright red; we use alpha = 255 for opaque</P>

<P>&#9;&#9;&#9;success = geBitmap_Palette_SetEntryColor(Pal,0,255,0,0,255);</P>
<P>&#9;&#9;&#9;assert(success);</P>

<P>&#9;&#9;&#9;// tell the bitmap system you've changed the palette; this function</P>
<P>&#9;&#9;&#9;//  is smart enough to not do unecessary copies or whatever.</P>

<P>&#9;&#9;&#9;success = geBitmap_SetPalette(myBM,Pal);</P>
<P>&#9;&#9;&#9;assert(success);</P>
<P>&#9;&#9;}</P>

<P>&#9;}</P>
<P>&#9;else</P>
<P>&#9;{</P>
<P>&#9;&#9;// otherwise, treat black as transparent, in whatever format I have</P>

<P>&#9;&#9;success = geBitmap_SetColorKey(myBM,GE_TRUE,gePixelFormat_ComposePixel(Info.Format,0,0,0,0));</P>
<P>&#9;&#9;assert(success);</P>
<P>&#9;}&#9;</P>

<P>&#9;// note that I did NOT use SetFormat.  SetFormat may do a conversion, and since the original</P>
<P>&#9;//&#9;bitmap was created without colorkey, it would have been converted to a new format but</P>
<P>&#9;//&#9;kept its property of having no colorkey!</P>
<P>&#9;// (SetFormat will fiddle the bits and whatever way necessary to keep bitmaps as visually similar</P>
<P>&#9;//&#9;&#9;as possible)</P>

<P>&#9;// I want to fiddle the fast format in 565 later, so cue the bitmap to try to give me that format.</P>

<P>&#9;success = geBitmap_SetPreferredFormat(myBM,GE_PIXELFORMAT_16BIT_565_RGB);</P>
<P>&#9;assert(success);</P>

<P>&#9;// Add it to the engine so it can be used for drawing.</P>

<P>&#9;success = geEngine_AddBitmap(myEngine,myBM);</P>
<P>&#9;assert(success);</P>
<P>}</P>

<P>void Shutdown(void)</P>
<P>{</P>
<P>geBoolean WasDestroyed;</P>

<P>&#9;assert(myBM);</P>
<P>&#9;</P>
<P>&#9;// clean up</P>

<P>&#9;geEngine_RemoveBitmap(myEngine,myBM);</P>

<P>&#9;WasDestroyed = geBitmap_Destroy(&amp;myBM);</P>

<P>&#9;// someone else might have done _CreateRef on our bitmap,</P>
<P>&#9;//  so we can't be sure it's actually destroyed.</P>
<P>&#9;// this code is still ready to be run again with a new call to Init()</P>

<P>&#9;//assert(WasDestroyed);</P>

<P>&#9;myBM = NULL;</P>
<P>&#9;myEngine = NULL;</P>
<P>}</P>

<P>void Draw(void)</P>
<P>{</P>
<P>geBitmap * Lock;</P>
<P>geBoolean success;</P>
<P>geBitmap_Info Info;</P>
<P>uint16 *bits,*bptr;</P>
<P>int x,y;</P>

<P>&#9;// lets fiddle the bits.</P>
<P>&#9;// we need to lock the bitmap for write.</P>
<P>&#9;//&#9;LockForWrite is an exclusive lock, unlike LockForRead which is non-blocking</P>
<P>&#9;// request our favorite format, and only lock Mip 0 (the full size bitmap)</P>

<P>&#9;success = geBitmap_LockForWriteFormat(myBM,&amp;Lock,0,0,GE_PIXELFORMAT_16BIT_565_RGB);</P>
<P>&#9;if ( ! success )</P>
<P>&#9;{</P>
<P>&#9;&#9;// well, we tried to be nice; if we were very polite, we would do a LockForWrite</P>
<P>&#9;&#9;// here, and try to fiddle the bits in whatever format we got; However, we aren't</P>
<P>&#9;&#9;// that polite, so we just do a _SetFormat</P>
<P>&#9;&#9;//</P>
<P>&#9;&#9;// note that we are destroying the original bitmap by changing its format</P>
<P>&#9;&#9;// we should only do this if we are going to draw into the bitmap</P>

<P>&#9;&#9;success = geBitmap_SetFormat(myBM,GE_PIXELFORMAT_16BIT_565_RGB,GE_TRUE,0,NULL);</P>
<P>&#9;&#9;assert(success);</P>

<P>&#9;&#9;// now we should be able to get the bits we want, *but* they may not be the</P>
<P>&#9;&#9;// primary (fast) format; oh well, it's the best we can do...</P>
<P>&#9;&#9;// (if you must have the fastest bits, then use only _LockForWrite, never LockForWriteFormat,</P>
<P>&#9;&#9;// which might have to do a conversion)</P>

<P>&#9;&#9;success = geBitmap_LockForWriteFormat(myBM,&amp;Lock,0,0,GE_PIXELFORMAT_16BIT_565_RGB);</P>
<P>&#9;&#9;assert(success);</P>
<P>&#9;}</P>

<P>&#9;// now Lock is our bitmap in 565</P>
<P>&#9;// we do a GetInfo because the Lock's info could be different than</P>
<P>&#9;//&#9;the original bitmap's (particularly the Palette &amp; the Stride)</P>

<P>&#9;success = geBitmap_GetInfo(Lock,&amp;Info,NULL);</P>
<P>&#9;assert(success);</P>

<P>&#9;// you can only call _GetBits on a locked bitmap</P>

<P>&#9;bits = geBitmap_GetBits(Lock);</P>
<P>&#9;assert( bits );</P>

<P>&#9;bptr = bits;</P>
<P>&#9;for(y=0; y &lt; Info.Height; y++)</P>
<P>&#9;{</P>
<P>&#9;&#9;for(x=0; x &lt; Info.Width; x++)</P>
<P>&#9;&#9;{</P>
<P>&#9;&#9;uint16 R,G,B;</P>
<P>&#9;&#9;&#9;// make a silly 565 gradient</P>
<P>&#9;&#9;&#9;R = x &amp; 0x1F;</P>
<P>&#9;&#9;&#9;G = x &amp; 0x3F;</P>
<P>&#9;&#9;&#9;B = y &amp; 0x1F;</P>

<P>&#9;&#9;&#9;*bptr++ = (R&lt;&lt;11) + (G&lt;&lt;5) + B;</P>
<P>&#9;&#9;}</P>

<P>&#9;&#9;// note that bptr is a word pointer, and Stride is in pixels :</P>

<P>&#9;&#9;bptr += Info.Stride -  Info.Width;</P>
<P>&#9;}</P>
<P>&#9;bits = bptr = NULL;</P>

<P>&#9;// you call Unlock on all the mips you locked - not on the original bitmap!</P>

<P>&#9;success = geBitmap_UnLock(Lock);</P>
<P>&#9;assert(success);</P>

<P>&#9;// now, we only fiddled the full-size Mip, and there might be more,</P>
<P>&#9;//  so lets percolate the changes into the smaller mips:</P>

<P>&#9;success = geBitmap_RefreshMips(myBM);</P>
<P>&#9;assert(success);</P>

<P>&#9;// a null rect means use the whole bitmap;</P>
<P>&#9;// Engine_DrawBitmap blits a 2d decal to the framebuffer (fast)</P>

<P>&#9;success = geEngine_DrawBitmap(myEngine,myBM,NULL,0,0);</P>
<P>&#9;assert(success);</P>

<P>}</P>

<P>void DrawPolite(void)</P>
<P>{</P>
<P>geBitmap * Lock;</P>
<P>geBoolean success;</P>
<P>geBitmap_Info Info;</P>
<P>void *bits;</P>
<P>int x,y;</P>

<P>&#9;// this function does the same thing as Draw() , but is more polite</P>
<P>&#9;// lock in the fastest format (whatever it is)</P>
<P>&#9;// because we did SetPreferred, this should be 565_RGB, but might not be</P>

<P>&#9;success = geBitmap_LockForWrite(myBM,&amp;Lock,0,0);</P>
<P>&#9;assert(success);</P>

<P>&#9;success = geBitmap_GetInfo(Lock,&amp;Info,NULL);</P>
<P>&#9;assert(success);</P>

<P>&#9;bits = geBitmap_GetBits(Lock);</P>
<P>&#9;assert( bits );</P>

<P>&#9;if ( Info.Format == GE_PIXELFORMAT_16BIT_565_RGB )</P>
<P>&#9;{</P>
<P>&#9;uint16 *wptr;</P>

<P>&#9;&#9;// our favorite format</P>

<P>&#9;&#9;wptr = bits;</P>
<P>&#9;&#9;for(y=0; y &lt; Info.Height; y++)</P>
<P>&#9;&#9;{</P>
<P>&#9;&#9;&#9;for(x=0; x &lt; Info.Width; x++)</P>
<P>&#9;&#9;&#9;{</P>
<P>&#9;&#9;&#9;uint16 R,G,B;</P>
<P>&#9;&#9;&#9;&#9;// make a silly 565 gradient</P>
<P>&#9;&#9;&#9;&#9;R = x &amp; 0x1F;</P>
<P>&#9;&#9;&#9;&#9;G = x &amp; 0x3F;</P>
<P>&#9;&#9;&#9;&#9;B = y &amp; 0x1F;</P>

<P>&#9;&#9;&#9;&#9;*wptr++ = (R&lt;&lt;11) + (G&lt;&lt;5) + B;</P>
<P>&#9;&#9;&#9;}</P>
<P>&#9;&#9;&#9;wptr += Info.Stride -  Info.Width;</P>
<P>&#9;&#9;}</P>
<P>&#9;}</P>
<P>&#9;else</P>
<P>&#9;{</P>
<P>&#9;uint8 * bptr;</P>

<P>&#9;&#9;// oh well, do our best</P>
<P>&#9;&#9;// bitmaps must have had a good reason to not give us the format we preferred,</P>

<P>&#9;&#9;bptr = bits;</P>
<P>&#9;&#9;for(y=0; y &lt; Info.Height; y++)</P>
<P>&#9;&#9;{</P>
<P>&#9;&#9;&#9;for(x=0; x &lt; Info.Width; x++)</P>
<P>&#9;&#9;&#9;{</P>
<P>&#9;&#9;&#9;uint32 R,G,B;</P>

<P>&#9;&#9;&#9;&#9;// put a color in any format</P>

<P>&#9;&#9;&#9;&#9;R = (x &amp; 0x1F)&lt;&lt;3;</P>
<P>&#9;&#9;&#9;&#9;G = (x &amp; 0x3F)&lt;&lt;2;</P>
<P>&#9;&#9;&#9;&#9;B = (y &amp; 0x1F)&lt;&lt;3;</P>

<P>&#9;&#9;&#9;&#9;// we use alpha of 255 for opaque</P>

<P>&#9;&#9;&#9;&#9;gePixelFormat_PutColor(Info.Format,&amp;bptr,R,G,B,255);</P>
<P>&#9;&#9;&#9;}</P>

<P>&#9;&#9;&#9;bptr += (Info.Stride -  Info.Width) * gePixelFormat_BytesPerPel(Info.Format);</P>
<P>&#9;&#9;}</P>
<P>&#9;}</P>
<P>&#9;bits = NULL;</P>

<P>&#9;// same as before:</P>

<P>&#9;success = geBitmap_UnLock(Lock);</P>
<P>&#9;assert(success);</P>

<P>&#9;success = geBitmap_RefreshMips(myBM);</P>
<P>&#9;assert(success);</P>

<P>&#9;success = geEngine_DrawBitmap(myEngine,myBM,NULL,0,0);</P>
<P>&#9;assert(success);</P>

<P>}</P>

<P>// end tutorial on the Bitmap system</P>
<P>//-----------------------------------------------------------------------------</P>
<P>// }</P>

<P>/***********************************************************************************/</P>

<P>#endif</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558903"><A NAME="_Toc454069920">Body.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  BODY.H                                                                              */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description: Actor body interface.&#9;&#9;                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_BODY_H</P>
<P>#define GE_BODY_H </P>

<P>/* This object is for managing the data associated with a skeletal-based mesh, </P>
<P>   a 'body'.</P>
<P>   This object holds the geometry for the body and the list of materials needed.</P>
<P>*/</P>

<P>#include "basetype.h"</P>
<P>#include "xform3d.h"</P>
<P>#include "vfile.h"</P>
<P>#include "bitmap.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define GE_BODY_NUMBER_OF_LOD&#9;&#9;&#9;(4)&#9;&#9;// 0 is highest detail</P>
<P>#define GE_BODY_NO_PARENT_BONE         (-1)   </P>
<P>#define GE_BODY_HIGHEST_LOD            (0)</P>

<P>#define GE_BODY_ROOT&#9;&#9;&#9;&#9;&#9;(-1)&#9;// for specifying 'root' bounding box.</P>

<P>typedef struct geBody geBody;</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>geBody *GENESISCC geBody_Create(void);</P>

<P>void GENESISCC geBody_Destroy(geBody **B);</P>

<P>geBoolean GENESISCC geBody_IsValid(const geBody *B);</P>

<P>&nbsp;</P>
<P>geBoolean GENESISCC geBody_GetGeometryStats(const geBody *B, int lod, int *Vertices, int *Faces, int *Normals);</P>

<P>geBoolean GENESISCC geBody_AddFace(&#9;geBody *B,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Vertex1, const geVec3d *Normal1, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat U1, geFloat V1, int BoneIndex1,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Vertex2, const geVec3d *Normal2, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat U2, geFloat V2, int BoneIndex2,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Vertex3, const geVec3d *Normal3, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat U3, geFloat V3, int BoneIndex3,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int MaterialIndex);</P>

<P>&#9;&#9;&#9;// Bitmap is added to body.  It's reference count is increased.  Caller still owns a pointer</P>
<P>&#9;&#9;&#9;// to the bitmap, and is responsible for destroying it.</P>
<P>geBoolean GENESISCC geBody_AddMaterial( geBody *B, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const char *MaterialName, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap *Bitmap,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Red, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Green, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Blue,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int *MaterialIndex);</P>

<P>&#9;&#9;&#9;// returned bitmap is a pointer to the bitmap in the body's list.  It may not be destroyed.</P>
<P>&#9;&#9;&#9;// if caller would like to 'own' a copy of that bitmap pointer, it should call geBitmap_CreateRef()</P>
<P>geBoolean GENESISCC geBody_GetMaterial(const geBody *Body, int MaterialIndex,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const char **MaterialName,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap **Bitmap, geFloat *Red, geFloat *Green, geFloat *Blue);</P>

<P>&#9;&#9;&#9;// Bitmap is set into the body.  It's reference count is increased.  Caller still owns a pointer</P>
<P>&#9;&#9;&#9;// to the bitmap, and is responsible for destroying it.</P>
<P>geBoolean GENESISCC geBody_SetMaterial(geBody *Body, int MaterialIndex,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap *Bitmap,  geFloat Red,  geFloat Green,  geFloat Blue);</P>

<P>int GENESISCC geBody_GetMaterialCount(const geBody *B);</P>

<P>geBoolean GENESISCC geBody_AddBone( geBody *B, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;int ParentBoneIndex,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;const char *BoneName, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d *AttachmentMatrix,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;int *BoneIndex);</P>

<P>geBoolean GENESISCC geBody_ComputeLevelsOfDetail( geBody *B ,int Levels);</P>

<P>int GENESISCC geBody_GetBoneCount(const geBody *B);</P>

<P>void GENESISCC geBody_GetBone(&#9;const geBody *B, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;int BoneIndex, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const char **BoneName,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;geXForm3d *Attachment, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;int *ParentBoneIndex);</P>

<P>int32 GENESISCC geBody_GetBoneNameChecksum(const geBody *B);</P>

<P>void GENESISCC geBody_SetBoundingBox( geBody *B,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;int BoneIndex,&#9;&#9;// GE_BODY_ROOT for specifing 'root' bounding box.</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *MinimumBoxCorner,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *MaximumBoxCorner);</P>
<P> </P>

<P>geBoolean GENESISCC geBody_GetBoundingBox( const geBody *B, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;int BoneIndex,&#9;&#9;// GE_BODY_ROOT for specifing 'root' bounding box.</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *MinimumBoxCorner,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *MaximumBoxCorner);</P>

<P>geBoolean GENESISCC geBody_GetBoneByName(const geBody* B,</P>
<P>&#9;const char* BoneName,</P>
<P>&#9;int* pBoneIndex,</P>
<P>&#9;geXForm3d* Attachment,</P>
<P>&#9;int* pParentBoneIndex);</P>

<P>geBoolean GENESISCC geBody_WriteToFile(const geBody *B, geVFile *pFile);</P>
<P>geBody  *GENESISCC  geBody_CreateFromFile(geVFile *pFile);</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558904"><A NAME="_Toc454069921">Errorlog.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  ERRORLOG.H                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige                                                                */</P>
<P>/*  Description: Generic error logging system interface                                 */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_ERRORLOG_H</P>
<P>#define GE_ERRORLOG_H</P>

<P>#include "basetype.h"</P>

<P>#ifndef NDEBUG </P>
<P>&#9;#define ERRORLOG_FULL_REPORTING</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef enum</P>
<P>{</P>
<P>&#9;GE_ERR_INVALID_DRIVER_HANDLE,&#9;&#9;&#9;// Driver not supported</P>
<P>&#9;GE_ERR_INVALID_MODE_HANDLE,&#9;&#9;&#9;&#9;// Mode not supported</P>
<P>&#9;GE_ERR_DRIVER_INIT_FAILED,&#9;&#9;&#9;&#9;// Could not init Driver</P>
<P>&#9;GE_ERR_DRIVER_ALLREADY_INITIALIZED,&#9;&#9;// Driver init failure</P>
<P>&#9;GE_ERR_DRIVER_NOT_FOUND,&#9;&#9;&#9;&#9;// File open error for driver</P>
<P>&#9;GE_ERR_DRIVER_NOT_INITIALIZED,&#9;&#9;&#9;// Driver shutdown failure</P>
<P>&#9;GE_ERR_INVALID_DRIVER,&#9;&#9;&#9;&#9;&#9;// Wrong driver version, or bad driver</P>
<P>&#9;GE_ERR_DRIVER_BEGIN_SCENE_FAILED,</P>
<P>&#9;GE_ERR_DRIVER_END_SCENE_FAILED,</P>
<P>&#9;GE_ERR_CREATE_SOUND_MANAGER_FAILED,</P>
<P>&#9;GE_ERR_CREATE_SOUND_BUFFER_FAILED,</P>
<P>&#9;GE_ERR_DS_ERROR,</P>
<P>&#9;GE_ERR_INVALID_WAV,</P>
<P>&#9;GE_ERR_NO_PERF_FREQ,</P>
<P>&#9;GE_ERR_FILE_OPEN_ERROR,</P>
<P>&#9;GE_ERR_FILE_READ_ERROR,</P>
<P>&#9;GE_ERR_FILE_WRITE_ERROR,</P>
<P>&#9;GE_ERR_PALETTE_LOAD_FAILURE,</P>
<P>&#9;GE_ERR_GBSP_LOAD_FAILURE,</P>
<P>&#9;GE_ERR_INVALID_PARMS,</P>
<P>&#9;GE_ERR_INVALID_CAMERA,</P>
<P>&#9;GE_ERR_RENDER_WORLD_FAILED,</P>
<P>&#9;GE_ERR_BEGIN_WORLD_FAILED,</P>
<P>&#9;GE_ERR_END_WORLD_FAILED,</P>
<P>&#9;GE_ERR_BEGIN_MODELS_FAILED,</P>
<P>&#9;GE_ERR_END_MODELS_FAILED,</P>
<P>&#9;GE_ERR_BEGIN_MESHES_FAILED,</P>
<P>&#9;GE_ERR_END_MESHES_FAILED,</P>
<P>&#9;GE_ERR_RENDER_MESH_FAILED,</P>
<P>&#9;GE_ERR_BAD_LMAP_EXTENTS,</P>
<P>&#9;GE_ERR_INVALID_TEXTURE,</P>
<P>&#9;GE_ERR_REGISTER_WORLD_TEXTURE_FAILED,</P>
<P>&#9;GE_ERR_REGISTER_LIGHTMAPS_FAILED,</P>
<P>&#9;GE_ERR_REGISTER_WORLD_PALETTE_FAILED,</P>
<P>&#9;GE_ERR_REGISTER_MISC_TEXTURE_FAILED,</P>
<P>&#9;GE_ERR_INVALID_MESH_FILE,</P>
<P>&#9;GE_ERR_LOAD_BITMAP_FAILED,</P>
<P>&#9;GE_ERR_MAX_MESH_DEFS,</P>
<P>&#9;GE_ERR_MESH_MAX_NODES,</P>
<P>&#9;GE_ERR_INVALID_MESH_MATERIAL,</P>
<P>&#9;GE_ERR_MAX_MESH_MATERIALS,</P>
<P>&#9;GE_ERR_MAX_MESH_CLIP_PLANES,</P>
<P>&#9;GE_ERR_RENDERQ_OVERFLOW,</P>
<P>&#9;GE_ERR_INVALID_LTYPE,</P>
<P>&#9;GE_ERR_MAX_ENTITIES,</P>
<P>&#9;GE_ERR_GET_ENTITY_DATA_ERROR,</P>
<P>&#9;GE_ERR_INVALID_ENTITY_FIELD_TYPE,</P>
<P>&#9;GE_ERR_MODEL_NOT_FOUND,</P>
<P>&#9;GE_ERR_MODEL_NOT_IN_ENTITY,</P>
<P>&#9;GE_ERR_MAX_TEXTURES,</P>
<P>&#9;GE_ERR_MAX_DECALS,</P>
<P>&#9;GE_ERR_MAX_VERTS,</P>
<P>&#9;GE_ERR_OUT_OF_MEMORY,</P>
<P>&#9;GE_ERR_INVALID_BSP_TAG,</P>
<P>&#9;GE_ERR_INVALID_BSP_VERSION,</P>
<P>&#9;GE_ERR_ERROR_READING_BSP_CHUNK,</P>
<P>&#9;ERR_PATH_CREATE_ENOMEM,&#9;&#9;&#9;&#9;// failure to create a path (memory allocation failed)</P>
<P>&#9;ERR_PATH_INSERT_R_KEYFRAME,&#9;&#9;&#9;// failure to insert a rotation keyframe</P>
<P>&#9;ERR_PATH_INSERT_T_KEYFRAME,&#9;&#9;&#9;// failure to insert a translation keyframe</P>
<P>&#9;ERR_PATH_DELETE_R_KEYFRAME,&#9;&#9;&#9;// failure to delete a rotation keyframe</P>
<P>&#9;ERR_PATH_DELETE_T_KEYFRAME,&#9;&#9;&#9;// failure to delete a translation keyframe</P>
<P>&#9;ERR_PATH_FILE_READ,&#9;&#9;&#9;&#9;&#9;// failure to read from file</P>
<P>&#9;ERR_PATH_FILE_VERSION,&#9;&#9;&#9;&#9;// tried to create path from file with wrong/bad version</P>
<P>&#9;ERR_PATH_FILE_PARSE,&#9;&#9;&#9;&#9;// failure to parse file (unexpected format problem)</P>
<P>&#9;ERR_PATH_FILE_WRITE,&#9;&#9;&#9;&#9;// failure to read from file</P>
<P>&#9;ERR_MOTION_CREATE_ENOMEM,&#9;&#9;&#9;// failure to create (memory allocation failed)</P>
<P>&#9;ERR_MOTION_ADDPATH_ENOMEM,&#9;&#9;&#9;// failure to add path into motion (memory allocation failed)</P>
<P>&#9;ERR_MOTION_ADDPATH_PATH,&#9;&#9;&#9;// failure to add path into motion (path creation failed)</P>
<P>&#9;ERR_MOTION_ADDPATH_BAD_NAME,&#9;&#9;// failure to add path into motion due to name conflict</P>
<P>&#9;ERR_MOTION_INSERT_EVENT,&#9;&#9;&#9;// failure to insert event (memory allocation failed or duplicate key)</P>
<P>&#9;ERR_MOTION_DELETE_EVENT,&#9;&#9;&#9;// failure to insert event</P>
<P>&#9;ERR_MOTION_FILE_READ,&#9;&#9;&#9;&#9;// failure to read from file</P>
<P>&#9;ERR_MOTION_FILE_WRITE,&#9;&#9;&#9;&#9;// failure to write to file</P>
<P>&#9;ERR_MOTION_FILE_PARSE,&#9;&#9;&#9;&#9;// failure to parse file (unexpected format problem)</P>
<P>&#9;ERR_TKARRAY_INSERT_IDENTICAL,&#9;&#9;// failure to insert into list because of existing identical key</P>
<P>&#9;ERR_TKARRAY_INSERT_ENOMEM,&#9;&#9;&#9;// failure to insert into list because of memory allocation failure</P>
<P>&#9;ERR_TKARRAY_DELETE_NOT_FOUND,&#9;&#9;// failure to delete from list because key was not found</P>
<P>&#9;ERR_TKARRAY_CREATE,&#9;&#9;&#9;&#9;&#9;// failure to create TKArray object (out of memroy)</P>
<P>&#9;ERR_TKARRAY_TOO_BIG,&#9;&#9;&#9;&#9;// TKArray object can't be added to - it's list is as big as it can get</P>
<P>&#9;ERR_VKARRAY_INSERT,&#9;&#9;&#9;&#9;&#9;// insertion to VKArray failed</P>
<P>&#9;ERR_QKARRAY_INSERT,&#9;&#9;&#9;&#9;&#9;// insertion to QKArray failed</P>
<P>&#9;ERR_POSE_CREATE_ENOMEM,&#9;&#9;&#9;&#9;// Motion object failed to create (memory allocation failed)</P>
<P>&#9;ERR_POSE_ADDJOINT_ENOMEM,&#9;&#9;&#9;// Motion_AddJoint failed to allocate/reallocate memory for new joint</P>
<P>&#9;ERR_TKEVENTS_CREATE_ENOMEM,&#9;&#9;&#9;// failure to create TKEvents object (memory allocation failed)</P>
<P>&#9;ERR_TKEVENTS_DELETE_NOT_FOUND,&#9;&#9;// failure to delete from list because key was not found</P>
<P>&#9;ERR_TKEVENTS_INSERT_ENOMEM,&#9;&#9;&#9;// failure to insert into list because of memory allocation failure</P>
<P>&#9;ERR_TKEVENTS_INSERT,&#9;&#9;&#9;&#9;// failure to insert into list </P>
<P>&#9;ERR_TKEVENTS_FILE_READ,&#9;&#9;&#9;&#9;// failure to read from data file</P>
<P>&#9;ERR_TKEVENTS_FILE_WRITE,&#9;&#9;&#9;// failure to write to data file</P>
<P>&#9;ERR_TKEVENTS_FILE_VERSION,&#9;&#9;&#9;// failure to read tkevents object: file has wrong version</P>
<P>&#9;ERR_TKEVENTS_FILE_PARSE,&#9;&#9;&#9;// failure to parse file (unexpected format problem)</P>
<P>&#9;ERR_STRBLOCK_ENOMEM,&#9;&#9;&#9;&#9;// failure to create, insert, or append (memory allocation failed)</P>
<P>&#9;ERR_STRBLOCK_STRLEN,&#9;&#9;&#9;&#9;// string too long to insert or append</P>
<P>&#9;ERR_STRBLOCK_FILE_READ,&#9;&#9;&#9;&#9;// failure to read from data file</P>
<P>&#9;ERR_STRBLOCK_FILE_WRITE,&#9;&#9;&#9;// failure to write to data file</P>
<P>&#9;ERR_STRBLOCK_FILE_PARSE,&#9;&#9;&#9;// failure to parse reading from input file (unexpected format problem)</P>
<P>&#9;ERR_BODY_ENOMEM,&#9;&#9;&#9;&#9;&#9;// failure to create, or add (memory allocation failed)</P>
<P>&#9;ERR_BODY_FILE_PARSE,&#9;&#9;&#9;&#9;// failure to parse reading from input file (unexpected format problem)</P>
<P>&#9;ERR_BODY_FILE_READ,&#9;&#9;&#9;&#9;&#9;// failure to read from data file</P>
<P>&#9;ERR_BODY_FILE_WRITE,&#9;&#9;&#9;&#9;// failure to write to data file</P>
<P>&#9;ERR_BODY_BONEXFARRAY,&#9;&#9;&#9;&#9;// XFArray object failed to return array, or array size doesn't match bone count</P>
<P>&#9;ERR_XFARRAY_ENOMEM,&#9;&#9;&#9;&#9;&#9;// failure to create. (memory allocation failure)</P>
<P>&#9;ERR_PUPPET_ENOMEM,&#9;&#9;&#9;&#9;&#9;// failure to create. (memory allocation failure)</P>
<P>&#9;ERR_PUPPET_RENDER,&#9;&#9;&#9;&#9;&#9;// failure to render. </P>
<P>&#9;ERR_PUPPET_NO_MATERIALS,&#9;&#9;&#9;// failure to create: associated body has no materials.</P>
<P>&#9;ERR_PUPPET_LOAD_TEXTURE,&#9;&#9;&#9;// failure to load texture </P>
<P>&#9;ERR_TEXPOOL_ENOMEM,&#9;&#9;&#9;&#9;&#9;// failure to create or add to. (memory allocation/reallocation failure)</P>
<P>&#9;ERR_TEXPOOL_TOO_BIG,&#9;&#9;&#9;&#9;// failure to add to pool, pool is too large.</P>
<P>&#9;ERR_TEXPOOL_LOAD_TEXTURE,&#9;&#9;&#9;// failure to load texture into pool</P>
<P>&#9;ERR_TEXPOOL_TEXTURE_NOT_FREE,&#9;&#9;// texture pool destroyed without first freeing all it's shared textures</P>
<P>&#9;ERR_ACTOR_ENOMEM,&#9;&#9;&#9;&#9;&#9;// failure to create. (memory allocation failure)</P>
<P>&#9;ERR_ACTOR_RENDER_PREP,&#9;&#9;&#9;&#9;// failure to prepare actor for rendering (bad Body or allocation failure)</P>
<P>&#9;ERR_ACTOR_RENDER_FAILED,&#9;&#9;&#9;// failure to render.  failure to get geometry from Body </P>
<P>&#9;ERR_ACTOR_TOO_MANY_MOTIONS,&#9;&#9;&#9;// failure to add motion. too many.</P>
<P>&#9;ERR_ACTOR_FILE_READ,&#9;&#9;&#9;&#9;// failure to read from data file.</P>
<P>&#9;ERR_ACTOR_FILE_PARSE,&#9;&#9;&#9;&#9;// failure to parse reading from input file(unexpected format problem)</P>
<P>&#9;ERR_ACTOR_FILE_WRITE,&#9;&#9;&#9;&#9;// failure to write to data file.</P>
<P>&#9;GE_ERR_INVALID_MODEL_MOTION_FILE,&#9;// Bad model motion file (for bsp files)</P>
<P>&#9;GE_ERR_BAD_BSP_FILE_CHUNK_SIZE,&#9;&#9;// Chunk size does not match structure size of kind</P>
<P>} geErrorLog_ErrorIDEnumType;</P>

<P>&nbsp;</P>
<P>typedef enum </P>
<P>{</P>
<P>&#9;GE_ERR_MEMORY_RESOURCE,</P>
<P>&#9;GE_ERR_DISPLAY_RESOURCE,</P>
<P>&#9;GE_ERR_SOUND_RESOURCE,</P>
<P>&#9;GE_ERR_SYSTEM_RESOURCE,</P>
<P>&#9;GE_ERR_INTERNAL_RESOURCE,</P>
<P>&#9;</P>
<P>&#9;GE_ERR_FILEIO_OPEN,</P>
<P>&#9;GE_ERR_FILEIO_CLOSE,</P>
<P>&#9;GE_ERR_FILEIO_READ,</P>
<P>&#9;GE_ERR_FILEIO_WRITE,</P>
<P>&#9;GE_ERR_FILEIO_FORMAT,</P>
<P>&#9;GE_ERR_FILEIO_VERSION,</P>
<P>&#9;</P>
<P>&#9;GE_ERR_LIST_FULL,</P>
<P>&#9;GE_ERR_DATA_FORMAT,</P>
<P>&#9;GE_ERR_SEARCH_FAILURE,</P>
<P>} geErrorLog_ErrorClassType;</P>

<P>GENESISAPI void geErrorLog_Clear(void);</P>
<P>&#9;// clears error history</P>

<P>GENESISAPI int  geErrorLog_Count(void);</P>
<P>&#9;// reports size of current error log</P>

<P>GENESISAPI void geErrorLog_AddExplicit(geErrorLog_ErrorClassType,</P>
<P>&#9;const char *ErrorIDString,</P>
<P>&#9;const char *ErrorFileString,</P>
<P>&#9;int LineNumber,</P>
<P>&#9;const char *UserString,</P>
<P>&#9;const char *Context);</P>
<P>&#9;// not intended to be used directly: use ErrorLog_Add or ErrorLog_AddString</P>

<P>&nbsp;</P>
<P>#ifdef ERRORLOG_FULL_REPORTING</P>
<P>&#9;// 'Debug' version includes a textual error id, and the user string</P>

<P>&#9;#define geErrorLog_Add(Error, Context) geErrorLog_AddExplicit(Error, #Error, __FILE__, __LINE__,"", Context)</P>
<P>&#9;&#9;// logs an error.  </P>

<P>&#9;#define geErrorLog_AddString(Error,String, Context) geErrorLog_AddExplicit(Error, #Error, __FILE__,__LINE__, String, Context)</P>
<P>&#9;&#9;// logs an error with additional identifing string.  </P>
<P>&#9;</P>
<P>GENESISAPI&#9;geBoolean geErrorLog_AppendStringToLastError(const char *String);// use geErrorLog_AppendString</P>

<P>&#9;#define geErrorLog_AppendString(XXX) geErrorLog_AppendStringToLastError(XXX)</P>
<P>&#9;&#9;// adds text to the previous logged error</P>

<P>#else</P>
<P>&#9;// 'Release' version does not include the textual error id, or the user string</P>

<P>&#9;#define geErrorLog_Add(Error, Context) geErrorLog_AddExplicit(Error, "", __FILE__, __LINE__,"", Context)</P>
<P>&#9;&#9;// logs an error.  </P>

<P>&#9;#define geErrorLog_AddString(Error,String, Context) geErrorLog_AddExplicit(Error, "", __FILE__,__LINE__, "", Context)</P>
<P>&#9;&#9;// logs an error with additional identifing string.  </P>
<P>&#9;</P>
<P>&#9;#define geErrorLog_AppendString(XXX)</P>
<P>&#9;&#9;// adds text to the previous logged error</P>

<P>#endif</P>

<P>GENESISAPI geBoolean geErrorLog_Report(int History, geErrorLog_ErrorClassType *Error, const char **UserString);</P>
<P>&#9;// reports from the error log.  </P>
<P>&#9;// history is 0 for most recent,  1.. for second most recent etc.</P>
<P>&#9;// returns GE_TRUE if report succeeded.  GE_FALSE if it failed.</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558905"><A NAME="_Toc454069922">ExtBox.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  EXTBOX.H                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:                                                                             */</P>
<P>/*  Description: Axial aligned bounding box (extent box) support                        */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_EXTBOX_H</P>
<P>#define GE_EXTBOX_H</P>

<P>#include "basetype.h"</P>
<P>#include "vec3d.h"</P>

<P>#ifdef __cplusplus</P>
<P>&#9;extern "C" {</P>
<P>#endif</P>

<P>typedef struct geExtBox</P>
<P>{</P>
<P>&#9;geVec3d Min;</P>
<P>&#9;geVec3d Max;</P>
<P>} geExtBox;</P>

<P>// Set the values in a box</P>
<P>void GENESISCC geExtBox_Set (  geExtBox *B,</P>
<P>&#9;&#9;&#9;&#9;  geFloat X1,&#9;  geFloat Y1,&#9;  geFloat Z1,</P>
<P>&#9;&#9;&#9;&#9;  geFloat X2,&#9;  geFloat Y2,&#9;  geFloat Z2 );</P>

<P>// Test a box for validity ( non NULL and max &gt;= min )</P>
<P>geBoolean GENESISCC geExtBox_IsValid(  const geExtBox *B );</P>

<P>// Set box Min and Max to the passed point</P>
<P>void GENESISCC geExtBox_SetToPoint ( geExtBox *B, const geVec3d *Point );</P>

<P>// Extend a box to encompass the passed point</P>
<P>void GENESISCC geExtBox_ExtendToEnclose( geExtBox *B, const geVec3d *Point );</P>

<P>// Return result of box intersection.</P>
<P>// If no intersection, returns GE_FALSE and bResult is not modified.</P>
<P>// If intersection, returns GE_TRUE and fills bResult (if not NULL)</P>
<P>// with the intersected box,</P>
<P>// bResult may be one of b1 or b2.</P>
<P>// </P>
<P>geBoolean GENESISCC geExtBox_Intersection ( const geExtBox *B1, const geExtBox *B2, geExtBox *Result&#9;);</P>

<P>// computes union of b1 and b2 and returns in bResult.</P>
<P>void GENESISCC geExtBox_Union ( const geExtBox *B1, const geExtBox *B2, geExtBox *Result );</P>

<P>geBoolean GENESISCC geExtBox_ContainsPoint ( const geExtBox *B, const geVec3d  *Point );</P>

<P>void GENESISCC geExtBox_GetTranslation ( const geExtBox *B,       geVec3d *pCenter );</P>
<P>void GENESISCC geExtBox_SetTranslation (       geExtBox *B, const geVec3d *pCenter );</P>
<P>void GENESISCC geExtBox_Translate      (       geExtBox *B, geFloat DX, geFloat DY, geFloat DZ );</P>

<P>void GENESISCC geExtBox_GetScaling     ( const geExtBox *B,       geVec3d *pScale );</P>
<P>void GENESISCC geExtBox_SetScaling     (       geExtBox *B, const geVec3d *pScale );</P>
<P>void GENESISCC geExtBox_Scale          (       geExtBox *B, geFloat DX, geFloat DY,geFloat DZ );</P>

<P>//  Creates a box that encloses the entire area of a box that moves along linear path</P>
<P>void GENESISCC geExtBox_LinearSweep(&#9;const geExtBox *BoxToSweep, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *StartPoint, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *EndPoint, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;geExtBox *EnclosingBox );</P>

<P>// Collides a ray with box B.  The ray is directed, from Start to End.  </P>
<P>//   Only returns a ray hitting the outside of the box.  </P>
<P>//     on success, GE_TRUE is returned, and </P>
<P>//       if T is non-NULL, T is returned as 0..1 where 0 is a collision at Start, and 1 is a collision at End</P>
<P>//       if Normal is non-NULL, Normal is the surface normal of the box where the collision occured.</P>
<P>geBoolean GENESISCC geExtBox_RayCollision( const geExtBox *B, const geVec3d *Start, const geVec3d *End, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *T, geVec3d *Normal );</P>

<P>#ifdef __cplusplus</P>
<P>&#9;}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558906"><A NAME="_Toc454069923">Font.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  FONT.H                                                                              */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Thom Robertson                                                              */</P>
<P>/*  Description: Bitmapped font support interface                                       */</P>
<P>/*               This implementation supports any TrueType fonts provided by Windows    */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_FONT_H</P>
<P>#define GE_FONT_H</P>

<P>// includes</P>
<P>#include "genesis.h"</P>
<P>#include "basetype.h"</P>
<P>#include "bitmap.h"</P>
<P>// **************************</P>
<P>// to use this API:</P>

<P>// 2.  geFont_CreateFont().</P>

<P>// 3.  (Optionally) geFont_AddCharacters().</P>
<P>// 3A. Otherwise, IF you intend to use geFont_DrawText(), call geFont_AddBitmapBuffer().</P>

<P>// 4.  Between geEngine_BeginFrame() and geEngine_EndFrame(), and after geEngine_RenderWorld(),</P>
<P>//       geFont_DrawText(). You may call geFont_DrawTextToBitmap() anytime, though.</P>

<P>// 5.  When finished, geFont_Destroy().</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>//*************************************************************************************** </P>
<P>// these are bit flags for _DrawText(). Currently only _WORDWRAP is implemented, and without</P>
<P>// it, the function will still wrap, just not on word boundaries.</P>
<P>// Note that these will fail for non ascii fonts.</P>
<P>#define GE_FONT_WRAP                0x00000001  // wrap to fit inside the drawing rect</P>
<P>#define GE_FONT_WORDWRAP            0x00000002  // wrap on word boundaries</P>
<P>#define GE_FONT_JUST_RETURN_FIT     0x00000004  // returns number of characters that fit in drawing rectangle, WITHOUT drawing anything.</P>
<P>#define GE_FONT_JUSTIFY_RIGHT       0x00000008</P>
<P>#define GE_FONT_JUSTIFY_CENTER      0x00000010</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>// opaque structure headers.</P>
<P>typedef struct geFont geFont;&#9;&#9;&#9;// an instance of a font</P>

<P>&nbsp;</P>
<P>//*************************************************************************************** </P>
<P>GENESISAPI geFont *GENESISCC geFont_Create(const geEngine *Engine, const char *fontNameString, </P>
<P>                                               const int fontSize,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   const int fontWeight , const geBoolean antialiased) ;</P>
<P>   // Creates a font, and returns a pointer to it.</P>
<P>   // Pass in the string name of the TrueType font (case sensitive), and the height in pixels.</P>
<P>   </P>
<P>   // ARGUMENTS:</P>
<P>   // fontNameString - char pointer to a string containing the case sensitive name of the font.</P>
<P>   // fontSize - the pixel height of the requested font.</P>

<P>   // RETURNS:</P>
<P>   // success: pointer to the newly created font.</P>
<P>   // failure: NULL.</P>

<P>   // NOTE: the new font set has NO actual characters in it at first.  You must add characters</P>
<P>   // to it with the _AddCharacters() function before you can use the font.</P>
<P>   // NOTE: all fonts start out with a grayscale palette, with the range 0 to 128.</P>

<P>//*************************************************************************************** </P>
<P>GENESISAPI void GENESISCC geFont_CreateRef(geFont *font);</P>

<P>&nbsp;</P>
<P>//*************************************************************************************** </P>
<P>GENESISAPI void GENESISCC geFont_Destroy(geFont **font);</P>
<P>   // destroys a font.</P>

<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the font to be destroyed.</P>

<P>   // RETURNS:</P>
<P>   // nothing.</P>

<P>//*************************************************************************************** </P>
<P>GENESISAPI geBoolean GENESISCC geFont_AddCharacters(geFont *font, </P>
<P>                                                  unsigned char leastIndex, </P>
<P>                                                  unsigned char mostIndex</P>
<P>                                                  );</P>
<P>   // Adds a set of characters to the font defined by the ascii range passed in </P>
<P>   // (leastIndex and mostIndex, inclusive).</P>

<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the font to add characters to.</P>
<P>   // e - pointer to a valid geEngine.</P>
<P>   // leastIndex and mostIndex - the ASCII range of characters to add.</P>
<P>   // cellBuffer - an allocated hunk of ram to temproarily store the character image</P>
<P>   // bufferSize - length of the above buffer</P>

<P>   // RETURNS:</P>
<P>   // success: GE_TRUE.</P>
<P>   // failure: GE_FALSE.</P>

<P>   // NOTES:</P>
<P>   // This is the function that actually uses the</P>
<P>   // Win32 GetGlyphOutline() function to draw the character onto a geBitmap, which can be</P>
<P>   // blitted to the screen.</P>

<P>&nbsp;</P>
<P>//*******************************************************************************</P>
<P>GENESISAPI void GENESISCC geFont_DestroyBitmapBuffer( geFont *font );</P>
<P>   // destroys any valid "scratch-pad" buffer attached to the geFont.</P>
<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the geFont.</P>
<P>   //</P>
<P>   // NOTES:</P>
<P>   // you'll rarely need to call this function; it's called by geFont_Destroy() anyway.</P>
<P>   // Calling this function with a geFont that has no initialized buffer doesn't</P>
<P>   // hurt anything.</P>

<P>//*******************************************************************************</P>
<P>GENESISAPI geBoolean GENESISCC geFont_AddBitmapBuffer(</P>
<P>                                  geFont *font, const uint32 width, const uint32 height);</P>
<P>   // Adds a geBitmap to the geFont, to be used as a temporary "scratch-pad".  This is</P>
<P>   // required for using geFont_DrawText() when no characters have been added.</P>

<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the geFont to add a buffer to.</P>
<P>   // width and height - the size of the buffer to create.  Make sure this size is &gt;=</P>
<P>   // the biggest rectagle of text you'll want to write to the screen using this geFont</P>
<P>   // and DrawText().</P>

<P>   // RETURNS:</P>
<P>   // success: GE_TRUE.</P>
<P>   // failure: GE_FALSE.</P>

<P>   // NOTES:</P>
<P>   // You don't need to call this function IF you _AddCharacters() to this geFont.</P>
<P>   // You call this function for each geFont you need to use.  geFont's don't share buffers.</P>
<P>   // if you call this function on a geFont that already has a valid buffer, the buffer is</P>
<P>   // destroyed, and replaced by the new one.</P>

<P>//*************************************************************************************** </P>
<P>GENESISAPI geBoolean GENESISCC geFont_DrawText(geFont *font, const char *textString, </P>
<P>                                           const GE_Rect *Rect, const GE_RGBA *Color, </P>
<P>                                           uint32 flags, const GE_Rect *clipRect);</P>
<P>   // This is the function you put between geEngine_BeginFrame() and _EndFrame(), the function</P>
<P>   // that draws text to the screen.</P>

<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the font to draw with.  IF the font has NO characters in it</P>
<P>   //  (added by geFont_AddCharacters() ) then a different, more windows-intensive way is</P>
<P>   //  used to draw out the characters.</P>
<P>   // textString - pointer to the text string to output to the screen.</P>
<P>   // Rect - screen rectangle to place the text within.</P>
<P>   // Color - RGB color the text should be.</P>
<P>   // flags - a bitfield of GE_FONT_ values.</P>
<P>   // clipRect - pointer to a screen rectangle to clip the text to.  MAY BE NULL, in which</P>
<P>   // case the text is only clipped by the boundaries of the screen.</P>

<P>   // RETURNS:</P>
<P>   // success: GE_TRUE.</P>
<P>   // failure: GE_FALSE.</P>

<P>   // NOTES:</P>
<P>   // Assuming you've added characters to the font, characters which have NOT been added</P>
<P>   // WILL cause an assert if you try to draw them.  </P>
<P>   // Only GE_FONTSET_WORDWRAP is meaningfull right now.  Using any other flags will cause</P>
<P>   // an assert.</P>
<P>   // As stated above, you can use an entirely different way of creating a string, by</P>
<P>   // making a font with no characters in it.  This</P>
<P>   // jumps through Windows DIB hoops, and draws the text in a non-anti-aliased, but</P>
<P>   // (hopefully) more unicode-tolerant way (DrawText() ).</P>

<P>&nbsp;</P>
<P>//*************************************************************************************** </P>
<P>GENESISAPI geBoolean GENESISCC geFont_DrawTextToBitmap(geFont *font, const char *textString, </P>
<P>                                           const GE_Rect *Rect, const GE_RGBA *Color, </P>
<P>                                           uint32 flags, const GE_Rect *clipRect,</P>
<P>                                           geBitmap *targetBitmap);</P>
<P>   // This is the function you put between geEngine_BeginFrame() and _EndFrame(), the function</P>
<P>   // that draws text to the screen.</P>

<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the font to draw with.  IF the font has NO characters in it</P>
<P>   //  (added by geFont_AddCharacters() ) then a different, more windows-intensive way is</P>
<P>   //  used to draw out the characters.</P>
<P>   // textString - pointer to the text string to output to the screen.</P>
<P>   // Rect - screen rectangle to place the text within.</P>
<P>   // Color - RGB color the text should be.</P>
<P>   // flags - a bitfield of GE_FONT_ values.</P>
<P>   // clipRect - pointer to a screen rectangle to clip the text to.  MAY BE NULL, in which</P>
<P>   // case the text is only clipped by the boundaries of the screen.</P>
<P>   // targetBitmap - pointer to a target bitmap to draw the text into.  MAY NOT BE NULL,</P>
<P>   // and MUST BE GE_PIXELFORMAT_8BIT.</P>

<P>   // RETURNS:</P>
<P>   // success: GE_TRUE.</P>
<P>   // failure: GE_FALSE.</P>

<P>   // NOTES:</P>
<P>   // Assuming you've added characters to the font, characters which have NOT been added</P>
<P>   // WILL cause an assert if you try to draw them.  </P>
<P>   // Only GE_FONTSET_WORDWRAP is meaningfull right now.  Using any other flags will cause</P>
<P>   // an assert.</P>
<P>   // As stated above, you can use an entirely different way of creating a string, by</P>
<P>   // making a font with no characters in it.  This</P>
<P>   // jumps through Windows DIB hoops, and draws the text in a non-anti-aliased, but</P>
<P>   // (hopefully) more unicode-tolerant way (DrawText() ).</P>
<P>   // The Color argument is will be used to modify the existing palette of the targetBitmap</P>
<P>   // passed in.  Therefore, you won't be able to _DrawTextToBitmap() a red piece of text,</P>
<P>   // then a green piece, then a blue piece.  You'll end up with three lines of blue text.</P>

<P>&nbsp;</P>
<P>//*************************************************************************************** </P>
<P>GENESISAPI int32 GENESISCC geFont_GetStringPixelWidth (geFont *font, const char *textString);</P>
<P>GENESISAPI int32 GENESISCC geFont_GetStringPixelHeight(geFont *font, const char *textString);</P>
<P>   // These two functions return the pixel width and height of the string passed in.</P>

<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the font to draw with.</P>
<P>   // textString - pointer to the text string to output to the screen.</P>

<P>   // RETURNS:</P>
<P>   // success: a positive value in pixels.  IF the text passed in contains characters</P>
<P>   //          which haven't been added to the font yet, BUT other characters HAVE</P>
<P>   //          been added, the function asserts.</P>
<P>   // failure: -1.</P>
<P>   // NOTES:</P>
<P>   // these two functions assume no text wrapping!</P>

<P>//*************************************************************************************** </P>
<P>GENESISAPI geBitmap* GENESISCC geFont_GetBuffer(geFont *font);</P>
<P>   // This function returns a pointer to the drawing buffer contained by the font.</P>

<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the font.</P>

<P>   // RETURNS:</P>
<P>   // a valid pointer to a geBitmap, OR NULL, signifying that the buffer wasn't initialized.</P>

<P>&nbsp;</P>
<P>//*************************************************************************************** </P>
<P>GENESISAPI geBoolean GENESISCC geFont_GetCharMap(geFont *font, uint8 character, GE_Rect *Rect, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; geBitmap **targetBitmap, int32 *fullWidth, int32 *fullHeight, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; int32 *offsetX, int32 *offsetY);</P>

<P>//*************************************************************************************** </P>
<P>GENESISAPI void GENESISCC geFont_EnableAntialiasing(geFont *font, const geBoolean anti);</P>
<P>//*************************************************************************************** </P>
<P>GENESISAPI geBoolean GENESISCC geFont_IsAntialiased(geFont *font);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558907"><A NAME="_Toc454069924">Genesis.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Genesis.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Description: The master header for Genesis                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GENESIS_H</P>
<P>#define GENESIS_H</P>

<P>#include "BaseType.h"</P>
<P>#include "Vec3d.h"</P>
<P>#include "XForm3d.h"</P>
<P>#include "GETypes.h"</P>
<P>#include "ExtBox.h"</P>
<P>#include "vfile.h"</P>
<P>#include "Bitmap.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//================================================================================</P>
<P>//&#9;Constants / Defines / TypDefs</P>
<P>//================================================================================</P>

<P>typedef struct&#9;&#9;geEngine&#9;&#9;&#9;geEngine;</P>

<P>typedef struct&#9;&#9;geDriver_System&#9;&#9;geDriver_System;</P>
<P>typedef struct&#9;&#9;geDriver&#9;&#9;&#9;geDriver;</P>
<P>typedef struct&#9;&#9;geDriver_Mode&#9;&#9;geDriver_Mode;</P>

<P>typedef struct&#9;&#9;geSound_System&#9;&#9;geSound_System;</P>
<P>typedef struct&#9;&#9;geSound_Cfg&#9;&#9;&#9;geSound_Cfg;</P>
<P>typedef struct&#9;&#9;geSound_Def&#9;&#9;&#9;geSound_Def;</P>
<P>typedef struct&#9;&#9;geSound&#9;&#9;&#9;&#9;geSound;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>typedef struct&#9;&#9;geActor&#9;&#9;&#9;&#9;geActor;</P>
<P>typedef struct&#9;&#9;geActor_Def&#9;&#9;&#9;geActor_Def;&#9;&#9;// the definition of an actor's geometry/bone structure</P>

<P>typedef struct&#9;&#9;geWorld&#9;&#9;&#9;&#9;geWorld;</P>

<P>typedef struct&#9;&#9;geWorld_Model&#9;&#9;geWorld_Model;</P>

<P>typedef struct&#9;&#9;geEntity&#9;&#9;&#9;geEntity;</P>
<P>typedef struct&#9;&#9;geEntity_EntitySet&#9;geEntity_EntitySet;</P>

<P>typedef struct&#9;&#9;geCamera&#9;&#9;&#9;geCamera;</P>

<P>typedef struct&#9;&#9;geCSNetMgr&#9;&#9;&#9;geCSNetMgr;</P>

<P>typedef struct&#9;&#9;gePoly&#9;&#9;&#9;&#9;gePoly;</P>

<P>typedef struct&#9;&#9;geLight&#9;&#9;&#9;&#9;geLight;&#9;&#9;&#9;</P>

<P>typedef struct&#9;&#9;geFog&#9;&#9;&#9;&#9;geFog;</P>

<P>typedef struct&#9;&#9;geMesh_Def&#9;&#9;&#9;geMesh_Def;&#9;&#9;&#9;// Mesh def</P>
<P>typedef struct&#9;&#9;geMesh&#9;&#9;&#9;&#9;geMesh;&#9;&#9;&#9;&#9;</P>

<P>#define GE_VERSION_MAJOR&#9;&#9;(1UL)</P>
<P>#define GE_VERSION_MINOR&#9;&#9;(3UL)</P>
<P>#define GE_VERSION_MINOR_MIN&#9;(3UL)</P>

<P>#define GE_VERSION_MAJOR_SHIFT&#9;(16)</P>
<P>#define GE_VERSION_MAJOR_MASK&#9;((uint32)0xFFFF0000)</P>

<P>#define GE_VERSION&#9;&#9;&#9;&#9;( (GE_VERSION_MAJOR &lt;&lt; GE_VERSION_MAJOR_SHIFT) + GE_VERSION_MINOR )</P>

<P>// From here down, still needs to be fixed up for July4</P>
<P>typedef&#9;struct&#9;&#9;GE_ModelMotion&#9;&#9;GE_ModelMotion;</P>
<P>typedef float&#9;&#9;GE_TimeType;</P>

<P>// Polys</P>
<P>typedef enum</P>
<P>{</P>
<P>&#9;GE_TEXTURED_POLY,</P>
<P>&#9;GE_GOURAUD_POLY,</P>
<P>&#9;GE_TEXTURED_POINT&#9;&#9;&#9;&#9;&#9;</P>
<P>} gePoly_Type;</P>

<P>// Poly Fx flags</P>
<P>#define&#9;GE_RENDER_DO_NOT_OCCLUDE_OTHERS&#9;(1&lt;&lt;0)&#9;&#9;&#9;// Poly will not occlude others</P>
<P>#define GE_RENDER_DO_NOT_OCCLUDE_SELF&#9;(1&lt;&lt;1)&#9;&#9;&#9;// Renders under any condition.  Useful for halos, etc...</P>
<P>#define&#9;GE_RENDER_BACKFACED&#9;&#9;&#9;&#9;(1&lt;&lt;2)&#9;&#9;&#9;// Poly should be backfaced from the Camera's Pov</P>
<P>#define GE_RENDER_DEPTH_SORT_BF&#9;&#9;&#9;(1&lt;&lt;3)&#9;&#9;&#9;// Sorts relative to camera position, from back to front</P>
<P>#define GE_RENDER_CLAMP_UV&#9;&#9;&#9;&#9;(1&lt;&lt;4)&#9;&#9;&#9;// Clamp UV's in both directions</P>

<P>// World Add flags</P>
<P>#define GE_WORLD_RENDER&#9;&#9;&#9;&#9;(1&lt;&lt;0)</P>
<P>#define GE_WORLD_COLLIDE&#9;&#9;&#9;(1&lt;&lt;1)</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#ifndef GE_CONTENTS_TYPES</P>
<P>#define GE_CONTENTS_TYPES</P>

<P>//</P>
<P>// Content types in GE_Contents structure (multiple contents can be mixed...)</P>
<P>//</P>
<P>//*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=</P>
<P>//&#9;IF THESE FLAGS CHANGE, THEY MUST CHANGE IN GBSPFILE.H in Genesis AND GBSPLIB, and Genesis.H!!!!!</P>
<P>//*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=</P>
<P>#define GE_CONTENTS_SOLID&#9;&#9;&#9;(1&lt;&lt;0)&#9;&#9;// Solid (Visible)</P>
<P>#define GE_CONTENTS_WINDOW&#9;&#9;&#9;(1&lt;&lt;1)&#9;&#9;// Window (Visible)</P>
<P>#define GE_CONTENTS_EMPTY&#9;&#9;&#9;(1&lt;&lt;2)&#9;&#9;// Empty but Visible (water, lava, etc...)</P>

<P>#define GE_CONTENTS_TRANSLUCENT&#9;&#9;(1&lt;&lt;3)&#9;&#9;// Vis will see through it</P>
<P>#define GE_CONTENTS_WAVY&#9;&#9;&#9;(1&lt;&lt;4)&#9;&#9;// Wavy (Visible)</P>
<P>#define GE_CONTENTS_DETAIL&#9;&#9;&#9;(1&lt;&lt;5)&#9;&#9;// Won't be included in vis oclusion</P>

<P>#define GE_CONTENTS_CLIP&#9;&#9;&#9;(1&lt;&lt;6)&#9;&#9;// Structural but not visible</P>
<P>#define GE_CONTENTS_HINT&#9;&#9;&#9;(1&lt;&lt;7)&#9;&#9;// Primary splitter (Non-Visible)</P>
<P>#define GE_CONTENTS_AREA&#9;&#9;&#9;(1&lt;&lt;8)&#9;&#9;// Area seperator leaf (Non-Visible)</P>

<P>#define GE_CONTENTS_FLOCKING&#9;&#9;(1&lt;&lt;9)</P>
<P>#define GE_CONTENTS_SHEET&#9;&#9;&#9;(1&lt;&lt;10)</P>
<P>#define GE_CONTENTS_AIR&#9;&#9;&#9;&#9;(1&lt;&lt;11)&#9;&#9;// No brush lives in this leaf</P>
<P>#define GE_RESERVED4&#9;&#9;&#9;&#9;(1&lt;&lt;12)</P>
<P>#define GE_RESERVED5&#9;&#9;&#9;&#9;(1&lt;&lt;13)</P>
<P>#define GE_RESERVED6&#9;&#9;&#9;&#9;(1&lt;&lt;14)</P>
<P>#define GE_RESERVED7&#9;&#9;&#9;&#9;(1&lt;&lt;15)</P>

<P>// 16-31 reserved for user contents</P>
<P>#define GE_CONTENTS_USER1&#9;&#9;&#9;(1&lt;&lt;16)</P>
<P>#define GE_CONTENTS_USER2&#9;&#9;&#9;(1&lt;&lt;17)</P>
<P>#define GE_CONTENTS_USER3&#9;&#9;&#9;(1&lt;&lt;18)</P>
<P>#define GE_CONTENTS_USER4&#9;&#9;&#9;(1&lt;&lt;19)</P>
<P>#define GE_CONTENTS_USER5&#9;&#9;&#9;(1&lt;&lt;20)</P>
<P>#define GE_CONTENTS_USER6&#9;&#9;&#9;(1&lt;&lt;21)</P>
<P>#define GE_CONTENTS_USER7&#9;&#9;&#9;(1&lt;&lt;22)</P>
<P>#define GE_CONTENTS_USER8&#9;&#9;&#9;(1&lt;&lt;23)</P>
<P>#define GE_CONTENTS_USER9&#9;&#9;&#9;(1&lt;&lt;24)</P>
<P>#define GE_CONTENTS_USER10&#9;&#9;&#9;(1&lt;&lt;25)</P>
<P>#define GE_CONTENTS_USER11&#9;&#9;&#9;(1&lt;&lt;26)</P>
<P>#define GE_CONTENTS_USER12&#9;&#9;&#9;(1&lt;&lt;27)</P>
<P>#define GE_CONTENTS_USER13&#9;&#9;&#9;(1&lt;&lt;28)</P>
<P>#define GE_CONTENTS_USER14&#9;&#9;&#9;(1&lt;&lt;29)</P>
<P>#define GE_CONTENTS_USER15&#9;&#9;&#9;(1&lt;&lt;30)</P>
<P>#define GE_CONTENTS_USER16&#9;&#9;&#9;(1&lt;&lt;31)</P>
<P>// 16-31 reserved for user contents</P>

<P>&nbsp;</P>
<P>// These contents are all solid types</P>
<P>#define GE_CONTENTS_SOLID_CLIP&#9;&#9;(GE_CONTENTS_SOLID | GE_CONTENTS_WINDOW | GE_CONTENTS_CLIP)</P>
<P>#define GE_CONTENTS_CANNOT_OCCUPY&#9;GE_CONTENTS_SOLID_CLIP</P>

<P>// These contents are all visible types</P>
<P>#define GE_VISIBLE_CONTENTS&#9;&#9;&#9;(&#9;GE_CONTENTS_SOLID | \</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_CONTENTS_EMPTY | \</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_CONTENTS_WINDOW | \</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_CONTENTS_WAVY)</P>

<P>#endif</P>
<P>//*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=</P>
<P>//*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=</P>

<P>// NOTES - Fills in first Model/Mesh hit</P>
<P>// Exceptions:</P>
<P>//&#9;&#9;Returns the last solid model hit...</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;geMesh&#9;&#9;&#9;*Mesh;</P>
<P>&#9;geWorld_Model&#9;*Model;</P>
<P>&#9;geActor&#9;&#9;&#9;*Actor;</P>
<P>&#9;int32&#9;&#9;&#9;Contents;</P>
<P>} GE_Contents;</P>

<P>typedef geBoolean GE_CollisionCB(geWorld_Model *Model, geActor *Actor, void *Context);</P>

<P>// Collision</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;geVec3d&#9;Normal;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Orientation of plane</P>
<P>&#9;float&#9;Dist;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Distance from origin</P>
<P>} GE_Plane;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;geWorld_Model&#9;*Model;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Pointer to what model was hit (if any)</P>
<P>&#9;geMesh&#9;&#9;&#9;*Mesh;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Pointer to what mesh was hit (if any)</P>
<P>&#9;geActor&#9;&#9;&#9;*Actor;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Pointer to what actor was hit (if any)&#9;</P>
<P>&#9;geVec3d&#9;&#9;&#9;Impact;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Impact Point</P>
<P>&#9;float&#9;&#9;&#9;Ratio;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Percent from 0 to 1.0, how far along the line for the impact point</P>
<P>&#9;GE_Plane&#9;&#9;Plane;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Impact Plane</P>
<P>} GE_Collision;</P>

<P>// If these render states change, they must change in DCommon.h too!!!</P>
<P>// These are still under construction, and are for debug purposes only.</P>
<P>// They are merely means of overriding ways the engine normally renders primitives, etc...</P>
<P>//</P>
<P>//&#9;RenderState States</P>
<P>//</P>
<P>#define GE_RENDERSTATE_ZWRITE&#9;&#9;0&#9;&#9;// Z Writes</P>
<P>#define GE_RENDERSTATE_ZCMP&#9;&#9;&#9;1&#9;&#9;// Z Compares</P>
<P>#define GE_RENDERSTATE_BILINEAR&#9;&#9;2&#9;&#9;// Bilinear filtering</P>
<P>#define&#9;GE_RENDERSTATE_ANTI_ALIAS&#9;3&#9;&#9;// Anti-Aliasing</P>
<P>#define GE_RENDERSTATE_POLYMODE&#9;&#9;4&#9;&#9;// Normal, Gouraud only, Lines only, etc</P>

<P>//</P>
<P>//&#9;RenderState Flags</P>
<P>//</P>
<P>#define GE_RENDERFLAG_OFF&#9;&#9;0</P>
<P>#define GE_RENDERFLAG_ON&#9;&#9;1</P>

<P>//</P>
<P>//  PolyMode flags&#9;(A method to override how polys are drawn for debugging purposes...)</P>
<P>//</P>
<P>#define GE_POLYMODE_NORMAL&#9;&#9;1&#9;&#9;&#9;// Draw as is</P>
<P>#define GE_POLYMODE_GOURAUD&#9;&#9;2&#9;&#9;&#9;// Gouraud only</P>
<P>#define GE_POLYMODE_LINES&#9;&#9;3&#9;&#9;&#9;// Outlines only</P>

<P>//================================================================================</P>
<P>//&#9;Engine Management functions</P>
<P>//================================================================================</P>

<P>&nbsp;</P>
<P>#ifdef _INC_WINDOWS&#9;</P>
<P>&#9;// Windows.h must be included before genesis.h for this api to be exposed.</P>
<P>&#9;</P>

<P>GENESISAPI&#9;geEngine&#9;*geEngine_CreateWithVersion(HWND hWnd, const char *AppName, const char *DriverDirectory, uint32 Version);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;// use geEngine_Create, rather than calling this directly.</P>

<P>#define geEngine_Create( hWnd, AppName, DriverDirectory)   geEngine_CreateWithVersion(hWnd,AppName,DriverDirectory,GE_VERSION)</P>

<P>#endif</P>

<P>GENESISAPI void&#9;&#9;&#9;geEngine_Free(geEngine *Engine);</P>

<P>GENESISAPI geBoolean&#9;geEngine_AddWorld(geEngine *Engine, geWorld *World);</P>
<P>GENESISAPI geBoolean&#9;geEngine_RemoveWorld(geEngine *Engine, geWorld *World);</P>

<P>GENESISAPI geBoolean&#9;geEngine_AddBitmap(geEngine *Engine, geBitmap *Bitmap);</P>
<P>GENESISAPI geBoolean&#9;geEngine_RemoveBitmap(geEngine *Engine, geBitmap *Bitmap);</P>

<P>GENESISAPI geDriver_System *geEngine_GetDriverSystem(geEngine *Engine);</P>

<P>GENESISAPI geBoolean&#9;geEngine_SetDriverAndMode(&#9;geEngine *Engine, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geDriver *Driver, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geDriver_Mode *DriverMode);</P>

<P>GENESISAPI geBoolean&#9;geEngine_ShutdownDriver(geEngine *Engine);</P>

<P>GENESISAPI geBoolean&#9;geEngine_BeginFrame(geEngine *Engine, geCamera *Camera, geBoolean ClearScreen);</P>
<P>GENESISAPI geBoolean&#9;geEngine_EndFrame(geEngine *Engine);</P>

<P>GENESISAPI geBoolean&#9;geEngine_RenderWorld(geEngine *Engine, geWorld *World, geCamera *Camera, geFloat Time);</P>
<P>GENESISAPI geBoolean&#9;geEngine_Printf(geEngine *Engine, int32 x, int32 y, const char *String, ...);</P>

<P>GENESISAPI void&#9;&#9;&#9;GENESISCC geEngine_RenderPoly(const geEngine *Engine, const GE_TLVertex *Points, int NumPoints, const geBitmap *Texture, uint32 Flags);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;//RenderPoly : if Texture is null, we Gouraud shade</P>

<P>GENESISAPI void&#9;&#9;&#9;GENESISCC geEngine_RenderPolyArray(const geEngine *Engine, const GE_TLVertex ** pPoints, int * pNumPoints, int NumPolys, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geBitmap *Texture, uint32 Flags);</P>

<P>GENESISAPI geBoolean&#9;GENESISCC geEngine_DrawBitmap(const geEngine *Engine,const geBitmap *Bitmap,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geRect * Source, uint32 x, uint32 y);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;//DrawBitmap &amp; RenderPoly : must Engine_AddBitmap first!</P>

<P>&nbsp;</P>
<P>GENESISAPI void&#9;&#9;&#9;geEngine_FillRect(geEngine *Engine, const GE_Rect *Rect, const GE_RGBA *Color);</P>

<P>GENESISAPI geBoolean&#9;geEngine_SetGamma(geEngine *Engine, float Gamma);</P>
<P>GENESISAPI geBoolean&#9;geEngine_GetGamma(geEngine *Engine, float *Gamma);</P>

<P>GENESISAPI geBoolean&#9;geEngine_ScreenShot(geEngine *Engine, const char *FileName);</P>

<P>GENESISAPI void&#9;&#9;&#9;geEngine_EnableFrameRateCounter(geEngine *Engine, geBoolean Enabled);</P>

<P>GENESISAPI geBoolean&#9;geEngine_Activate(geEngine *Engine, geBoolean bActive);</P>

<P>#ifdef _INC_WINDOWS</P>
<P>&#9;// Windows.h must be included before genesis.h for this api to be exposed.</P>
<P>GENESISAPI geBoolean&#9;geEngine_UpdateWindow(geEngine *Engine);</P>
<P>#endif</P>

<P>// geDriver</P>
<P>GENESISAPI geDriver&#9;&#9;*geDriver_SystemGetNextDriver(geDriver_System *DriverSystem, geDriver *Start);</P>
<P>GENESISAPI geDriver_Mode *geDriver_GetNextMode(geDriver *Driver, geDriver_Mode *Start);</P>
<P>GENESISAPI geBoolean&#9;geDriver_GetName(geDriver *Driver, const char **Name);</P>
<P>GENESISAPI geBoolean&#9;geDriver_ModeGetName(geDriver_Mode *Mode, const char **Name);</P>
<P>GENESISAPI geBoolean&#9;geDriver_ModeGetWidthHeight(geDriver_Mode *Mode, int32 *Width, int32 *Height);</P>

<P>//================================================================================</P>
<P>//&#9;Sound Management functions</P>
<P>//================================================================================</P>
<P>#ifdef _INC_WINDOWS</P>
<P>&#9;// Windows.h must be included before genesis.h for this api to be exposed.</P>
<P>GENESISAPI &#9;geSound_System *geSound_CreateSoundSystem(HWND hWnd);</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>GENESISAPI void&#9;&#9;&#9;geSound_DestroySoundSystem(geSound_System *Sound);</P>

<P>&nbsp;</P>
<P>GENESISAPI geSound_Def&#9;   *geSound_LoadSoundDef(geSound_System *SoundS, geVFile *File);</P>
<P>GENESISAPI void&#9;&#9;&#9;&#9;geSound_FreeSoundDef(geSound_System *SoundS, geSound_Def *SoundDef);</P>

<P>GENESISAPI geSound&#9;&#9;   *geSound_PlaySoundDef(geSound_System *SoundS, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geSound_Def *SoundDef, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Volume, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Pan, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Frequency, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean Loop);</P>
<P>GENESISAPI geBoolean&#9;&#9;geSound_StopSound(geSound_System *SoundS, geSound *Sound);</P>
<P>GENESISAPI geBoolean&#9;&#9;geSound_ModifySound(geSound_System *SoundS, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geSound *Sound, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Volume, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Pan, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Frequency);</P>
<P>GENESISAPI geBoolean&#9;&#9;geSound_SoundIsPlaying(geSound_System *SoundS, geSound *Sound);</P>
<P>GENESISAPI geBoolean&#9;&#9;geSound_SetMasterVolume( geSound_System *SoundS, geFloat Volume );</P>

<P>GENESISAPI void geSound3D_GetConfig(</P>
<P>&#9;&#9;&#9;const geWorld *World, </P>
<P>&#9;&#9;&#9;const geXForm3d *CameraTransform, </P>
<P>&#9;&#9;&#9;const geVec3d *SoundPos, </P>
<P>&#9;&#9;&#9;geFloat Min, </P>
<P>&#9;&#9;&#9;geFloat Ds,</P>
<P>&#9;&#9;&#9;geFloat *Volume,</P>
<P>&#9;&#9;&#9;geFloat *Pan,</P>
<P>&#9;&#9;&#9;geFloat *Frequency);</P>

<P>//================================================================================</P>
<P>//  Path Support</P>
<P>//================================================================================</P>
<P>#include "Path.h"</P>
<P>//================================================================================</P>
<P>//  Motion Support</P>
<P>//================================================================================</P>
<P>#include "Motion.h"</P>
<P>//================================================================================</P>
<P>//  Actor Support</P>
<P>//================================================================================</P>
<P>#include "Actor.h"</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>//================================================================================</P>
<P>//&#9;World Management functions</P>
<P>//================================================================================</P>
<P>GENESISAPI geWorld&#9;&#9;*geWorld_Create(geVFile *File);</P>
<P>GENESISAPI void&#9;&#9;&#9;geWorld_Free(geWorld *World);</P>

<P>// World Actors</P>
<P>GENESISAPI geBoolean&#9;geWorld_RemoveActor    (geWorld *World, geActor *Actor);</P>
<P>GENESISAPI geBoolean    geWorld_AddActor       (geWorld *World, geActor *Actor, uint32 Flags, uint32 UserFlags);</P>
<P>GENESISAPI geBoolean&#9;geWorld_SetActorFlags  (geWorld *World, geActor *Actor, uint32 Flags);</P>

<P>// World Bitmaps</P>
<P>GENESISAPI geBoolean&#9;geWorld_AddBitmap(&#9;&#9;geWorld *World, geBitmap *Bitmap);</P>
<P>GENESISAPI geBoolean&#9;geWorld_RemoveBitmap(&#9;geWorld *World, geBitmap *Bitmap);</P>
<P>GENESISAPI geBoolean&#9;geWorld_HasBitmap(const geWorld *World, const geBitmap *Bitmap);</P>
<P>GENESISAPI geBitmap&#9;&#9;*geWorld_GetBitmapByName(geWorld *World, const char *BitmapName);</P>
<P>GENESISAPI geBoolean&#9;geWorld_BitmapIsVisible(geWorld *World, const geBitmap *Bitmap);</P>

<P>// World BModels</P>
<P>GENESISAPI geWorld_Model&#9;*geWorld_GetNextModel(geWorld *World, geWorld_Model *Start);</P>
<P>GENESISAPI geBoolean&#9;&#9;geWorld_SetModelXForm(geWorld *World, geWorld_Model *Model, const geXForm3d *XForm);</P>
<P>GENESISAPI geBoolean&#9;&#9;geWorld_GetModelXForm(const geWorld *World, const geWorld_Model *Model, geXForm3d *XForm);</P>
<P>GENESISAPI geBoolean&#9;&#9;geWorld_OpenModel(geWorld *World, geWorld_Model *Model, geBoolean Open);</P>
<P>GENESISAPI geBoolean&#9;&#9;geWorld_GetModelRotationalCenter(const geWorld *World, const geWorld_Model *Model, geVec3d *Center);</P>
<P>GENESISAPI geBoolean&#9;&#9;geWorld_ModelGetBBox(const geWorld *World, const geWorld_Model *Model, geVec3d *Mins, geVec3d *Maxs);</P>
<P>GENESISAPI geMotion *&#9;&#9;geWorld_ModelGetMotion(geWorld_Model *Model);</P>

<P>GENESISAPI void&#9;&#9;&#9;*geWorld_ModelGetUserData(const geWorld_Model *Model);</P>
<P>GENESISAPI void&#9;&#9;&#9;geWorld_ModelSetUserData(geWorld_Model *Model, void *UserData);</P>
<P>GENESISAPI void&#9;&#9;&#9;geWorld_ModelSetFlags(geWorld_Model *Model, uint32 ModelFlags);</P>
<P>GENESISAPI uint32&#9;&#9;geWorld_ModelGetFlags(geWorld_Model *Model);</P>

<P>// World Lights</P>
<P>GENESISAPI geLight&#9;&#9;*geWorld_AddLight(geWorld *World);</P>
<P>GENESISAPI void&#9;&#9;&#9;geWorld_RemoveLight(geWorld *World, geLight *Light);</P>
<P>GENESISAPI geBoolean&#9;geWorld_SetLightAttributes(&#9;geWorld *World,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geLight&#9;&#9;*Light, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const&#9;&#9;geVec3d *Pos, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const&#9;&#9;GE_RGBA *RGBA, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float&#9;&#9;Radius,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean&#9;CastShadow);</P>
<P>GENESISAPI geBoolean&#9;geWorld_SetLTypeTable(geWorld *World, int32 LType, const char *Table);</P>

<P>// World fog</P>
<P>GENESISAPI geFog&#9;&#9;*geWorld_AddFog(geWorld *World);</P>
<P>GENESISAPI geBoolean&#9;geWorld_RemoveFog(geWorld *World, geFog *Fog);</P>

<P>GENESISAPI geBoolean geFog_SetAttributes(&#9;geFog&#9;&#9;&#9;*Fog, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d&#9;*Pos, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_RGBA&#9;&#9;&#9;*Color,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float&#9;&#9;&#9;LightBrightness, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float&#9;&#9;&#9;VolumeBrightness, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float&#9;&#9;&#9;VolumeRadius);</P>

<P>// World Classes/Entities</P>
<P>GENESISAPI geEntity_EntitySet *geWorld_GetEntitySet(geWorld *World, const char *ClassName);</P>
<P>GENESISAPI geEntity&#9;&#9;*geEntity_EntitySetGetNextEntity(geEntity_EntitySet *EntitySet, geEntity *Entity);</P>
<P>GENESISAPI void&#9;&#9;&#9;*geEntity_GetUserData(geEntity *Entity);</P>
<P>GENESISAPI void&#9;&#9;&#9;geEntity_GetName(const geEntity *Entity, char *Buff, int MaxLen);</P>

<P>// World collision</P>
<P>GENESISAPI geBoolean&#9;geWorld_ModelCollision(&#9;geWorld&#9;&#9;&#9;*World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geWorld_Model&#9;*Model, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d&#9;*DXForm, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_Collision&#9;*Collision);</P>
<P>GENESISAPI geBoolean geWorld_TestModelMove(&#9;geWorld&#9;&#9;&#9;*World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geWorld_Model&#9;*Model, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d&#9;*DXForm, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d&#9;*Mins, const geVec3d *Maxs,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d&#9;*In, geVec3d *Out);</P>

<P>GENESISAPI geBoolean geWorld_Collision(&#9;geWorld *World,&#9;&#9;&#9;&#9;// World to collide with</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Mins,&#9;&#9;// Mins of object (in object-space).  This CAN be NULL</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Maxs,&#9;&#9;// Maxs of object (in object-space).  This CAN be NULL</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Front,&#9;&#9;// Front of line (in world-space)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Back,&#9;&#9;// Back of line (in world-space)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 Contents,&#9;&#9;&#9;// Contents to collide with (use GE_CONTENTS_SOLID_CLIP for default)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 CollideFlags,&#9;&#9;// To mask out certain object types (GE_COLLIDE_ALL, etc...)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 UserFlags,&#9;&#9;&#9;// To mask out actors (refer to geActor_SetUserFlags)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_CollisionCB *CollisionCB, // A callback to allow user to reject collisions with certain objects)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;void *Context,&#9;&#9;&#9;&#9;// User data passed through above callback</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_Collision *Col);&#9;&#9;&#9;// Structure filled with info about what was collided with</P>
<P>&#9;// NOTE - Mins/Maxs CAN be NULL.  If you are just testing a point, then use NULL (it's faster!!!).</P>

<P>GENESISAPI geBoolean geWorld_GetContents(geWorld *World, const geVec3d *Pos, const geVec3d *Mins, const geVec3d *Maxs, uint32 Flags, uint32 UserFlags, GE_CollisionCB *CollisionCB, void *Context, GE_Contents *Contents);</P>

<P>// World Polys</P>
<P>GENESISAPI&#9;gePoly *geWorld_AddPolyOnce(geWorld *World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_LVertex *Verts, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap *Bitmap,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;gePoly_Type Type, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 RenderFlags,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float Scale);</P>
<P>GENESISAPI&#9;gePoly *geWorld_AddPoly(geWorld *World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_LVertex *Verts, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap *Bitmap,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;gePoly_Type Type,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 RenderFlags,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float Scale);</P>

<P>GENESISAPI&#9;void geWorld_RemovePoly(geWorld *World, gePoly *Poly);</P>
<P>GENESISAPI&#9;geBoolean gePoly_GetLVertex(gePoly *Poly, int32 Index, GE_LVertex *LVert);</P>
<P>GENESISAPI&#9;geBoolean gePoly_SetLVertex(gePoly *Poly, int32 Index, const GE_LVertex *LVert);</P>

<P>// World visibility</P>
<P>GENESISAPI geBoolean&#9;geWorld_GetLeaf(const geWorld *World, const geVec3d *Pos, int32 *Leaf);</P>
<P>GENESISAPI geBoolean&#9;geWorld_MightSeeLeaf(const geWorld *World, int32 Leaf);</P>

<P>GENESISAPI geBoolean&#9;geWorld_LeafMightSeeLeaf(const geWorld *World, int32 Leaf1, int32 Leaf2, uint32 VisFlags);</P>
<P>&#9;// Checks to see if Leaf1 can see Leaf2</P>
<P>&#9;// Currently VisFlags is not used yet.  It could be used for checking against areas, etc...</P>
<P>&#9;// Eventually you could also pass in a VisObject, that is manipulated with a camera...</P>

<P>GENESISAPI geBoolean GENESISCC geWorld_IsActorPotentiallyVisible(const geWorld *World, const geActor *Actor, const geCamera *Camera);</P>

<P>&nbsp;</P>
<P>//================================================================================</P>
<P>//&#9;Camera Management functions</P>
<P>//================================================================================</P>

<P>GENESISAPI geCamera&#9;&#9;&#9;*GENESISCC geCamera_Create(geFloat Fov, const geRect *Rect);</P>
<P>GENESISAPI void&#9;&#9;&#9;&#9;GENESISCC geCamera_Destroy(geCamera **pCamera);</P>
<P>GENESISAPI void&#9;&#9;&#9;&#9;GENESISCC geCamera_SetZScale(geCamera *Camera, geFloat ZScale);</P>
<P>GENESISAPI geFloat&#9;&#9;&#9;GENESISCC geCamera_GetZScale(const geCamera *Camera);</P>
<P>GENESISAPI void&#9;&#9;&#9;&#9;GENESISCC geCamera_SetAttributes(geCamera *Camera,geFloat Fov, const geRect *Rect);</P>
<P>GENESISAPI void&#9;&#9;&#9;&#9;GENESISCC geCamera_GetClippingRect(const geCamera *Camera, geRect *Rect);</P>

<P>GENESISAPI void&#9;&#9;&#9;&#9;GENESISCC geCamera_ScreenPointToWorld(const geCamera&#9;*Camera,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32&#9;&#9;&#9; ScreenX,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32&#9;&#9;&#9; ScreenY,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d&#9;&#9;&#9;*Vector&#9;);</P>
<P>GENESISAPI void&#9;GENESISCC geCamera_Project(const geCamera&#9;*Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d&#9;*PointInCameraSpace, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d&#9;&#9;&#9;*ProjectedPoint);</P>
<P>GENESISAPI void GENESISCC geCamera_Transform(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *WorldSpacePoint, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  geVec3d *CameraSpacePoint);</P>

<P>GENESISAPI void GENESISCC geCamera_TransformArray(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *WorldSpacePointPtr, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;      geVec3d *CameraSpacePointPtr,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int count);</P>

<P>GENESISAPI void GENESISCC geCamera_TransformAndProject(const geCamera *Camera,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const&#9;geVec3d *Point, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *ProjectedPoint);</P>

<P>GENESISAPI void GENESISCC geCamera_TransformAndProjectArray(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *WorldSpacePointPtr, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;      geVec3d *ProjectedSpacePointPtr,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int count);</P>
<P>&#9;</P>
<P>GENESISAPI void GENESISCC geCamera_TransformAndProjectL(const geCamera *Camera,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const GE_LVertex *Point, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_TLVertex *ProjectedPoint);</P>
<P>&#9;&#9;</P>
<P>GENESISAPI void GENESISCC geCamera_TransformAndProjectLArray(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const GE_LVertex *WorldSpacePointPtr, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;      GE_TLVertex *ProjectedSpacePointPtr,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int count);</P>

<P>&nbsp;</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCamera_SetWorldSpaceXForm(geCamera *Camera, const geXForm3d *XForm);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCamera_SetWorldSpaceVisXForm(geCamera *Camera, const geXForm3d *XForm);</P>
<P>GENESISAPI const geXForm3d&#9;*GENESISCC geCamera_GetWorldSpaceXForm( const geCamera *Camera);</P>
<P>GENESISAPI const geXForm3d * GENESISCC geCamera_GetWorldSpaceVisXForm( const geCamera *Camera);</P>
<P>GENESISAPI geBoolean GENESISCC geCamera_ConvertWorldSpaceToCameraSpace(const geXForm3d *WXForm, geXForm3d *CXForm);</P>

<P>&nbsp;</P>
<P>//================================================================================</P>
<P>// NetPlay Management functions</P>
<P>//================================================================================</P>

<P>typedef uint32&#9;&#9;&#9;&#9;geCSNetMgr_NetID;</P>
<P>#define&#9;MAX_CLIENT_NAME&#9;&#9;256</P>

<P>// Types for messages received from GE_ReceiveSystemMessage</P>
<P>typedef enum </P>
<P>{</P>
<P>&#9;NET_MSG_NONE,&#9;&#9;&#9;&#9;&#9;// No msg</P>
<P>&#9;NET_MSG_USER,&#9;&#9;&#9;&#9;&#9;// User message</P>
<P>&#9;NET_MSG_CREATE_CLIENT,&#9;&#9;&#9;// A new client has joined in</P>
<P>&#9;NET_MSG_DESTROY_CLIENT,&#9;&#9;&#9;// An existing client has left</P>
<P>&#9;NET_MSG_HOST,&#9;&#9;&#9;&#9;&#9;// We are the server now</P>
<P>&#9;NET_MSG_SESSIONLOST,&#9;&#9;&#9;// Connection was lost</P>
<P>&#9;NET_MSG_SERVER_ID,&#9;&#9;&#9;&#9;// Internal, for hand shaking process</P>
<P>} geCSNetMgr_NetMsgType;</P>

<P>&nbsp;</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;char&#9;&#9;&#9;&#9;Name[MAX_CLIENT_NAME];</P>
<P>&#9;geCSNetMgr_NetID&#9;Id;</P>
<P>} geCSNetMgr_NetClient;</P>

<P>#ifdef _INC_WINDOWS</P>
<P>&#9;// Windows.h must be included before genesis.h for this api to be exposed.</P>
<P>&#9;typedef struct geCSNetMgr_NetSession</P>
<P>&#9;{</P>
<P>&#9;&#9;char&#9;&#9;SessionName[200];&#9;&#9;&#9;&#9;&#9;// Description of Service provider</P>
<P>&#9;&#9;GUID&#9;&#9;Guid;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Service Provider GUID</P>
<P>&#9;} geCSNetMgr_NetSession;</P>
<P>GENESISAPI &#9;geBoolean&#9;&#9;GENESISCC geCSNetMgr_FindSession(geCSNetMgr *M, const char *IPAdress, geCSNetMgr_NetSession **SessionList, int32 *SessionNum );</P>
<P>GENESISAPI &#9;geBoolean&#9;&#9;GENESISCC geCSNetMgr_JoinSession(geCSNetMgr *M, const char *Name, const geCSNetMgr_NetSession* Session);</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>GENESISAPI geCSNetMgr&#9;*&#9;GENESISCC geCSNetMgr_Create(void);</P>
<P>GENESISAPI void&#9;&#9;&#9;&#9;GENESISCC geCSNetMgr_Destroy(geCSNetMgr **ppM);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_ReceiveFromServer(geCSNetMgr *M, geCSNetMgr_NetMsgType *Type, int32 *Size, uint8 **Data);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_ReceiveFromClient(geCSNetMgr *M, geCSNetMgr_NetMsgType *Type, geCSNetMgr_NetID *IdClient, int32 *Size, uint8 **Data);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_ReceiveSystemMessage(geCSNetMgr *M, geCSNetMgr_NetID IdFor, geCSNetMgr_NetMsgType *Type, geCSNetMgr_NetClient *Client);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_ReceiveAllMessages(geCSNetMgr *M, geCSNetMgr_NetID *IdFrom, geCSNetMgr_NetID *IdTo, geCSNetMgr_NetMsgType *Type, int32 *Size, uint8 **Data);</P>
<P>GENESISAPI geCSNetMgr_NetID&#9;GENESISCC geCSNetMgr_GetServerID(geCSNetMgr *M);</P>
<P>GENESISAPI geCSNetMgr_NetID&#9;GENESISCC geCSNetMgr_GetOurID(geCSNetMgr *M);</P>
<P>GENESISAPI geCSNetMgr_NetID&#9;GENESISCC geCSNetMgr_GetAllPlayerID(geCSNetMgr *M);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_WeAreTheServer(geCSNetMgr *M);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_StartSession(geCSNetMgr *M, const char *SessionName, const char *PlayerName );</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_StopSession(geCSNetMgr *M);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_SendToServer(geCSNetMgr *M, geBoolean Guaranteed, uint8 *Data, int32 DataSize);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_SendToClient(geCSNetMgr *M, geCSNetMgr_NetID To, geBoolean Guaranteed, uint8 *Data, int32 DataSize);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558908"><A NAME="_Toc454069925">Getypes.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  GeTypes.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Description: Genesis Types (not primitive enough for basetype)                      */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_TYPES_H</P>
<P>#define GE_TYPES_H</P>

<P>#include "BaseType.h"</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//</P>
<P>//&#9;Collision defines (for geWorld_Collision)</P>
<P>//</P>
<P>#define GE_COLLIDE_MESHES&#9;&#9;&#9;(1&lt;&lt;0)</P>
<P>#define GE_COLLIDE_MODELS&#9;&#9;&#9;(1&lt;&lt;1)</P>
<P>#define GE_COLLIDE_ACTORS&#9;&#9;&#9;(1&lt;&lt;2)</P>
<P>#define GE_COLLIDE_NO_SUB_MODELS&#9;(1&lt;&lt;3)</P>
<P>#define GE_COLLIDE_ALL&#9;&#9;&#9;&#9;(GE_COLLIDE_MESHES | GE_COLLIDE_MODELS | GE_COLLIDE_ACTORS)</P>

<P>//</P>
<P>// Actor flags (geWorld_AddActor)</P>
<P>//</P>
<P>#define GE_ACTOR_RENDER_NORMAL&#9;&#9;&#9;(1&lt;&lt;0)&#9;&#9;// Render in normal views</P>
<P>#define GE_ACTOR_RENDER_MIRRORS&#9;&#9;&#9;(1&lt;&lt;1)&#9;&#9;// Render in mirror views</P>
<P>#define GE_ACTOR_RENDER_ALWAYS&#9;&#9;&#9;(1&lt;&lt;2)&#9;&#9;// Render always, skipping all visibility tests</P>
<P>#define GE_ACTOR_COLLIDE&#9;&#9;&#9;&#9;(1&lt;&lt;3)&#9;&#9;// Collide when calling geWorld_Collision</P>

<P>//</P>
<P>//&#9;Model flags (geWorld_ModelSetFlags)</P>
<P>//</P>
<P>#define GE_MODEL_RENDER_NORMAL&#9;&#9;&#9;(1&lt;&lt;0)&#9;&#9;// Render in normal views</P>
<P>#define GE_MODEL_RENDER_MIRRORS&#9;&#9;&#9;(1&lt;&lt;1)&#9;&#9;// Render in mirror views</P>
<P>#define GE_MODEL_RENDER_ALWAYS&#9;&#9;&#9;(1&lt;&lt;2)&#9;&#9;// Render always, skipping all visibility tests</P>
<P>#define GE_MODEL_COLLIDE&#9;&#9;&#9;&#9;(1&lt;&lt;3)&#9;&#9;// Collide when calling geWorld_Collision</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;float r, g, b, a;</P>
<P>} GE_RGBA;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;int32&#9;Left;</P>
<P>&#9;int32&#9;Right;</P>
<P>&#9;int32&#9;Top;</P>
<P>&#9;int32&#9;Bottom;</P>
<P>} GE_Rect;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;geFloat MinX,MaxX;</P>
<P>&#9;geFloat MinY,MaxY;</P>
<P>} geFloatRect;</P>

<P>// Lit vertex</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;// FIXME:  Convert 3d X,Y,Z to geVec3d</P>
<P>&#9;float X, Y, Z;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 3d vertex</P>
<P>&#9;float u, v;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Uv's</P>
<P>&#9;// FIXME:  Convert r,g,b,a to GE_RGBA</P>
<P>&#9;float r, g, b, a;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// color</P>
<P>} GE_LVertex;</P>

<P>// Transformed Lit vertex</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;float x, y, z;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// screen points</P>
<P>&#9;float u, v;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Uv's</P>
<P>&#9;float r, g, b, a;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// color</P>
<P>} GE_TLVertex;</P>

<P>typedef GE_Rect geRect;</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif GETYPES_H</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558909"><A NAME="_Toc454069926">Matrix33.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  MATRIX33.H                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Jason Wood                                                                  */</P>
<P>/*  Description: Pure 3x3 matrix                                                        */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef&#9;MATRIX33_H</P>
<P>#define MATRIX33_H</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;float x[3][3];</P>
<P>}&#9;Matrix33;</P>

<P>void Matrix33_Copy(const Matrix33* m, Matrix33* c);</P>
<P>void Matrix33_SetIdentity(Matrix33* m);</P>
<P>void Matrix33_Add(const Matrix33* m1, const Matrix33* m2, Matrix33* res);</P>
<P>void Matrix33_Subtract(const Matrix33* m1, const Matrix33* m2, Matrix33* res);</P>
<P>void Matrix33_MultiplyVec3d(const Matrix33* m, const geVec3d* v, geVec3d* res);</P>
<P>void Matrix33_Multiply(const Matrix33* m1, const Matrix33* m2, Matrix33* res);</P>
<P>void Matrix33_MultiplyScalar(float s, const Matrix33* m, Matrix33* res);</P>
<P>void Matrix33_GetTranspose(const Matrix33* m, Matrix33* t);</P>
<P>void Matrix33_GetInverse(const Matrix33* m, Matrix33* inv);</P>
<P>void Matrix33_MakeCrossProductMatrix33(const geVec3d* v, Matrix33* m);</P>
<P>void Matrix33_ExtractFromXForm3d(const geXForm3d* xform, Matrix33* m);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558910"><A NAME="_Toc454069927">Motion.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  MOTION.H&#9;                                                                        */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description: Motion interface.&#9;&#9;&#9;&#9;&#9;                                    */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_MOTION_H</P>
<P>#define GE_MOTION_H</P>

<P>/*&#9;motion</P>

<P>&#9;This object is a list of named Path objects</P>

<P>*/</P>

<P>#include &lt;stdio.h&gt;</P>
<P>#include "basetype.h"</P>
<P>#include "path.h"</P>
<P>#include "vfile.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>// GENESIS_PUBLIC_APIS</P>
<P>typedef struct geMotion geMotion;</P>

<P>GENESISAPI geMotion *GENESISCC geMotion_Create(geBoolean ManageNames);</P>

<P>GENESISAPI void GENESISCC geMotion_Destroy(geMotion **PM);</P>

<P>// GENESIS_PRIVATE_APIS</P>

<P>GENESISAPI geBoolean GENESISCC geMotion_IsValid(const geMotion *M);</P>

<P>&#9;// AddPath adds a reference of P to the motion M.  Ownership is shared - The caller must destroy P.</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_AddPath(geMotion *M, gePath *P,const char *Name,int *Index);</P>

<P>GENESISAPI geBoolean GENESISCC geMotion_HasNames(const geMotion *M);</P>
<P>GENESISAPI int32 GENESISCC geMotion_GetNameChecksum(const geMotion *M);</P>

<P>GENESISAPI geBoolean GENESISCC geMotion_RemoveNames(geMotion *M);</P>

<P>GENESISAPI void GENESISCC geMotion_SampleChannels(const geMotion *M, int PathIndex, geFloat Time, geQuaternion *Rotation, geVec3d *Translation);</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_SampleChannelsNamed(const geMotion *M, const char *PathName, geFloat Time, geQuaternion *Rotation, geVec3d *Translation);</P>

<P>GENESISAPI void GENESISCC geMotion_Sample(const geMotion *M, int PathIndex, geFloat Time, geXForm3d *Transform);</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_SampleNamed(const geMotion *M, const char *PathName, geFloat Time, geXForm3d *Transform);</P>

<P>&#9;// the returned Paths from _Get functions should not be destroyed.  </P>
<P>&#9;// if ownership is desired, call gePath_CreateRef() to create another owner. </P>
<P>&#9;// an 'owner' has access to the object regardless of the number of other owners, and </P>
<P>&#9;// an owner must call the object's destroy method to relinquish ownership</P>
<P>GENESISAPI gePath *GENESISCC geMotion_GetPathNamed(const geMotion *M,const char *Name);</P>
<P>GENESISAPI const char *GENESISCC geMotion_GetNameOfPath(const geMotion *M, int Index);</P>

<P>// GENESIS_PUBLIC_APIS</P>
<P>GENESISAPI gePath *GENESISCC geMotion_GetPath(const geMotion *M,int Index);</P>
<P>GENESISAPI int GENESISCC geMotion_GetPathCount(const geMotion *M);</P>

<P>&nbsp;</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_SetName(geMotion *M, const char * Name);</P>
<P>GENESISAPI const char *GENESISCC geMotion_GetName(const geMotion *M);</P>

<P>// GENESIS_PRIVATE_APIS</P>

<P>&#9;// support for compound motions.  A motion can either have sub-motions, or be single motion.</P>
<P>&#9;// these functions support motions that have sub-motions.</P>
<P>GENESISAPI int GENESISCC geMotion_GetSubMotionCount(const geMotion*M);</P>

<P>&#9;// the returned motions from these _Get functions should not be destroyed.  </P>
<P>&#9;// if ownership is desired, call geMotion_CreateRef() to create another owner. </P>
<P>&#9;// an 'owner' has access to the object regardless of the number of other owners, and </P>
<P>&#9;// an owner must call the object's destroy method to relinquish ownership</P>
<P>GENESISAPI geMotion *GENESISCC geMotion_GetSubMotion(const geMotion *M,int Index);</P>
<P>GENESISAPI geMotion *GENESISCC geMotion_GetSubMotionNamed(const geMotion *M,const char *Name);</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_AddSubMotion(</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geMotion *ParentMotion,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat TimeScale,&#9;&#9;&#9;// Scale factor for this submotion</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat TimeOffset,&#9;&#9;&#9;// Time in parent motion when submotion should start</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geMotion *SubMotion,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat StartTime,&#9;&#9;&#9;// Blend start time (relative to submotion)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat StartMagnitude,&#9;&#9;// Blend start magnitude (0..1)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat EndTime,&#9;&#9;&#9;// Blend ending time (relative to submotion)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat EndMagnitude,&#9;&#9;// Blend ending magnitude (0..1)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d *Transform,&#9;// Base transform to apply to this submotion</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int *Index);&#9;&#9;&#9;&#9;// returned motion index</P>

<P>GENESISAPI geMotion *GENESISCC  geMotion_RemoveSubMotion(geMotion *ParentMotion, int SubMotionIndex);</P>

<P>// Get/Set submotion time offset.  The time offset is the offset into the </P>
<P>// compound (parent) motion at which the submotion should start.</P>
<P>GENESISAPI geFloat   GENESISCC  geMotion_GetTimeOffset( const geMotion *M,int SubMotionIndex );</P>
<P>GENESISAPI geBoolean  GENESISCC geMotion_SetTimeOffset( geMotion *M,int SubMotionIndex,geFloat TimeOffset );</P>

<P>// Get/Set submotion time scale.  Time scaling is applied to the submotion after the TimeOffset</P>
<P>// is applied.  The formula is:  (CurrentTime - TimeOffset) * TimeScale</P>
<P>GENESISAPI geFloat   GENESISCC  geMotion_GetTimeScale( const geMotion *M,int SubMotionIndex );</P>
<P>GENESISAPI geBoolean  GENESISCC geMotion_SetTimeScale( geMotion *M,int SubMotionIndex,geFloat TimeScale );</P>

<P>// Get blending amount for a particular submotion.  The Time parameter is parent-relative.</P>
<P>GENESISAPI geFloat    GENESISCC geMotion_GetBlendAmount( const geMotion *M, int SubMotionIndex, geFloat Time);</P>

<P>// Get/Set blending path.  The keyframe times in the blend path are relative to the submotion.</P>
<P>GENESISAPI gePath    *GENESISCC geMotion_GetBlendPath( const geMotion *M,int SubMotionIndex );</P>
<P>GENESISAPI geBoolean  GENESISCC geMotion_SetBlendPath( geMotion *M,int SubMotionIndex, gePath *Blend );</P>

<P>GENESISAPI const geXForm3d *GENESISCC geMotion_GetBaseTransform( const geMotion *M,int SubMotionIndex );</P>
<P>GENESISAPI geBoolean  GENESISCC geMotion_SetBaseTransform( geMotion *M,int SubMotionIndex, geXForm3d *BaseTransform );</P>
<P>GENESISAPI geBoolean  GENESISCC geMotion_GetTransform(const geMotion *M, geFloat Time, geXForm3d *Transform);</P>
<P>// GENESIS_PUBLIC_APIS</P>

<P>&#9;// gets time of first key and time of last key (as if motion did not loop)</P>
<P>&#9;// if there are no paths in the motion: returns GE_FALSE and times are not set</P>
<P>&#9;// otherwise returns GE_TRUE</P>
<P>&#9;//</P>
<P>&#9;// For a compound motion, GetTimeExtents will return the extents of the scaled submotions.</P>
<P>&#9;// For a single motion, no scaling is applied.</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_GetTimeExtents(const geMotion *M,geFloat *StartTime,geFloat *EndTime);</P>

<P>// Only one event is allowed per time key.</P>

<P>GENESISAPI geBoolean GENESISCC geMotion_InsertEvent(geMotion *M, geFloat tKey, const char* String);</P>
<P>&#9;// Inserts the new event and corresponding string.</P>

<P>GENESISAPI geBoolean GENESISCC geMotion_DeleteEvent(geMotion *M, geFloat tKey);</P>
<P>&#9;// Deletes the event</P>

<P>GENESISAPI void GENESISCC geMotion_SetupEventIterator(</P>
<P>&#9;geMotion *M,</P>
<P>&#9;geFloat StartTime,&#9;&#9;&#9;&#9;// Inclusive search start</P>
<P>&#9;geFloat EndTime);&#9;&#9;&#9;&#9;// Non-inclusive search stop</P>
<P>&#9;// For searching or querying the array for events between two times</P>
<P>&#9;// times are compaired [StartTime,EndTime), '[' is inclusive, ')' is </P>
<P>&#9;// non-inclusive.  This prepares the geMotion_GetNextEvent() function.</P>

<P>GENESISAPI geBoolean GENESISCC geMotion_GetNextEvent(</P>
<P>&#9;geMotion *M,&#9;&#9;&#9;&#9;&#9;&#9;// Event list to iterate</P>
<P>&#9;geFloat *pTime,&#9;&#9;&#9;&#9;// Return time, if found</P>
<P>&#9;const char **ppEventString);&#9;// Return data, if found</P>
<P>&#9;// Iterates from StartTime to EndTime as setup in geMotion_SetupEventIterator()</P>
<P>&#9;// and for each event between these times [StartTime,EndTime)</P>
<P>&#9;// this function will return Time and EventString returned for that event</P>
<P>&#9;// and the iterator will be positioned for the next search.  When there </P>
<P>&#9;// are no more events in the range, this function will return GE_FALSE (Time</P>
<P>&#9;// will be 0 and ppEventString will be empty).</P>

<P>GENESISAPI geBoolean GENESISCC geMotion_GetEventExtents(const geMotion *M,</P>
<P>&#9;&#9;&#9;geFloat *FirstEventTime,</P>
<P>&#9;&#9;&#9;geFloat *LastEventTime);</P>
<P>&#9;// returns the time associated with the first and last events </P>
<P>&#9;// returns GE_FALSE if there are no events (and Times are not set)</P>

<P>&nbsp;</P>
<P>// GENESIS_PRIVATE_APIS</P>
<P>GENESISAPI geMotion *GENESISCC geMotion_CreateFromFile(geVFile *f);</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_WriteToFile(const geMotion *M, geVFile *f);</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_WriteToBinaryFile(const geMotion *M,geVFile *pFile);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558911"><A NAME="_Toc454069928">Path.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  PATH.H&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description: Time-indexed keyframe creation, maintenance, and sampling.&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_PATH_H</P>
<P>#define GE_PATH_H</P>

<P>#include "basetype.h"</P>
<P>#include "xform3d.h"</P>
<P>#include "quatern.h"</P>
<P>#include "vfile.h"</P>

<P>#ifdef __cplusplus</P>
<P>&#9;extern "C" {</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>// GENESIS_PUBLIC_APIS</P>
<P>typedef struct _gePath gePath;</P>

<P>#define GE_PATH_ROTATION_CHANNEL    1</P>
<P>#define GE_PATH_TRANSLATION_CHANNEL 2</P>

<P>#define GE_PATH_ALL_CHANNELS (GE_PATH_ROTATION_CHANNEL | GE_PATH_TRANSLATION_CHANNEL)</P>

<P>#ifndef GE_PATH_ENUMS</P>
<P>&#9;#define GE_PATH_ENUMS</P>
<P>&#9;typedef enum </P>
<P>&#9;{</P>
<P>&#9;&#9;GE_PATH_INTERPOLATE_LINEAR  = 0,&#9;// linear blend for translation or rotation channel</P>
<P>&#9;&#9;GE_PATH_INTERPOLATE_HERMITE,&#9;&#9;// hermite cubic spline for translation channel</P>
<P>&#9;&#9;GE_PATH_INTERPOLATE_SLERP,&#9;&#9;&#9;// spherical-linear blend for rotation channel</P>
<P>&#9;&#9;GE_PATH_INTERPOLATE_SQUAD,&#9;&#9;&#9;// higher order blend for rotation channel 'G1' continuity</P>
<P>&#9;&#9;//GE_PATH_INTEROPLATE_TRIPOD,&#9;&#9; // not supported yet.</P>
<P>&#9;&#9;GE_PATH_INTERPOLATE_HERMITE_ZERO_DERIV = 7&#9;// hermite cubic with zero derivative at keyframes ('easing' curve)</P>
<P>&#9;}gePath_Interpolator;</P>
<P>#endif</P>

<P>GENESISAPI void GENESISCC gePath_CreateRef( gePath *P );</P>

<P>GENESISAPI gePath *GENESISCC gePath_Create(</P>
<P>&#9;gePath_Interpolator TranslationInterpolation,&#9;// type of interpolation for translation channel</P>
<P>&#9;gePath_Interpolator RotationInterpolation,&#9;// type of interpolation for rotation channel</P>
<P>&#9;geBoolean Looped);&#9;&#9;&#9;&#9;// True if end of path is connected to head</P>
<P>&#9;// creates new gePath</P>
<P>&#9;//  A looping path should have the same first &amp; last point.  The path</P>
<P>&#9;//  generator will choose arbitrarily between these points for a </P>
<P>&#9;//  sample exactly at the end of the loop.</P>

<P>GENESISAPI gePath *GENESISCC gePath_CreateCopy( const gePath *P );</P>
<P>&#9;</P>
<P>GENESISAPI void GENESISCC gePath_Destroy(gePath **PP);&#9;&#9;</P>
<P>&#9;// destroys path *PP</P>

<P>//------------------ time based keyframe operations</P>
<P>GENESISAPI geBoolean GENESISCC gePath_InsertKeyframe(</P>
<P>&#9;gePath *P, </P>
<P>&#9;int ChannelMask, </P>
<P>&#9;geFloat Time, </P>
<P>&#9;const geXForm3d *Matrix); </P>
<P>&#9;// inserts a keyframe at a specific time.</P>
<P>&#9;</P>
<P>GENESISAPI geBoolean GENESISCC gePath_DeleteKeyframe(</P>
<P>&#9;gePath *P,</P>
<P>&#9;int Index,</P>
<P>&#9;int ChannelMask); </P>
<P>&#9;// deletes the nth keyframe</P>

<P>GENESISAPI geBoolean GENESISCC gePath_GetTimeExtents(</P>
<P>&#9;const gePath *P,</P>
<P>&#9;geFloat *StartTime, </P>
<P>&#9;geFloat *EndTime);</P>
<P>&#9;// gets the time for the first and last keys in the path (ignoring looping)</P>
<P>&#9;// if there are no keys, return GE_FALSE and times are not set.</P>
<P>&#9;// returns GE_TRUE if there are keys.</P>

<P>//----------------- index based keyframe operations</P>
<P>GENESISAPI void GENESISCC gePath_GetKeyframe(</P>
<P>&#9;const gePath *P, </P>
<P>&#9;int Index,&#9;&#9;&#9;&#9;// gets keyframe[index]</P>
<P>&#9;int Channel,&#9;&#9;&#9;// for this channel</P>
<P>&#9;geFloat *Time,&#9;&#9;&#9;// returns the time of the keyframe</P>
<P>&#9;geXForm3d *Matrix);&#9;&#9;// returns the matrix of the keyframe</P>
<P>&#9;// retrieves keyframe[index], and it's time</P>

<P>GENESISAPI int GENESISCC gePath_GetKeyframeCount(const gePath *P,int Channel);</P>
<P>&#9;// retrieves count of keyframes for a specific channel</P>

<P>GENESISAPI int GENESISCC gePath_GetKeyframeIndex(const gePath *P, int Channel, geFloat Time);</P>
<P>&#9;// retrieves the index of the keyframe at a specific time for a specific channel</P>

<P>//----------------- sampling a path  (time based)</P>
<P>GENESISAPI void GENESISCC gePath_Sample(const gePath *P, geFloat Time,geXForm3d *Matrix);</P>
<P>&#9;// returns a transform matrix sampled at 'Time'.</P>
<P>&#9;// p is not const because information is cached in p for next sample</P>

<P>// GENESIS_PRIVATE_APIS</P>
<P>void GENESISCC gePath_SampleChannels(</P>
<P>&#9;const gePath *P, </P>
<P>&#9;geFloat Time, </P>
<P>&#9;geQuaternion *Rotation, </P>
<P>&#9;geVec3d *Translation);</P>
<P>&#9;// returns a rotation and a translation for the path at 'Time'</P>
<P>&#9;// p is not const because information is cached in p for next sample</P>

<P>GENESISAPI geBoolean GENESISCC gePath_OffsetTimes(gePath *P, </P>
<P>&#9;int StartingIndex, int ChannelMask, geFloat TimeOffset );</P>
<P>&#9;&#9;// slides all samples in path starting with StartingIndex down by TimeOffset</P>

<P>GENESISAPI geBoolean GENESISCC gePath_ModifyKeyframe(</P>
<P>&#9;gePath *P,</P>
<P>&#9;int Index,</P>
<P>&#9;int ChannelMask,</P>
<P>&#9;const geXForm3d *Matrix);</P>
<P>&#9;</P>

<P>// GENESIS_PUBLIC_APIS</P>

<P>//------------------ saving/loading a path</P>
<P>GENESISAPI gePath* GENESISCC gePath_CreateFromFile(geVFile *F);</P>
<P>&#9;// loads a file  (binary or ascii)</P>

<P>GENESISAPI geBoolean GENESISCC gePath_WriteToFile(const gePath *P, geVFile *F);</P>
<P>&#9;// dumps formatted ascii to the file.  </P>

<P>GENESISAPI geBoolean GENESISCC gePath_WriteToBinaryFile(const gePath *P, geVFile *F);</P>
<P>&#9;// dumps a minimal binary image for fastest reading</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>&#9;}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558912"><A NAME="_Toc454069929">PhysicsJoint.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  PHYSICSJOINT.H                                                                      */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Jason Wood                                                                  */</P>
<P>/*  Description: Rigid body joint interface                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef&#9;PHYSICSJOINT_H</P>
<P>#define PHYSICSJOINT_H</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef enum</P>
<P>{</P>
<P>&#9;JT_WORLD = 0,</P>
<P>&#9;JT_SPHERICAL,</P>
<P>&#9;JT_PTTOPATH,</P>
<P>&#9;JT_PTTOSURFACE</P>
<P>}&#9;gePhysicsJoint_Kind;</P>

<P>typedef struct gePhysicsJoint gePhysicsJoint;</P>

<P>////////////////////////////////////////////////////////////////////////////////////////////////////</P>
<P>// ctor / dtor</P>

<P>//gePhysicsJoint* gePhysicsJoint_Create(ItemJoint* pItemJoint);</P>
<P>GENESISAPI gePhysicsJoint * GENESISCC gePhysicsJoint_Create(gePhysicsJoint_Kind Kind, const geVec3d *Location, </P>
<P>&#9;float assemblyRate, gePhysicsObject *PS1, gePhysicsObject *PS2, float physicsScale);</P>
<P>GENESISAPI geBoolean GENESISCC gePhysicsJoint_Destroy(gePhysicsJoint** ppPhysjnt);</P>

<P>////////////////////////////////////////////////////////////////////////////////////////////////////////////</P>
<P>// functions</P>

<P>GENESISAPI gePhysicsJoint_Kind GENESISCC gePhysicsJoint_GetType(const gePhysicsJoint* pPhysjnt);</P>
<P>GENESISAPI void GENESISCC gePhysicsJoint_GetLocationA(const gePhysicsJoint* pPhysjnt, geVec3d* pLoc);</P>
<P>GENESISAPI void GENESISCC gePhysicsJoint_GetLocationB(const gePhysicsJoint* pPhysjnt, geVec3d* pLoc);</P>
<P>GENESISAPI void GENESISCC gePhysicsJoint_SetLocationA(gePhysicsJoint* pPhysjnt, const geVec3d* pLoc);</P>
<P>GENESISAPI void GENESISCC gePhysicsJoint_SetLocationB(gePhysicsJoint* pPhysjnt, const geVec3d* pLoc);</P>
<P>GENESISAPI void GENESISCC gePhysicsJoint_GetLocationAInWorldSpace(const gePhysicsJoint* pPhysjnt, geVec3d* pLoc);</P>
<P>GENESISAPI void GENESISCC gePhysicsJoint_GetLocationBInWorldSpace(const gePhysicsJoint* pPhysjnt, geVec3d* pLoc);</P>
<P>GENESISAPI void GENESISCC gePhysicsJoint_SetLocationAInWorldSpace(gePhysicsJoint* pPhysjnt, const geVec3d* pLoc);</P>
<P>GENESISAPI void GENESISCC gePhysicsJoint_SetLocationBInWorldSpace(gePhysicsJoint* pPhysjnt, const geVec3d* pLoc);</P>
<P>GENESISAPI gePhysicsObject* GENESISCC gePhysicsJoint_GetObject1(const gePhysicsJoint* pPhysjnt);</P>
<P>GENESISAPI gePhysicsObject* GENESISCC gePhysicsJoint_GetObject2(const gePhysicsJoint* pPhysjnt);</P>
<P>GENESISAPI float GENESISCC gePhysicsJoint_GetAssemblyRate(const gePhysicsJoint* pPhysjnt);</P>
<P>GENESISAPI void GENESISCC gePhysicsJoint_SetAssemblyRate(gePhysicsJoint* pPhysjnt, float assemblyRate);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558913"><A NAME="_Toc454069930">PhysicsObject.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  PHYSICSOBJECT.H                                                                     */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Jason Wood                                                                  */</P>
<P>/*  Description: Constrained rigid body interface                                       */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef&#9;PHYSICSOBJECT_H</P>
<P>#define PHYSICSOBJECT_H</P>

<P>#include "matrix33.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define PHYSICSOBJECT_GRAVITY&#9;&#9;&#9;&#9;(-3.9f)</P>

<P>typedef struct gePhysicsObject gePhysicsObject;</P>

<P>////////////////////////////////////////////////////////////////////////////////////////////////////////////</P>
<P>// ctor/dtor</P>

<P>GENESISAPI gePhysicsObject * GENESISCC gePhysicsObject_Create(</P>
<P>&#9;const geVec3d *StartLocation,</P>
<P>&#9;float mass,</P>
<P>&#9;geBoolean IsAffectedByGravity,</P>
<P>&#9;geBoolean RespondsToForces,</P>
<P>&#9;float linearDamping,</P>
<P>&#9;float angularDamping,</P>
<P>&#9;const geVec3d *&#9;Mins,</P>
<P>&#9;const geVec3d *&#9;Maxs,</P>
<P>&#9;float physicsScale);</P>
<P>GENESISAPI geBoolean GENESISCC gePhysicsObject_Destroy(gePhysicsObject** pPhysob);</P>

<P>////////////////////////////////////////////////////////////////////////////////////////////////////////////</P>
<P>// functions</P>

<P>GENESISAPI geBoolean GENESISCC gePhysicsObject_ApplyGlobalFrameForce(gePhysicsObject* pod, geVec3d* force, geVec3d* radiusVector, geBoolean isAppliedForce,</P>
<P>&#9;int configIndex);</P>
<P>GENESISAPI geBoolean GENESISCC gePhysicsObject_ApplyGlobalFrameImpulse(gePhysicsObject* pPhysob, geVec3d* pImpulse, geVec3d* pRadVec, int configIndex);</P>
<P>GENESISAPI geBoolean GENESISCC gePhysicsObject_ComputeForces(gePhysicsObject* pod, int configIndex);</P>
<P>GENESISAPI geBoolean GENESISCC gePhysicsObject_Integrate(gePhysicsObject* pod, float deltaTime, int SourceConfigIndex);</P>

<P>GENESISAPI float GENESISCC gePhysicsObject_GetMass(const gePhysicsObject* po);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_SetMass(gePhysicsObject* po, float mass);</P>

<P>GENESISAPI float GENESISCC gePhysicsObject_GetOneOverMass(const gePhysicsObject* po);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_GetXForm(const gePhysicsObject* po, geXForm3d* xform, int configIndex);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_SetXForm(gePhysicsObject* po, const geXForm3d* xform, int configIndex);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_GetXFormInEditorSpace(const gePhysicsObject* po, geXForm3d* xform, int configIndex);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_GetOriginalLocation(const gePhysicsObject* po, geVec3d* loc);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_SetOriginalLocation(gePhysicsObject* po, const geVec3d* loc);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_GetLocation(const gePhysicsObject *po, geVec3d *Location, int configIndex);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_GetLocationInEditorSpace(const gePhysicsObject* po, geVec3d* loc, int configIndex);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_GetLinearVelocity(const gePhysicsObject* po, geVec3d* vel, int configIndex);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_SetLinearVelocity(gePhysicsObject* po, const geVec3d* vel, int configIndex);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_GetAngularVelocity(const gePhysicsObject* po, geVec3d* vel, int configIndex);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_SetAngularVelocity(gePhysicsObject* po, const geVec3d* vel, int configIndex);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_GetForce(const gePhysicsObject* po, geVec3d* force, int configIndex);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_SetForce(gePhysicsObject* po, const geVec3d* force, int configIndex);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_GetTorque(const gePhysicsObject* po, geVec3d* torque, int configIndex);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_SetTorque(gePhysicsObject* po, const geVec3d* torque, int configIndex);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_GetAppliedForce(const gePhysicsObject* po, geVec3d* force, int configIndex);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_SetAppliedForce(gePhysicsObject* po, const geVec3d* force, int configIndex);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_GetAppliedTorque(const gePhysicsObject* po, geVec3d* torque, int configIndex);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_SetAppliedTorque(gePhysicsObject* po, const geVec3d* torque, int configIndex);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_ClearForce(gePhysicsObject* po, int configIndex);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_ClearTorque(gePhysicsObject* po, int configIndex);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_ClearAppliedForce(gePhysicsObject* po, int configIndex);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_ClearAppliedTorque(gePhysicsObject* po, int configIndex);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_IncForce(gePhysicsObject* po, const geVec3d* forceInc, int configIndex);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_IncTorque(gePhysicsObject* po, const geVec3d* torqueInc, int configIndex);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_IncAppliedForce(gePhysicsObject* po, const geVec3d* forceInc, int configIndex);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_IncAppliedTorque(gePhysicsObject* po, const geVec3d* torqueInc, int configIndex);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_GetOrientation(const gePhysicsObject* po, geQuaternion* orient, int configIndex);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_SetOrientation(gePhysicsObject* po, const geQuaternion* orient, int configIndex);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_GetInertiaTensor(const gePhysicsObject* po, Matrix33* iTensor);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_GetInertiaTensorInverse(const gePhysicsObject* po, Matrix33* iTensorInv);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_GetInertiaTensorInPhysicsSpace(const gePhysicsObject* pPhysob, Matrix33* pITensor, int configIndex);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_GetInertiaTensorInverseInPhysicsSpace(const gePhysicsObject* pPhysob, Matrix33* pITensorInv, int configIndex);</P>

<P>GENESISAPI geBoolean GENESISCC gePhysicsObject_IsAffectedByGravity(const gePhysicsObject* po);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_SetIsAffectedByGravity(gePhysicsObject* po, geBoolean flag);</P>

<P>GENESISAPI geBoolean GENESISCC gePhysicsObject_RespondsToForces(const gePhysicsObject* po);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_SetRespondsToForces(gePhysicsObject* po, geBoolean flag);</P>

<P>GENESISAPI float GENESISCC gePhysicsObject_GetLinearDamping(const gePhysicsObject* po);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_SetLinearDamping(gePhysicsObject* po, float linearDamping);</P>

<P>GENESISAPI float GENESISCC gePhysicsObject_GetAngularDamping(const gePhysicsObject* po);</P>
<P>GENESISAPI void GENESISCC gePhysicsObject_SetAngularDamping(gePhysicsObject* po, float angularDamping);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_SetActiveConfig(gePhysicsObject* pPhysob, int configIndex);</P>
<P>GENESISAPI int GENESISCC gePhysicsObject_GetActiveConfig(gePhysicsObject* pPhysob);</P>

<P>GENESISAPI void GENESISCC gePhysicsObject_SetPhysicsScale(gePhysicsObject* pPhysob, float scale);</P>
<P>GENESISAPI float GENESISCC gePhysicsObject_GetPhysicsScale(gePhysicsObject* pPhysob);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558914"><A NAME="_Toc454069931">PhysicsSystem.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  PHYSICSSYSTEM.H                                                                     */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Jason Wood                                                                  */</P>
<P>/*  Description: Rigid body, constraint based physics system interface                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#if !defined (PHYSICSSYSTEM_H)</P>
<P>#define PHYSICSSYSTEM_H</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct gePhysicsSystem gePhysicsSystem;</P>

<P>////////////////////////////////////////////////////////////////////////////////////////////////////</P>
<P>// ctor / dtor</P>

<P>GENESISAPI gePhysicsSystem *GENESISCC gePhysicsSystem_Create(void);</P>
<P>GENESISAPI geBoolean GENESISCC gePhysicsSystem_Destroy(gePhysicsSystem** ppSys);</P>

<P>GENESISAPI geBoolean GENESISCC gePhysicsSystem_Iterate(gePhysicsSystem* psPtr, float Time);</P>

<P>GENESISAPI geBoolean GENESISCC gePhysicsSystem_AddJoint(gePhysicsSystem *psPtr, gePhysicsJoint *Joint);</P>
<P>GENESISAPI geBoolean GENESISCC gePhysicsSystem_AddObject(gePhysicsSystem *psPtr, gePhysicsObject *Object);</P>

<P>GENESISAPI int GENESISCC gePhysicsSystem_GetSourceConfigIndex(const gePhysicsSystem* pSys);</P>
<P>GENESISAPI gePhysicsObject** GENESISCC gePhysicsSystem_GetPhysobs(const gePhysicsSystem* pSys);</P>
<P>GENESISAPI gePhysicsJoint** GENESISCC gePhysicsSystem_GetPhysjnts(const gePhysicsSystem* pSys);</P>
<P>GENESISAPI int GENESISCC gePhysicsSystem_GetNumPhysobs(const gePhysicsSystem* pSys);</P>
<P>GENESISAPI int GENESISCC gePhysicsSystem_GetNumPhysjnts(const gePhysicsSystem* pSys);</P>
<P>GENESISAPI int GENESISCC gePhysicsSystem_GetSumOfConstraintDimensions(const gePhysicsSystem* pSys);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558915"><A NAME="_Toc454069932">Pixelformat.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>#ifndef&#9;PIXELFORMAT_H</P>
<P>#define&#9;PIXELFORMAT_H</P>

<P>/****************************************************************************************/</P>
<P>/*  PixelFormat.h                                                                       */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description:  The abstract Pixel primitives                                         */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#include "basetype.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef enum&#9;&#9;// all supported formats (including shifts)</P>
<P>{</P>
<P>&#9;GE_PIXELFORMAT_NO_DATA = 0,</P>
<P>&#9;GE_PIXELFORMAT_8BIT,&#9;&#9;&#9;&#9;// PAL</P>
<P>&#9;GE_PIXELFORMAT_8BIT_GRAY,&#9;&#9;// no palette (intensity from bit value)</P>
<P>&#9;GE_PIXELFORMAT_16BIT_555_RGB,</P>
<P>&#9;GE_PIXELFORMAT_16BIT_555_BGR,</P>
<P>&#9;GE_PIXELFORMAT_16BIT_565_RGB,&#9;// #5</P>
<P>&#9;GE_PIXELFORMAT_16BIT_565_BGR, </P>
<P>&#9;GE_PIXELFORMAT_16BIT_4444_ARGB, // #7</P>
<P>&#9;GE_PIXELFORMAT_16BIT_1555_ARGB, </P>
<P>&#9;GE_PIXELFORMAT_24BIT_RGB,&#9;&#9;// #9</P>
<P>&#9;GE_PIXELFORMAT_24BIT_BGR,</P>
<P>&#9;GE_PIXELFORMAT_24BIT_YUV,&#9;&#9;// * see note below</P>
<P>&#9;GE_PIXELFORMAT_32BIT_RGBX, </P>
<P>&#9;GE_PIXELFORMAT_32BIT_XRGB, </P>
<P>&#9;GE_PIXELFORMAT_32BIT_BGRX, </P>
<P>&#9;GE_PIXELFORMAT_32BIT_XBGR,</P>
<P>&#9;GE_PIXELFORMAT_32BIT_RGBA, </P>
<P>&#9;GE_PIXELFORMAT_32BIT_ARGB,&#9;&#9;// #17</P>
<P>&#9;GE_PIXELFORMAT_32BIT_BGRA, </P>
<P>&#9;GE_PIXELFORMAT_32BIT_ABGR,</P>
<P>&#9;</P>
<P>&#9;GE_PIXELFORMAT_WAVELET,&#9;&#9;&#9;// #20 , Wavelet Compression</P>

<P>&#9;GE_PIXELFORMAT_COUNT</P>
<P>} gePixelFormat;</P>
<P>&#9;</P>
<P>/******</P>

<P>there's something wacked out about these format names :</P>

<P>&#9;for 16 bit &amp; 32 bit , the _RGB or _BGR refers to their order</P>
<P>&#9;&#9;*in the word or dword* ; since we're on intel, this means</P>
<P>&#9;&#9;the bytes in the data file have the *opposite* order !!</P>
<P>&#9;&#9;(for example the 32 bit _ARGB is actually B,G,R,A in raw bytes)</P>
<P>&#9;for 24 bit , the _RGB or _BGR refers to their order in the</P>
<P>&#9;&#9;actual bytes, so that windows bitmaps actually have</P>
<P>&#9;&#9;_RGB order in a dword !!</P>

<P>* YUV : the pixelformat ops here are identical to those of 24bit_RGB ;</P>
<P>&#9;&#9;this is just a place-keeper to notify you that you should to a YUV_to_RGB conversion</P>

<P>*********/</P>

<P>#define GE_PIXELFORMAT_8BIT_PAL GE_PIXELFORMAT_8BIT</P>

<P>typedef uint32&#9;(*gePixelFormat_Composer   )(int R,int G,int B,int A);</P>
<P>typedef void&#9;(*gePixelFormat_Decomposer )(uint32 Pixel,int *R,int *G,int *B,int *A);</P>

<P>typedef void&#9;(*gePixelFormat_ColorGetter)(uint8 **ppData,int *R,int *G,int *B,int *A);</P>
<P>typedef void&#9;(*gePixelFormat_ColorPutter)(uint8 **ppData,int  R,int  G,int  B,int  A);</P>

<P>typedef uint32&#9;(*gePixelFormat_PixelGetter)(uint8 **ppData);</P>
<P>typedef void&#9;(*gePixelFormat_PixelPutter)(uint8 **ppData,uint32 Pixel);</P>

<P>typedef struct gePixelFormat_Operations</P>
<P>{</P>
<P>&#9;uint32&#9;RMask;</P>
<P>&#9;uint32&#9;GMask;</P>
<P>&#9;uint32&#9;BMask;</P>
<P>&#9;uint32&#9;AMask;</P>

<P>&#9;int&#9;&#9;RShift;</P>
<P>&#9;int&#9;&#9;GShift;</P>
<P>&#9;int&#9;&#9;BShift;</P>
<P>&#9;int&#9;&#9;AShift;</P>

<P>&#9;int&#9;&#9;RAdd;</P>
<P>&#9;int&#9;&#9;GAdd;</P>
<P>&#9;int&#9;&#9;BAdd;</P>
<P>&#9;int&#9;&#9;AAdd;</P>

<P>&#9;int&#9;&#9;&#9;BytesPerPel;</P>
<P>&#9;geBoolean&#9;HasPalette;</P>
<P>&#9;char *&#9;&#9;Description;</P>
<P>&#9;</P>
<P>&#9;gePixelFormat_Composer&#9;&#9;ComposePixel;</P>
<P>&#9;gePixelFormat_Decomposer&#9;DecomposePixel;</P>

<P>&#9;gePixelFormat_ColorGetter&#9;GetColor;</P>
<P>&#9;gePixelFormat_ColorPutter&#9;PutColor;</P>

<P>&#9;gePixelFormat_PixelGetter&#9;GetPixel;</P>
<P>&#9;gePixelFormat_PixelPutter&#9;PutPixel;</P>
<P>} gePixelFormat_Operations;</P>

<P>&#9;// the Masks double as boolean "HaveAlpha" .. etc..</P>

<P>GENESISAPI const gePixelFormat_Operations * GENESISCC gePixelFormat_GetOperations( gePixelFormat Format );</P>

<P>&#9;// quick accessors to _GetOps</P>
<P>GENESISAPI geBoolean&#9;GENESISCC gePixelFormat_IsValid(&#9;&#9;gePixelFormat Format);</P>
<P>GENESISAPI unsigned int GENESISCC gePixelFormat_BytesPerPel(&#9;gePixelFormat Format );</P>
<P>GENESISAPI geBoolean&#9;GENESISCC gePixelFormat_HasPalette(&#9;&#9;gePixelFormat Format );</P>
<P>GENESISAPI geBoolean&#9;GENESISCC gePixelFormat_HasAlpha(&#9;&#9;gePixelFormat Format );</P>
<P>GENESISAPI geBoolean&#9;GENESISCC gePixelFormat_HasGoodAlpha(&#9;gePixelFormat Format ); // more than 1 bit of alpha</P>
<P>GENESISAPI const char * GENESISCC gePixelFormat_Description(&#9;gePixelFormat Format );</P>
<P>GENESISAPI geBoolean&#9;GENESISCC gePixelFormat_IsRaw(&#9;&#9;&#9;gePixelFormat Format );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 'Raw' means pixels can be made with the Compose operations</P>

<P>GENESISAPI uint32&#9;&#9;GENESISCC gePixelFormat_ComposePixel(&#9;gePixelFormat Format,int R,int G,int B,int A);</P>
<P>GENESISAPI void&#9;&#9;&#9;GENESISCC gePixelFormat_DecomposePixel(&#9;gePixelFormat Format,uint32 Pixel,int *R,int *G,int *B,int *A);</P>
<P>&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// these four functions move ppData to the next pixel</P>

<P>GENESISAPI void&#9;&#9;&#9;GENESISCC gePixelFormat_GetColor(gePixelFormat Format,uint8 **ppData,int *R,int *G,int *B,int *A);</P>
<P>GENESISAPI void&#9;&#9;&#9;GENESISCC gePixelFormat_PutColor(gePixelFormat Format,uint8 **ppData,int R,int G,int B,int A);</P>

<P>GENESISAPI uint32&#9;&#9;GENESISCC gePixelFormat_GetPixel(gePixelFormat Format,uint8 **ppData);</P>
<P>GENESISAPI void&#9;&#9;&#9;GENESISCC gePixelFormat_PutPixel(gePixelFormat Format,uint8 **ppData,uint32 Pixel);</P>
<P>&#9;</P>
<P>GENESISAPI uint32&#9;&#9;GENESISCC gePixelFormat_ConvertPixel(gePixelFormat Format,uint32 Pixel,gePixelFormat ToFormat);</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558916"><A NAME="_Toc454069933">Quatern.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  QUATERN.H                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige                                                                */</P>
<P>/*  Description: Quaternion mathematical system interface                               */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_QUATERNION_H</P>
<P>#define GE_QUATERNION_H</P>

<P>/***************************************************************************</P>

<P>&#9;The quatern module contains basic support for a quaternion object.</P>

<P>&#9;quaternions are an extension of complex numbers that allows an</P>
<P>&#9;expression for rotation that can be easily interpolated.  geQuaternion_s are also </P>
<P>&#9;more numericaly stable for repeated rotations than matrices.</P>

<P>&#9;</P>
<P>&#9;A quaternion is a 4 element 'vector'  [w,x,y,z] where:</P>

<P>&#9;q = w + xi + yj + zk</P>
<P>&#9;i*i = -1</P>
<P>&#9;j*j = -1</P>
<P>&#9;k*k = -1</P>
<P>&#9;i*j = -j*i = k</P>
<P>&#9;j*k = -k*j = i</P>
<P>&#9;k*i = -i*k = j</P>
<P>&#9;q' (conjugate) = w - xi - yj - zk</P>
<P>&#9;||q|| (magnitude) = sqrt(q*q') = sqrt(w*w + x*x + y*y + z*z)</P>
<P>&#9;unit quaternion ||q|| == 1; this implies  q' == qinverse </P>
<P>&#9;quaternions are associative (q1*q2)*q3 == q1*(q2*q3)</P>
<P>&#9;quaternions are not commutative  q1*q2 != q2*q1</P>
<P>&#9;qinverse (inverse (1/q) ) = q'/(q*q')</P>
<P>&#9;</P>
<P>&#9;q can be expressed by w + xi + yj + zk or [w,x,y,z] </P>
<P>&#9;or as in this implementation (s,v) where s=w, and v=[x,y,z]</P>

<P>&#9;quaternions can represent a rotation.  The rotation is an angle t, around a </P>
<P>&#9;unit vector u.   q=(s,v);  s= cos(t/2);   v= u*sin(t/2).</P>

<P>&#9;quaternions can apply the rotation to a point.  let the point be p [px,py,pz],</P>
<P>&#9;and let P be a quaternion(0,p).  Protated = q*P*qinverse </P>
<P>&#9;( Protated = q*P*q' if q is a unit quaternion)</P>

<P>&#9;concatenation rotations is similar to matrix concatenation.  given two rotations</P>
<P>&#9;q1 and q2,  to rotate by q1, then q2:  let qc = (q2*q1), then the combined </P>
<P>&#9;rotation is given by qc*P*qcinverse (= qc*P*qc' if q is a unit quaternion)</P>

<P>&#9;multiplication: </P>
<P>&#9;q1 = w1 + x1i + y1j + z1k</P>
<P>&#9;q2 = w2 + x2i + y2j + z2k</P>
<P>&#9;q1*q2 = q3 =</P>
<P>&#9;&#9;&#9;(w1*w2 - x1*x2 - y1*y2 - z1*z2)     {w3}</P>
<P>&#9;        (w1*x2 + x1*w2 + y1*z2 - z1*y2)i&#9;{x3}</P>
<P>&#9;&#9;&#9;(w1*y2 - x1*z2 + y1*w2 + z1*x2)j    {y3}</P>
<P>&#9;&#9;&#9;(w1*z2 + x1*y2 + y1*x2 + z1*w2)k&#9;{z3}</P>

<P>&#9;also, </P>
<P>&#9;q1 = (s1,v1) = [s1,(x1,y1,z1)]</P>
<P>&#9;q2 = (s2,v2) = [s2,(x2,y2,z2)]</P>
<P>&#9;q1*q2 = q3&#9;=&#9;(s1*s2 - dot_product(v1,v2),&#9;&#9;&#9;{s3}</P>
<P>&#9;&#9;&#9;&#9;&#9;(s1*v2 + s2*v1 + cross_product(v1,v2))&#9;{v3}</P>

<P>&nbsp;</P>
<P>&#9;interpolation - it is possible (and sometimes reasonable) to interpolate between</P>
<P>&#9;two quaternions by interpolating each component.  This does not quarantee a </P>
<P>&#9;resulting unit quaternion, and will result in an animation with non-linear </P>
<P>&#9;rotational velocity.</P>

<P>&#9;spherical interpolation: (slerp) treat the quaternions as vectors </P>
<P>&#9;find the angle between them (w = arccos(q1 dot q2) ).</P>
<P>&#9;given 0&lt;=t&lt;=1,  q(t) = q1*(sin((1-t)*w)/sin(w) + q2 * sin(t*w)/sin(w).</P>
<P>&#9;since q == -q, care must be taken to rotate the proper way.  </P>

<P>&#9;this implementation uses the notation quaternion q = (quatS,quatV) </P>
<P>&#9;  where quatS is a scalar, and quatV is a 3 element vector.</P>

<P>********************************************/</P>

<P>#include "basetype.h"</P>
<P>#include "xform3d.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct </P>
<P>{</P>
<P>&#9;geFloat&#9;W;</P>
<P>&#9;geFloat   X,Y,Z;</P>
<P>&#9;//geVec3d   QuatV;</P>
<P>} geQuaternion;</P>

<P>&nbsp;</P>
<P>#define&#9;QUATERNION_PI&#9;(GE_PI)</P>

<P>geBoolean GENESISCC geQuaternion_IsValid( const geQuaternion *Q );</P>
<P>&#9;// return GE_TRUE if Q is non null and for has no NAN's in its components</P>

<P>void GENESISCC geQuaternion_Set( geQuaternion *Q, geFloat W, geFloat X, geFloat Y, geFloat Z);</P>
<P>&#9;// set quaternion components.  Doesn't normalize</P>
<P>void GENESISCC geQuaternion_SetVec3d( geQuaternion *Q, geFloat W, const geVec3d *V);</P>
<P>&#9;// set quaternion components.  Doesn't normalize</P>
<P>GENESISAPI void GENESISCC geQuaternion_SetFromAxisAngle(geQuaternion *Q, const geVec3d *Axis, geFloat Theta);</P>
<P>&#9;// set a quaternion from an axis and a rotation around the axis</P>
<P>geBoolean GENESISCC geQuaternion_GetAxisAngle(const geQuaternion *Q, geVec3d *Axis, geFloat *Theta);</P>
<P>&#9;// gets an axis and angle of rotation around the axis from a quaternion</P>
<P>&#9;// returns GE_TRUE if there is an axis.  </P>
<P>&#9;// returns GE_FALSE if there is no axis (and Axis is set to 0,0,0, and Theta is 0)</P>

<P>void GENESISCC geQuaternion_Get( const geQuaternion *Q, </P>
<P>&#9;&#9;&#9;&#9;&#9;geFloat *W, geFloat *X, geFloat *Y, geFloat *Z);</P>
<P>&#9;// get quaternion components into W,X,Y,Z</P>
<P>void GENESISCC geQuaternion_GetVec3d( const geQuaternion *Q, geFloat *W, geVec3d *V);</P>
<P>&#9;// get quaternion components into W and V</P>

<P>void GENESISCC geQuaternion_FromMatrix(</P>
<P>&#9;const geXForm3d&#9;&#9;*RotationMatrix,</P>
<P>&#9;      geQuaternion&#9;*QDest);</P>
<P>&#9;// takes upper 3 by 3 portion of matrix (rotation sub matrix) </P>
<P>&#9;// and generates a quaternion</P>

<P>GENESISAPI void GENESISCC geQuaternion_ToMatrix(</P>
<P>&#9;const geQuaternion&#9;*Q, </P>
<P>&#9;&#9;  geXForm3d&#9;&#9;*RotationMatrixDest);</P>
<P>&#9;// takes a unit quaternion and makes RotationMatrixDest an equivelant rotation xform.</P>
<P>&#9;// (any translation in RotationMatrixDest will be list)</P>

<P>void GENESISCC geQuaternion_Slerp(</P>
<P>&#9;const geQuaternion&#9;&#9;*Q0, </P>
<P>&#9;const geQuaternion&#9;&#9;*Q1, </P>
<P>&#9;geFloat&#9;&#9;&#9;&#9;&#9;T,&#9;&#9;</P>
<P>&#9;geQuaternion&#9;&#9;&#9;*QT);</P>
<P>&#9;// spherical interpolation between q0 and q1.   0&lt;=t&lt;=1 </P>
<P>&#9;// resulting quaternion is 'between' q0 and q1</P>
<P>&#9;// with t==0 being all q0, and t==1 being all q1.</P>
<P>&#9;// returns a quaternion with a positive W - always takes shortest route</P>
<P>&#9;// through the positive W domain.</P>

<P>void GENESISCC geQuaternion_SlerpNotShortest(</P>
<P>&#9;const geQuaternion&#9;&#9;*Q0, </P>
<P>&#9;const geQuaternion&#9;&#9;*Q1, </P>
<P>&#9;geFloat&#9;&#9;&#9;&#9;&#9;T,&#9;&#9;</P>
<P>&#9;geQuaternion&#9;&#9;&#9;*QT);</P>
<P>&#9;// spherical interpolation between q0 and q1.   0&lt;=t&lt;=1 </P>
<P>&#9;// resulting quaternion is 'between' q0 and q1</P>
<P>&#9;// with t==0 being all q0, and t==1 being all q1.</P>

<P>&nbsp;</P>
<P>void GENESISCC geQuaternion_Multiply(</P>
<P>&#9;const geQuaternion&#9;*Q1, </P>
<P>&#9;const geQuaternion&#9;*Q2, </P>
<P>&#9;geQuaternion&#9;&#9;&#9;*QProduct);</P>
<P>&#9;// multiplies q1 * q2, and places the result in q.</P>
<P>&#9;// no failure. &#9;renormalization not automatic</P>

<P>void GENESISCC geQuaternion_Rotate(</P>
<P>&#9;const geQuaternion&#9;*Q, </P>
<P>&#9;const geVec3d       *V, </P>
<P>&#9;geVec3d&#9;&#9;&#9;&#9;*VRotated);</P>
<P>&#9;// Rotates V by the quaternion Q, places the result in VRotated.</P>

<P>geBoolean GENESISCC geQuaternion_IsUnit(const geQuaternion *Q);</P>
<P>&#9;// returns GE_TRUE if q is a unit quaternion.  GE_FALSE otherwise.</P>

<P>GENESISAPI geFloat GENESISCC geQuaternion_Normalize(geQuaternion *Q);</P>
<P>&#9;// normalizes q to be a unit quaternion.  returns original magnitude of q</P>

<P>GENESISAPI void GENESISCC geQuaternion_Copy(const geQuaternion *QSrc, geQuaternion *QDst);</P>
<P>&#9;// copies quaternion QSrc into QDst</P>

<P>void GENESISCC geQuaternion_SetNoRotation(geQuaternion *Q);</P>
<P>&#9;// sets Q to be a quaternion with no rotation (like an identity matrix)</P>

<P>void GENESISCC geQuaternion_Ln(</P>
<P>&#9;const geQuaternion *Q, </P>
<P>&#9;geQuaternion *LnQ);</P>
<P>&#9;// ln(Q) for unit quaternion only!</P>

<P>void GENESISCC geQuaternion_Exp(</P>
<P>&#9;const geQuaternion *Q,</P>
<P>&#9;geQuaternion *ExpQ);</P>
<P>&#9;// exp(Q) for pure quaternion only!  (zero scalar part (W))</P>

<P>void GENESISCC geQuaternion_Scale(</P>
<P>&#9;const geQuaternion *Q,</P>
<P>&#9;geFloat Scale,</P>
<P>&#9;geQuaternion *QScaled);</P>
<P>&#9;// Q = Q * Scale  (result is not generally a unit quaternion!)</P>

<P>void GENESISCC geQuaternion_Add(</P>
<P>&#9;const geQuaternion *Q1,</P>
<P>&#9;const geQuaternion *Q2,</P>
<P>&#9;geQuaternion *QSum);</P>
<P>&#9;// QSum = Q1 + Q2  (result is not generally a unit quaternion!)</P>

<P>void GENESISCC geQuaternion_Subtract(</P>
<P>&#9;const geQuaternion *Q1, </P>
<P>&#9;const geQuaternion *Q2, </P>
<P>&#9;geQuaternion *QSum);</P>
<P>&#9;// QSum = Q1 - Q2  (result is not generally a unit quaternion!)</P>

<P>void GENESISCC geQuaternion_Inverse(const geQuaternion *Q, geQuaternion *QInv);</P>
<P>&#9;// sets QInv to the inverse of Q.  </P>

<P>geFloat GENESISCC geQuaternion_Magnitude(const geQuaternion *Q);</P>
<P>&#9;// returns Magnitude of Q.  </P>

<P>geBoolean GENESISCC geQuaternion_Compare( geQuaternion *Q1, geQuaternion *Q2, geFloat Tolerance );</P>
<P>&#9;// return GE_TRUE if quaternions differ elementwise by less than Tolerance.</P>

<P>&nbsp;</P>
<P>#ifndef NDEBUG</P>
<P>void GENESISCC geQuaternion_SetMaximalAssertionMode( geBoolean Enable );</P>
<P>#endif</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif // GE_QUATERNION_H</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558917"></P>
<P><A NAME="_Toc454069934">Ram.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  RAM.H                                                                               */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:                                                                             */</P>
<P>/*  Description: Replacement for malloc, realloc and free                               */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_RAM_H</P>
<P>#define GE_RAM_H</P>

<P>#include "basetype.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef int (* geRam_CriticalCallbackFunction)(void);</P>

<P>/*</P>
<P>  Set the critical callback function.  ram_allocate will call the critical</P>
<P>  callback function if it's unable to allocate memory.</P>
<P>*/</P>
<P>GENESISAPI geRam_CriticalCallbackFunction geRam_SetCriticalCallback</P>
<P>    (</P>
<P>      geRam_CriticalCallbackFunction callback</P>
<P>    );</P>

<P>/*</P>
<P>  increments or decrements a counter .  if the counter is &gt;0</P>
<P>  the critical callback function (if set) is called for a failed memory allocation.</P>
<P>  add is added to the current counter value.  the new counter value is returned.</P>
<P>*/</P>
<P>GENESISAPI int geRam_EnableCriticalCallback(int add);</P>

<P>&nbsp;</P>
<P>/*</P>
<P>  Allocate memory of the given size.  In debug mode, the memory is filled</P>
<P>  with 0xA5, and we keep track of the amount of memory allocated.  Also, in debug</P>
<P>  mode, we track where the memory was allocated and can optionally provide a</P>
<P>  report of allocated blocks.  See geRam_ReportAllocations.</P>
<P>*/</P>
<P>#ifndef NDEBUG</P>

<P>#define geRam_Allocate(size) _geRam_DebugAllocate(size, __FILE__, __LINE__)</P>

<P>// Do not call _geRam_DebugAllocate directly.</P>
<P>GENESISAPI void* _geRam_DebugAllocate(uint32 size, const char* pFile, int line);</P>

<P>#else</P>

<P>GENESISAPI void *geRam_Allocate(uint32 size);</P>

<P>#endif</P>

<P>/*</P>
<P>  Free an allocated memory block.</P>
<P>*/</P>
<P>GENESISAPI void geRam_Free_(void *ptr);</P>

<P>&#9;&#9;extern void *StupidUnusedPointer;    // never used, except to mask the</P>
<P>&#9;&#9;// possible warning you get if you use the geRam_Free macro below, without</P>
<P>&#9;&#9;// using the xxx pointer again in the same block.  This is ugly.</P>
<P> </P>
<P>#define geRam_Free(xxx) geRam_Free_(xxx) ,(xxx)=NULL, StupidUnusedPointer=(xxx)</P>

<P>/*</P>
<P>  Reallocate memory.  This function supports shrinking and expanding blocks,</P>
<P>  and will also act like ram_allocate if the pointer passed to it is NULL.</P>
<P>  It won't, however, free the memory if you pass it a 0 size.</P>
<P>*/</P>
<P>#ifndef NDEBUG</P>

<P>#define geRam_Realloc(ptr, newsize) _geRam_DebugRealloc(ptr, newsize, __FILE__, __LINE__)</P>

<P>// Do not call _geRam_DebugRealloc directly.</P>
<P>GENESISAPI void* _geRam_DebugRealloc(void* ptr, uint32 size, const char* pFile, int line);</P>

<P>#else</P>

<P>GENESISAPI void *geRam_Realloc(void *ptr,uint32 newsize);</P>

<P>#endif</P>

<P>#ifndef NDEBUG</P>

<P>GENESISAPI void geRam_ReportAllocations(void);</P>

<P>#else</P>

<P>#define geRam_ReportAllocations() </P>

<P>#endif</P>

<P>#ifndef NDEBUG</P>
<P>    extern int32 geRam_CurrentlyUsed;</P>
<P>    extern int32 geRam_NumberOfAllocations;</P>
<P>    extern int32 geRam_MaximumUsed;</P>
<P>    extern int32 geRam_MaximumNumberOfAllocations;</P>

<P>GENESISAPI     void geRam_AddAllocation(int n,uint32 size);</P>
<P>#else</P>
<P>    #define geRam_AddAllocation(n,s)</P>
<P>#endif</P>

<P>// allocate the ram &amp; clear it. (calloc)</P>
<P>GENESISAPI void * geRam_AllocateClear(uint32 size);</P>

<P>#define GE_RAM_ALLOCATE_STRUCT(type)      (type *)geRam_Allocate (sizeof (type))</P>
<P>#define GE_RAM_ALLOCATE_ARRAY(type,count) (type *)geRam_Allocate (sizeof (type) * (count))</P>

<P>#ifndef NDEBUG</P>
<P>#define GE_RAM_REALLOC_ARRAY(ptr,type,count)  (type *)geRam_Realloc(  (ptr), sizeof(type) * (count) );{type *XX=(ptr);}</P>
<P>#else</P>
<P>#define GE_RAM_REALLOC_ARRAY(ptr,type,count)  (type *)geRam_Realloc(  (ptr), sizeof(type) * (count) )</P>
<P>#endif</P>

<P>#ifndef NDEBUG</P>
<P>geBoolean geRam_IsValidPtr(void *ptr);</P>
<P>#endif</P>

<P>#ifdef __cplusplus</P>
<P>  }</P>
<P>#endif</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558918"><A NAME="_Toc454069935">Vec3d.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  VEC3D.H                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:                                                                             */</P>
<P>/*  Description: 3D Vector interface                                                    */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_VEC3D_H</P>
<P>#define GE_VEC3D_H</P>

<P>#include "basetype.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;geFloat X, Y, Z;</P>
<P>} geVec3d;</P>

<P>#ifndef NDEBUG</P>
<P>GENESISAPI&#9;geFloat GENESISCC   geVec3d_GetElement(geVec3d *V, int Index);</P>
<P>#else</P>
<P>&#9;#define geVec3d_GetElement(Vector,Index)  (* ((&amp;((Vector)-&gt;X)) +  (Index) ))</P>
<P>#endif</P>

<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Set(geVec3d *V, geFloat X, geFloat Y, geFloat Z);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Get(const geVec3d *V, geFloat *X, geFloat *Y, geFloat *Z);</P>

<P>GENESISAPI geFloat GENESISCC&#9;geVec3d_DotProduct(const geVec3d *V1, const geVec3d *V2);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_CrossProduct(const geVec3d *V1, const geVec3d *V2, geVec3d *VResult);</P>
<P>GENESISAPI geBoolean GENESISCC&#9;geVec3d_Compare(const geVec3d *V1, const geVec3d *V2,geFloat tolarance);</P>
<P>GENESISAPI geFloat GENESISCC&#9;geVec3d_Normalize(geVec3d *V1);</P>
<P>GENESISAPI geBoolean GENESISCC &#9;geVec3d_IsNormalized(const geVec3d *V);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Scale(const geVec3d *VSrc, geFloat Scale, geVec3d *VDst);</P>
<P>GENESISAPI geFloat GENESISCC&#9;geVec3d_Length(const geVec3d *V1); </P>
<P>GENESISAPI geFloat GENESISCC&#9;geVec3d_LengthSquared(const geVec3d *V1);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Subtract(const geVec3d *V1, const geVec3d *V2, geVec3d *V1MinusV2);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Add(const geVec3d *V1, const geVec3d *V2,  geVec3d *VSum);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Copy(const geVec3d *Vsrc, geVec3d *Vdst);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Clear(geVec3d *V);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Inverse(geVec3d *V);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_MA(geVec3d *V1, geFloat Scale, const geVec3d *V2, geVec3d *V1PlusV2Scaled);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_AddScaled(const geVec3d *V1, const geVec3d *V2, geFloat Scale, geVec3d *V1PlusV2Scaled);</P>

<P>GENESISAPI geFloat GENESISCC&#9;&#9;geVec3d_DistanceBetween(const geVec3d *V1, const geVec3d *V2);&#9;// returns length of V1-V2&#9;</P>

<P>GENESISAPI geBoolean GENESISCC geVec3d_IsValid(const geVec3d *V);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558919"><A NAME="_Toc454069936">Vfile.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  VFILE.H                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Eli Boling                                                                  */</P>
<P>/*  Description: Virtual file interface                                                 */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef&#9;VFILE_H</P>
<P>#define&#9;VFILE_H</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#include&#9;"basetype.h"</P>

<P>typedef&#9;struct&#9;geVFile&#9;&#9;&#9;geVFile;</P>

<P>//--------- Finder (Directory) --------------</P>
<P>typedef&#9;struct&#9;geVFile_Finder&#9;geVFile_Finder;</P>

<P>typedef int     &#9;&#9;geVFile_TypeIdentifier;</P>
<P>typedef unsigned int    geVFile_Attributes;</P>

<P>typedef struct&#9;geVFile_Hints</P>
<P>{</P>
<P>&#9;void *&#9;HintData;</P>
<P>&#9;int&#9;&#9;HintDataLength;</P>
<P>}&#9;geVFile_Hints;</P>

<P>typedef&#9;struct&#9;geVFile_Time</P>
<P>{</P>
<P>&#9;unsigned long&#9;Time1;</P>
<P>&#9;unsigned long&#9;Time2;</P>
<P>}&#9;geVFile_Time;</P>

<P>#define&#9;GE_VFILE_ATTRIB_READONLY&#9;0x00000001</P>
<P>#define&#9;GE_VFILE_ATTRIB_DIRECTORY&#9;0x00000002</P>

<P>typedef&#9;struct&#9;geVFile_Properties</P>
<P>{</P>
<P>&#9;geVFile_Time&#9;&#9;&#9;&#9;Time;</P>
<P>&#9;geVFile_Attributes&#9;&#9;AttributeFlags;</P>
<P>&#9;long&#9;&#9;&#9;&#9;&#9;Size;</P>
<P>&#9;geVFile_Hints&#9;&#9;&#9;&#9;Hints;</P>
<P>&#9;char&#9;&#9;&#9;&#9;&#9;Name[1024];</P>
<P>}&#9;geVFile_Properties;</P>

<P>#ifdef _INC_WINDOWS</P>
<P>GENESISAPI void GENESISCC geVFile_TimeToWin32FileTime(const geVFile_Time *, LPFILETIME Win32FileTime);</P>
<P>&#9;// Converts a geVFile time to a Win32 FILETIME structure.  This API is the</P>
<P>&#9;// way to get the file time into a format to do standardized date/time</P>
<P>&#9;// operations on.  We do not provide date/time operations natively.</P>
<P>#endif</P>

<P>GENESISAPI geVFile_Finder * GENESISCC geVFile_CreateFinder(</P>
<P>&#9;geVFile *&#9;&#9;FileSystem,</P>
<P>&#9;const char *&#9;FileSpec);</P>
<P>&#9;// Creates a finder object from which you can get iterated file names.</P>
<P>&#9;// This is findfirst/findnext functionality.  </P>

<P>GENESISAPI void GENESISCC geVFile_DestroyFinder(geVFile_Finder *Finder);</P>
<P>&#9;// Destroys a Finder object</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_FinderGetNextFile(geVFile_Finder *Finder);</P>
<P>&#9;// Tracks to the next file in the finder directory</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_FinderGetProperties(const geVFile_Finder *Finder, geVFile_Properties *Properties);</P>
<P>&#9;// Gets the file properties from a geVFile_Finder.  You cannot set properties for</P>
<P>&#9;// a file through a finder.  You have to set the properties through a geVFile.</P>

<P>//--------- File System Operations ----</P>

<P>typedef&#9;struct&#9;geVFile_MemoryContext</P>
<P>{</P>
<P>&#9;void *&#9;Data;</P>
<P>&#9;int&#9;&#9;DataLength;</P>
<P>}&#9;geVFile_MemoryContext;</P>

<P>#define GE_VFILE_TYPE_DOS&#9;    ( (geVFile_TypeIdentifier) 1L )</P>
<P>#define GE_VFILE_TYPE_MEMORY&#9;( (geVFile_TypeIdentifier) 2L )</P>
<P>#define GE_VFILE_TYPE_VIRTUAL&#9;( (geVFile_TypeIdentifier) 3L )</P>

<P>// First three flags are mutually exclusive.  Combining them will result in failure</P>
<P>// returns for both geVFile_OpenNewSystem and geVFile_Open.</P>
<P>#define&#9;GE_VFILE_OPEN_READONLY&#9; 0x00000001</P>
<P>#define&#9;GE_VFILE_OPEN_UPDATE &#9; 0x00000002</P>
<P>#define&#9;GE_VFILE_OPEN_CREATE&#9; 0x00000004</P>

<P>#define GE_VFILE_OPEN_DIRECTORY  0x00000008</P>

<P>#if 0</P>
<P>geBoolean GENESISCC&#9;geVFile_Startup(void);</P>
<P>&#9;// Initializes the VFile System.  This API MUST be called before any other</P>
<P>&#9;// VFile APIs are called.  This API ensures that the rest of the VFile systems</P>
<P>&#9;// will be thread safe.  Hence the application should ensure that this function</P>
<P>&#9;// is called once and only once.</P>
<P>#endif</P>

<P>GENESISAPI geVFile * GENESISCC geVFile_OpenNewSystem(</P>
<P>&#9;geVFile *&#9;&#9;&#9;&#9;&#9;FS,</P>
<P>&#9;geVFile_TypeIdentifier&#9;FileSystemType,  // { DOS, MEMORY, ETC ... },</P>
<P>&#9;const char *&#9;&#9;&#9;Name, </P>
<P>&#9;void *&#9;&#9;&#9;&#9;&#9;Context, </P>
<P>&#9;unsigned int &#9;&#9;&#9;OpenModeFlags);</P>
<P>&#9;// Opens a file / file system.</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_UpdateContext(geVFile *FS, void *Context, int ContextSize);</P>

<P>GENESISAPI geVFile * GENESISCC geVFile_GetContext(const geVFile *File);</P>
<P>&#9;// Returns the outer context in which File was opened.</P>

<P>GENESISAPI geVFile * GENESISCC geVFile_Open( </P>
<P>&#9;geVFile *&#9;&#9;&#9;FS,</P>
<P>&#9;const char *&#9;Name, </P>
<P>&#9;unsigned int &#9;OpenModeFlags);</P>

<P>/*</P>
<P>typedef&#9;enum</P>
<P>{</P>
<P>&#9;geVFile_AppendPath,</P>
<P>&#9;geVFile_PrependPath,</P>
<P>}&#9;geVFile_SearchOrder;</P>
<P>*/</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_AddPath(geVFile *FS1, const geVFile *FS2, geBoolean Append);</P>
<P>&#9;// Appends (or prepends) the path associated with FS2 into FS1.</P>
<P>&#9;//    Append==GE_TRUE   causes the FS2 to be searched AFTER FS1</P>
<P>&#9;//    Append==GE_FALSE  causes the FS2 to be searched BEFORE FS1</P>

<P>/*  perhaps geVFile_AppendPath and geVFile_PrependPath */</P>

<P>&nbsp;</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_DeleteFile(geVFile *FS, const char *FileName);</P>
<P>&#9;// Deletes a file within a file system.  Returns GE_TRUE on success, GE_FALSE</P>
<P>&#9;// on failure.</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_RenameFile(geVFile *FS, const char *FileName, const char *NewName);</P>
<P>&#9;// Renames a file within a file system.  Returns GE_TRUE on success, GE_FALSE</P>
<P>&#9;// on failure.</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_FileExists(geVFile *FS, const char *FileName);</P>
<P>&#9;// Returns GE_TRUE if the file FileName exists in FS, GE_FALSE otherwise.</P>
<P>&#9;// Does not do any searching (?)</P>

<P>//geVFile_VFileType geVFile_Register( all kinds of stuff );</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_Close (geVFile *File);</P>
<P>&#9;// closes and destroys the File</P>

<P>//---------- File Specific Operations -----------</P>

<P>typedef&#9;enum</P>
<P>{</P>
<P>&#9;GE_VFILE_SEEKCUR&#9;= 0,</P>
<P>&#9;GE_VFILE_SEEKEND&#9;= 1,</P>
<P>&#9;GE_VFILE_SEEKSET&#9;= 2</P>
<P>}&#9;geVFile_Whence;</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_GetS  &#9;&#9; (&#9;&#9;geVFile *File, void *Buff, int MaxLen);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_Read  &#9;&#9; (&#9;&#9;geVFile *File, void *Buff, int Count);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_Write &#9;&#9; (&#9;&#9;geVFile *File, const void *Buff, int Count);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_Seek  &#9;&#9; (&#9;&#9;geVFile *File, int where, geVFile_Whence Whence);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_Printf&#9;&#9; (&#9;&#9;geVFile *File, const char *Format, ...);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_EOF   &#9;&#9; (const geVFile *File);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_Tell  &#9;&#9; (const geVFile *File, long *Position);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_GetProperties(const geVFile *File, geVFile_Properties *Properties);</P>
<P>//geBoolean geVFile_GetName(geVFile *File, char *Buff, int MaxBuffLen);</P>
<P>&#9;// Gets the name of the file</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_Size  &#9;&#9; (const geVFile *File, long *Size);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_SetSize&#9;&#9; (&#9;&#9;geVFile *File, long Size);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_SetAttributes(&#9;&#9;geVFile *File, geVFile_Attributes Attributes);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_SetTime&#9;&#9; (&#9;&#9;geVFile *File, const geVFile_Time *Time);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_SetHints&#9; (&#9;&#9;geVFile *File, const geVFile_Hints *Hints);</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558920"><A NAME="_Toc454069937">Xform3d.h</A></A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  XFORM3D.H                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:                                                                             */</P>
<P>/*  Description: 3D transform interface                                                 */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_XFORM_H</P>
<P>#define GE_XFORM_H</P>

<P>&nbsp;</P>
<P>#include "Vec3d.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct</P>
<P>{&#9;</P>
<P>&#9;geFloat AX,AY,AZ;&#9;// e[0][0],e[0][1],e[0][2]</P>
<P>&#9;geFloat BX,BY,BZ;&#9;// e[1][0],e[1][1],e[1][2]</P>
<P>&#9;geFloat CX,CY,CZ;&#9;// e[2][0],e[2][1],e[2][2]</P>
<P>&#9;geVec3d Translation;  // e[0][3],e[1][3],e[2][3]</P>
<P>&#9;//&#9;  0,0,0,1&#9;&#9;// e[3][0],e[3][1],e[3][2]</P>
<P>} geXForm3d;</P>

<P>/*   this is essentially a 'standard' 4x4 transform matrix,</P>
<P>     with the bottom row always 0,0,0,1</P>

<P>&#9;| AX, AY, AZ, Translation.X |  </P>
<P>&#9;| BX, BY, BZ, Translation.Y |  </P>
<P>&#9;| CX, CY, CZ, Translation.Z |  </P>
<P>&#9;|  0,  0,  0,      1        |  </P>
<P>*/</P>

<P>//  all geXForm3d_Set* functions return a right-handed transform.</P>

<P>#define GEXFORM3D_MINIMUM_SCALE (0.00001f)</P>

<P>&nbsp;</P>
<P>GENESISAPI void GENESISCC geXForm3d_Copy(</P>
<P>&#9;const geXForm3d *Src, </P>
<P>&#9;geXForm3d *Dst);</P>
<P>&#9;// copies Src to Dst.  </P>

<P>GENESISAPI geBoolean GENESISCC geXForm3d_IsValid(const geXForm3d *M);</P>
<P>&#9;// returns GE_TRUE if M is 'valid'  </P>
<P>&#9;// 'valid' means that M is non NULL, and there are no NAN's in the matrix.</P>

<P>GENESISAPI geBoolean GENESISCC geXForm3d_IsOrthonormal(const geXForm3d *M);</P>
<P>&#9;// returns GE_TRUE if M is orthonormal </P>
<P>&#9;// (if the rows and columns are all normalized (transform has no scaling or shearing)</P>
<P>&#9;// and is orthogonal (row1 cross row2 = row3 &amp; col1 cross col2 = col3)</P>
<P>&#9;// * does not check for right-handed convention *</P>

<P>GENESISAPI geBoolean GENESISCC geXForm3d_IsOrthogonal(const geXForm3d *M);</P>
<P>&#9;// returns GE_TRUE if M is orthogonal</P>
<P>&#9;// (row1 cross row2 = row3 &amp; col1 cross col2 = col3)</P>
<P>&#9;// * does not check for right-handed convention *</P>

<P>GENESISAPI void GENESISCC geXForm3d_Orthonormalize(geXForm3d *M);</P>
<P>&#9;// essentially removes scaling (or other distortions) from </P>
<P>&#9;// an orthogonal (or nearly orthogonal) matrix </P>
<P>&#9;// returns a right-handed matrix</P>

<P>&nbsp;</P>
<P>GENESISAPI void GENESISCC geXForm3d_SetIdentity(geXForm3d *M);&#9;&#9;&#9;</P>
<P>&#9;// sets M to an identity matrix (clears it)</P>
<P>&#9;</P>
<P>GENESISAPI void GENESISCC geXForm3d_SetXRotation(geXForm3d *M,geFloat RadianAngle);</P>
<P>&#9;// sets up a transform that rotates RadianAngle about X axis</P>
<P>&#9;// all existing contents of M are replaced</P>
<P>&#9;</P>
<P>GENESISAPI void GENESISCC geXForm3d_SetYRotation(geXForm3d *M,geFloat RadianAngle);</P>
<P>&#9;// sets up a transform that rotates RadianAngle about Y axis</P>
<P>&#9;// all existing contents of M are replaced</P>

<P>GENESISAPI void GENESISCC geXForm3d_SetZRotation(geXForm3d *M,geFloat RadianAngle);</P>
<P>&#9;// sets up a transform that rotates RadianAngle about Z axis</P>
<P>&#9;// all existing contents of M are replaced</P>

<P>GENESISAPI void GENESISCC geXForm3d_SetTranslation(geXForm3d *M,geFloat x, geFloat y, geFloat z);</P>
<P>&#9;// sets up a transform that translates x,y,z</P>
<P>&#9;// all existing contents of M are replaced</P>

<P>GENESISAPI void GENESISCC geXForm3d_SetScaling(geXForm3d *M,geFloat x, geFloat y, geFloat z);</P>
<P>&#9;// sets up a transform that scales by x,y,z</P>
<P>&#9;// all existing contents of M are replaced</P>

<P>GENESISAPI void GENESISCC geXForm3d_RotateX(geXForm3d *M,geFloat RadianAngle);  </P>
<P>&#9;// Rotates M by RadianAngle about X axis   </P>
<P>&#9;// applies the rotation to the existing contents of M</P>

<P>GENESISAPI void GENESISCC geXForm3d_RotateY(geXForm3d *M,geFloat RadianAngle);</P>
<P>&#9;// Rotates M by RadianAngle about Y axis</P>
<P>&#9;// applies the rotation to the existing contents of M</P>

<P>GENESISAPI void GENESISCC geXForm3d_RotateZ(geXForm3d *M,geFloat RadianAngle);</P>
<P>&#9;// Rotates M by RadianAngle about Z axis</P>
<P>&#9;// applies the rotation to the existing contents of M</P>

<P>GENESISAPI void GENESISCC geXForm3d_Translate(geXForm3d *M,geFloat x, geFloat y, geFloat z);&#9;</P>
<P>&#9;// Translates M by x,y,z</P>
<P>&#9;// applies the translation to the existing contents of M</P>

<P>GENESISAPI void GENESISCC geXForm3d_Scale(geXForm3d *M,geFloat x, geFloat y, geFloat z);&#9;&#9;</P>
<P>&#9;// Scales M by x,y,z</P>
<P>&#9;// applies the scale to the existing contents of M</P>

<P>GENESISAPI void GENESISCC geXForm3d_Multiply(</P>
<P>&#9;const geXForm3d *M1, </P>
<P>&#9;const geXForm3d *M2, </P>
<P>&#9;geXForm3d *MProduct);</P>
<P>&#9;// MProduct = matrix multiply of M1*M2</P>
<P>&#9;// Concatenates the transformation in the M2 matrix onto the transformation in M1</P>

<P>GENESISAPI void GENESISCC geXForm3d_Transform(</P>
<P>&#9;const geXForm3d *M,</P>
<P>&#9;const geVec3d *V, </P>
<P>&#9;geVec3d *Result);</P>
<P>&#9;// Result is Matrix M * Vector V:  V Tranformed by M</P>

<P>GENESISAPI void GENESISCC geXForm3d_TransformArray(&#9;const geXForm3d *XForm, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Source, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *Dest, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 Count);</P>

<P>GENESISAPI void GENESISCC geXForm3d_Rotate(</P>
<P>&#9;const geXForm3d *M,</P>
<P>&#9;const geVec3d *V, </P>
<P>&#9;geVec3d *Result);</P>
<P>&#9;// Result is Matrix M * Vector V:  V Rotated by M (no translation)</P>

<P>&nbsp;</P>
<P>/***</P>
<P>*</P>
<P>&#9;"Left,Up,In" are just the basis vectors in the new coordinate space.</P>
<P>&#9;You can get them by multiplying the unit bases into the transforms.</P>
<P>*</P>
<P>******/</P>

<P>GENESISAPI void GENESISCC geXForm3d_GetLeft(const geXForm3d *M, geVec3d *Left);</P>
<P>&#9;// Gets a vector that is 'left' in the frame of reference of M (facing -Z)</P>

<P>GENESISAPI void GENESISCC geXForm3d_GetUp(const geXForm3d *M,    geVec3d *Up);</P>
<P>&#9;// Gets a vector that is 'up' in the frame of reference of M (facing -Z)</P>

<P>GENESISAPI void GENESISCC geXForm3d_GetIn(const geXForm3d *M,  geVec3d *In);</P>
<P>&#9;// Gets a vector that is 'in' in the frame of reference of M (facing -Z)</P>

<P>GENESISAPI void GENESISCC geXForm3d_GetTranspose(const geXForm3d *M, geXForm3d *MTranspose);</P>
<P>&#9;// Gets the Transpose transform of M   (M^T) </P>
<P>&#9;// Transpose of a matrix is the switch of the rows and columns</P>
<P>&#9;// The transpose is usefull because it is rapidly computed and is equal to the inverse </P>
<P>&#9;// transform for orthonormal transforms    [inverse is (M')  where M*M' = Identity ]</P>

<P>GENESISAPI void GENESISCC geXForm3d_TransposeTransform(</P>
<P>&#9;const geXForm3d *M, </P>
<P>&#9;const geVec3d *V, </P>
<P>&#9;geVec3d *Result);</P>
<P>&#9;// applies the transpose transform of M to V.  Result = (M^T) * V</P>

<P>/*****</P>
<P>*</P>
<P>&#9;the Euler angles are subsequent rotations :</P>
<P>&#9;&#9;by Angles-&gt;Z around the Z axis</P>
<P>&#9;&#9;then by Angles-&gt;Y around the Y axis, in the newly rotate coordinates</P>
<P>&#9;&#9;then by Angles-&gt;X around the X axis</P>
<P>*</P>
<P>******/&#9;</P>

<P>GENESISAPI void GENESISCC geXForm3d_GetEulerAngles(const geXForm3d *M, geVec3d *Angles);</P>
<P>&#9;// Finds Euler angles from M and puts them into Angles</P>
<P>&#9;</P>
<P>GENESISAPI void GENESISCC geXForm3d_SetEulerAngles(geXForm3d *M, const geVec3d *Angles);</P>
<P>&#9;// Applies Euler angles to build M</P>

<P>GENESISAPI void GENESISCC geXForm3d_SetFromLeftUpIn(</P>
<P>&#9;geXForm3d *M,</P>
<P>&#9;const geVec3d *Left, </P>
<P>&#9;const geVec3d *Up, </P>
<P>&#9;const geVec3d *In);</P>
<P>&#9;// Builds an geXForm3d from orthonormal Left, Up and In vectors</P>

<P>GENESISAPI void GENESISCC geXForm3d_Mirror(</P>
<P>&#9;const&#9;&#9;geXForm3d *Source, </P>
<P>&#9;const&#9;&#9;geVec3d *PlaneNormal, </P>
<P>&#9;float&#9;&#9;PlaneDist, </P>
<P>&#9;geXForm3d&#9;*Dest);</P>
<P>&#9;// Mirrors a XForm3d about a plane</P>

<P>&nbsp;</P>
<P>//--------------</P>

<P>#ifndef NDEBUG</P>
<P>&#9;GENESISAPI &#9;void GENESISCC geXForm3d_SetMaximalAssertionMode( geBoolean Enable );</P>
<P>#else</P>
<P>&#9;#define geXForm3d_SetMaximalAssertionMode(Enable)</P>
<P>#endif</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc446558921"><A NAME="_Toc454069938">OpenSource/Source Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>The header files in this subdirectory and the next sixteen subdirectories following it comprise the links necessary to create the Genesis3D engine.  These are the include files you need in order to create the libraries and drivers provided by Eclipse as the Genesis3D game engine.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069939">Camera.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Camera.h                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard/Charles Bloom                                                  */</P>
<P>/*  Description: Creation/Transformation/projection code for a camera                   */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_CAMERA_H</P>
<P>#define GE_CAMERA_H</P>

<P>#include "BaseType.h"</P>
<P>#include "Vec3d.h"</P>
<P>#include "XForm3d.h"</P>
<P>#include "GETypes.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//================================================================================</P>
<P>//&#9;Structure defines</P>
<P>//================================================================================</P>
<P>typedef struct geCamera geCamera;</P>

<P>&nbsp;</P>
<P>//================================================================================</P>
<P>//&#9;Function ProtoTypes</P>
<P>//================================================================================</P>
<P>GENESISAPI geCamera *GENESISCC geCamera_Create(geFloat Fov, const geRect *Rect);</P>
<P>GENESISAPI void GENESISCC geCamera_Destroy(geCamera **pCamera);</P>
<P>GENESISAPI void GENESISCC geCamera_SetZScale(geCamera *Camera, geFloat ZScale);</P>
<P>GENESISAPI geFloat GENESISCC geCamera_GetZScale(const geCamera *Camera);</P>
<P>GENESISAPI void GENESISCC geCamera_GetClippingRect(const geCamera *Camera, geRect *Rect);</P>
<P>void GENESISCC geCamera_GetWidthHeight(const geCamera *Camera,geFloat *Width,geFloat *Height);</P>
<P>float GENESISCC geCamera_GetScale(const geCamera *Camera);</P>
<P>GENESISAPI void GENESISCC geCamera_SetAttributes(geCamera *Camera, geFloat Fov, const geRect *Rect);</P>
<P>void geCamera_FillDriverInfo(geCamera *Camera);</P>
<P>GENESISAPI void GENESISCC geCamera_ScreenPointToWorld (&#9;const geCamera&#9;*Camera,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32&#9;&#9;&#9; ScreenX,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32&#9;&#9;&#9; ScreenY,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d&#9;&#9;&#9;*Vector);</P>
<P>GENESISAPI void GENESISCC geCamera_Project(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *PointInCameraSpace, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *ProjectedPoint);</P>
<P>GENESISAPI void GENESISCC geCamera_ProjectZ(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *PointInCameraSpace, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *ProjectedPoint);</P>
<P>void GENESISCC geCamera_ProjectAndClamp(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *PointInCameraSpace, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *ProjectedPoint);</P>
<P>void GENESISCC geCamera_GetViewAngleXSinCos( const geCamera *Camera, geFloat *SinAngle, geFloat *CosAngle );</P>
<P>void GENESISCC geCamera_GetViewAngleYSinCos( const geCamera *Camera, geFloat *SinAngle, geFloat *CosAngle );</P>
<P>GENESISAPI void GENESISCC geCamera_Transform(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *WorldSpacePoint, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;      geVec3d *CameraSpacePoint);</P>
<P>GENESISAPI void GENESISCC geCamera_TransformArray(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *WorldSpacePointPtr, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;      geVec3d *CameraSpacePointPtr, int count);</P>
<P>GENESISAPI void GENESISCC geCamera_TransformAndProjectArray(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *WorldSpacePointPtr, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;      geVec3d *ProjectedSpacePointPtr, int count);</P>
<P>GENESISAPI void GENESISCC geCamera_TransformAndProjectLArray(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const GE_LVertex *WorldSpacePointPtr, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;      GE_TLVertex *ProjectedSpacePointPtr, int count);</P>
<P>GENESISAPI void GENESISCC geCamera_TransformAndProject(const geCamera *Camera,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Point, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *ProjectedPoint);</P>
<P>GENESISAPI void GENESISCC geCamera_TransformAndProjectL(const geCamera *Camera,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const GE_LVertex *Point, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_TLVertex *ProjectedPoint);</P>

<P>GENESISAPI geBoolean GENESISCC geCamera_SetWorldSpaceXForm(geCamera *Camera, const geXForm3d *XForm);</P>
<P>GENESISAPI geBoolean GENESISCC geCamera_SetWorldSpaceVisXForm(geCamera *Camera, const geXForm3d *XForm);</P>
<P>GENESISAPI const geXForm3d * GENESISCC geCamera_GetWorldSpaceXForm( const geCamera *Camera);</P>
<P>const geXForm3d * GENESISCC geCamera_GetCameraSpaceXForm( const geCamera *Camera);</P>
<P>GENESISAPI const geXForm3d * GENESISCC geCamera_GetCameraSpaceVisXForm( const geCamera *Camera);</P>
<P>GENESISAPI const geXForm3d * GENESISCC geCamera_GetWorldSpaceVisXForm( const geCamera *Camera);</P>
<P>const geVec3d *GENESISCC geCamera_GetPov(const geCamera *Camera);</P>
<P>const geVec3d *GENESISCC geCamera_GetVisPov(const geCamera *Camera);</P>
<P>GENESISAPI geBoolean GENESISCC geCamera_ConvertWorldSpaceToCameraSpace(const geXForm3d *WXForm, geXForm3d *CXForm);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069940">CSNetMgr.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  CSNetMgr.h                                                                         */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard/Brian Adelberg                                                 */</P>
<P>/*  Description: Client/Server network code                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_CSNETMGR_H</P>
<P>#define GE_CSNETMGR_H</P>

<P>#include "BaseType.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>//================================================================================</P>
<P>//&#9;Structure defines</P>
<P>//================================================================================</P>

<P>// GENESIS_PUBLIC_APIS</P>

<P>typedef struct&#9;&#9;geCSNetMgr&#9;geCSNetMgr;</P>

<P>typedef uint32&#9;&#9;&#9;&#9;geCSNetMgr_NetID;</P>
<P>#define&#9;MAX_CLIENT_NAME&#9;&#9;256</P>

<P>// Types for messages received from GE_ReceiveSystemMessage</P>
<P>typedef enum </P>
<P>{</P>
<P>&#9;NET_MSG_NONE,&#9;&#9;&#9;&#9;&#9;// No msg</P>
<P>&#9;NET_MSG_USER,&#9;&#9;&#9;&#9;&#9;// User message</P>
<P>&#9;NET_MSG_CREATE_CLIENT,&#9;&#9;&#9;// A new client has joined in</P>
<P>&#9;NET_MSG_DESTROY_CLIENT,&#9;&#9;&#9;// An existing client has left</P>
<P>&#9;NET_MSG_HOST,&#9;&#9;&#9;&#9;&#9;// We are the server now</P>
<P>&#9;NET_MSG_SESSIONLOST,&#9;&#9;&#9;// Connection was lost</P>
<P>&#9;NET_MSG_SERVER_ID,&#9;&#9;&#9;&#9;// Internal, for hand shaking process</P>
<P>} geCSNetMgr_NetMsgType;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;char&#9;&#9;&#9;&#9;Name[MAX_CLIENT_NAME];</P>
<P>&#9;geCSNetMgr_NetID&#9;Id;</P>
<P>} geCSNetMgr_NetClient;</P>

<P>&nbsp;</P>
<P>#ifdef _INC_WINDOWS</P>
<P>&#9;// Windows.h must be included previously for this api to be exposed.</P>

<P>&#9;typedef struct geCSNetMgr_NetSession</P>
<P>&#9;{</P>
<P>&#9;&#9;char&#9;&#9;SessionName[200];&#9;&#9;&#9;&#9;&#9;// Description of Service provider</P>
<P>&#9;&#9;GUID&#9;&#9;Guid;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Service Provider GUID</P>
<P>&#9;&#9;#pragma message("define a geGUID?.. wouldn't need a windows dependency here...")</P>
<P>&#9;} geCSNetMgr_NetSession;</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_FindSession(geCSNetMgr *M, const char *IPAdress, geCSNetMgr_NetSession **SessionList, int32 *SessionNum );</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_JoinSession(geCSNetMgr *M, const char *Name, const geCSNetMgr_NetSession* Session);</P>
<P>#endif</P>

<P>GENESISAPI geCSNetMgr *&#9;&#9;GENESISCC geCSNetMgr_Create(void);</P>
<P>GENESISAPI void&#9;&#9;&#9;&#9;GENESISCC geCSNetMgr_Destroy(geCSNetMgr **ppM);</P>
<P>GENESISAPI geCSNetMgr_NetID&#9;GENESISCC geCSNetMgr_GetServerID(geCSNetMgr *M);</P>
<P>GENESISAPI geCSNetMgr_NetID&#9;GENESISCC geCSNetMgr_GetOurID(geCSNetMgr *M);</P>
<P>GENESISAPI geCSNetMgr_NetID&#9;GENESISCC geCSNetMgr_GetAllPlayerID(geCSNetMgr *M);</P>
<P>GENESISAPI geBoolean GENESISCC&#9;&#9;geCSNetMgr_ReceiveFromServer(geCSNetMgr *M, geCSNetMgr_NetMsgType *Type, int32 *Size, uint8 **Data);</P>
<P>GENESISAPI geBoolean GENESISCC&#9;&#9;geCSNetMgr_ReceiveFromClient(geCSNetMgr *M, geCSNetMgr_NetMsgType *Type, geCSNetMgr_NetID *IdClient, int32 *Size, uint8 **Data);</P>
<P>GENESISAPI geBoolean GENESISCC&#9;&#9;geCSNetMgr_ReceiveSystemMessage(geCSNetMgr *M, geCSNetMgr_NetID IdFor, geCSNetMgr_NetMsgType *Type, geCSNetMgr_NetClient *Client);</P>
<P>GENESISAPI geBoolean GENESISCC&#9;&#9;geCSNetMgr_ReceiveAllMessages(geCSNetMgr *M, geCSNetMgr_NetID *IdFrom, geCSNetMgr_NetID *IdTo, geCSNetMgr_NetMsgType *Type, int32 *Size, uint8 **Data);</P>
<P>GENESISAPI geBoolean GENESISCC&#9;&#9;geCSNetMgr_WeAreTheServer(geCSNetMgr *M);</P>
<P>GENESISAPI geBoolean GENESISCC&#9;&#9;geCSNetMgr_StartSession(geCSNetMgr *M, const char *SessionName, const char *PlayerName );</P>
<P>GENESISAPI geBoolean GENESISCC&#9;&#9;geCSNetMgr_StopSession(geCSNetMgr *M);</P>
<P>GENESISAPI geBoolean GENESISCC&#9;&#9;geCSNetMgr_SendToServer(geCSNetMgr *M, geBoolean Guaranteed, uint8 *Data, int32 DataSize);</P>
<P>GENESISAPI geBoolean GENESISCC&#9;&#9;geCSNetMgr_SendToClient(geCSNetMgr *M, geCSNetMgr_NetID To, geBoolean Guaranteed, uint8 *Data, int32 DataSize);</P>

<P>&nbsp;</P>
<P>// GENESIS_PRIVATE_APIS</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069941">Genesis.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Genesis.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Description: The master header for Genesis                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GENESIS_H</P>
<P>#define GENESIS_H</P>

<P>#include "BaseType.h"</P>
<P>#include "Vec3d.h"</P>
<P>#include "XForm3d.h"</P>
<P>#include "GETypes.h"</P>
<P>#include "ExtBox.h"</P>
<P>#include "vfile.h"</P>
<P>#include "Bitmap.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//================================================================================</P>
<P>//&#9;Constants / Defines / TypDefs</P>
<P>//================================================================================</P>

<P>typedef struct&#9;&#9;geEngine&#9;&#9;&#9;geEngine;</P>

<P>typedef struct&#9;&#9;geDriver_System&#9;&#9;geDriver_System;</P>
<P>typedef struct&#9;&#9;geDriver&#9;&#9;&#9;geDriver;</P>
<P>typedef struct&#9;&#9;geDriver_Mode&#9;&#9;geDriver_Mode;</P>

<P>typedef struct&#9;&#9;geSound_System&#9;&#9;geSound_System;</P>
<P>typedef struct&#9;&#9;geSound_Cfg&#9;&#9;&#9;geSound_Cfg;</P>
<P>typedef struct&#9;&#9;geSound_Def&#9;&#9;&#9;geSound_Def;</P>
<P>typedef struct&#9;&#9;geSound&#9;&#9;&#9;&#9;geSound;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>typedef struct&#9;&#9;geActor&#9;&#9;&#9;&#9;geActor;</P>
<P>typedef struct&#9;&#9;geActor_Def&#9;&#9;&#9;geActor_Def;&#9;&#9;// the definition of an actor's geometry/bone structure</P>

<P>typedef struct&#9;&#9;geWorld&#9;&#9;&#9;&#9;geWorld;</P>

<P>typedef struct&#9;&#9;geWorld_Model&#9;&#9;geWorld_Model;</P>

<P>typedef struct&#9;&#9;geEntity&#9;&#9;&#9;geEntity;</P>
<P>typedef struct&#9;&#9;geEntity_EntitySet&#9;geEntity_EntitySet;</P>

<P>typedef struct&#9;&#9;geCamera&#9;&#9;&#9;geCamera;</P>

<P>typedef struct&#9;&#9;geCSNetMgr&#9;&#9;&#9;geCSNetMgr;</P>

<P>typedef struct&#9;&#9;gePoly&#9;&#9;&#9;&#9;gePoly;</P>

<P>typedef struct&#9;&#9;geLight&#9;&#9;&#9;&#9;geLight;&#9;&#9;&#9;</P>

<P>typedef struct&#9;&#9;geFog&#9;&#9;&#9;&#9;geFog;</P>

<P>typedef struct&#9;&#9;geMesh_Def&#9;&#9;&#9;geMesh_Def;&#9;&#9;&#9;// Mesh def</P>
<P>typedef struct&#9;&#9;geMesh&#9;&#9;&#9;&#9;geMesh;&#9;&#9;&#9;&#9;</P>

<P>#define GE_VERSION_MAJOR&#9;&#9;(1UL)</P>
<P>#define GE_VERSION_MINOR&#9;&#9;(3UL)</P>
<P>#define GE_VERSION_MINOR_MIN&#9;(3UL)</P>

<P>#define GE_VERSION_MAJOR_SHIFT&#9;(16)</P>
<P>#define GE_VERSION_MAJOR_MASK&#9;((uint32)0xFFFF0000)</P>

<P>#define GE_VERSION&#9;&#9;&#9;&#9;( (GE_VERSION_MAJOR &lt;&lt; GE_VERSION_MAJOR_SHIFT) + GE_VERSION_MINOR )</P>

<P>// From here down, still needs to be fixed up for July4</P>
<P>typedef&#9;struct&#9;&#9;GE_ModelMotion&#9;&#9;GE_ModelMotion;</P>
<P>typedef float&#9;&#9;GE_TimeType;</P>

<P>// Polys</P>
<P>typedef enum</P>
<P>{</P>
<P>&#9;GE_TEXTURED_POLY,</P>
<P>&#9;GE_GOURAUD_POLY,</P>
<P>&#9;GE_TEXTURED_POINT&#9;&#9;&#9;&#9;&#9;</P>
<P>} gePoly_Type;</P>

<P>// Poly Fx flags</P>
<P>#define&#9;GE_RENDER_DO_NOT_OCCLUDE_OTHERS&#9;(1&lt;&lt;0)&#9;&#9;&#9;// Poly will not occlude others</P>
<P>#define GE_RENDER_DO_NOT_OCCLUDE_SELF&#9;(1&lt;&lt;1)&#9;&#9;&#9;// Renders under any condition.  Useful for halos, etc...</P>
<P>#define&#9;GE_RENDER_BACKFACED&#9;&#9;&#9;&#9;(1&lt;&lt;2)&#9;&#9;&#9;// Poly should be backfaced from the Camera's Pov</P>
<P>#define GE_RENDER_DEPTH_SORT_BF&#9;&#9;&#9;(1&lt;&lt;3)&#9;&#9;&#9;// Sorts relative to camera position, from back to front</P>
<P>#define GE_RENDER_CLAMP_UV&#9;&#9;&#9;&#9;(1&lt;&lt;4)&#9;&#9;&#9;// Clamp UV's in both directions</P>

<P>// World Add flags</P>
<P>#define GE_WORLD_RENDER&#9;&#9;&#9;&#9;(1&lt;&lt;0)</P>
<P>#define GE_WORLD_COLLIDE&#9;&#9;&#9;(1&lt;&lt;1)</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#ifndef GE_CONTENTS_TYPES</P>
<P>#define GE_CONTENTS_TYPES</P>

<P>//</P>
<P>// Content types in GE_Contents structure (multiple contents can be mixed...)</P>
<P>//</P>
<P>//*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=</P>
<P>//&#9;IF THESE FLAGS CHANGE, THEY MUST CHANGE IN GBSPFILE.H in Genesis AND GBSPLIB, and Genesis.H!!!!!</P>
<P>//*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=</P>
<P>#define GE_CONTENTS_SOLID&#9;&#9;&#9;(1&lt;&lt;0)&#9;&#9;// Solid (Visible)</P>
<P>#define GE_CONTENTS_WINDOW&#9;&#9;&#9;(1&lt;&lt;1)&#9;&#9;// Window (Visible)</P>
<P>#define GE_CONTENTS_EMPTY&#9;&#9;&#9;(1&lt;&lt;2)&#9;&#9;// Empty but Visible (water, lava, etc...)</P>

<P>#define GE_CONTENTS_TRANSLUCENT&#9;&#9;(1&lt;&lt;3)&#9;&#9;// Vis will see through it</P>
<P>#define GE_CONTENTS_WAVY&#9;&#9;&#9;(1&lt;&lt;4)&#9;&#9;// Wavy (Visible)</P>
<P>#define GE_CONTENTS_DETAIL&#9;&#9;&#9;(1&lt;&lt;5)&#9;&#9;// Won't be included in vis oclusion</P>

<P>#define GE_CONTENTS_CLIP&#9;&#9;&#9;(1&lt;&lt;6)&#9;&#9;// Structural but not visible</P>
<P>#define GE_CONTENTS_HINT&#9;&#9;&#9;(1&lt;&lt;7)&#9;&#9;// Primary splitter (Non-Visible)</P>
<P>#define GE_CONTENTS_AREA&#9;&#9;&#9;(1&lt;&lt;8)&#9;&#9;// Area seperator leaf (Non-Visible)</P>

<P>#define GE_CONTENTS_FLOCKING&#9;&#9;(1&lt;&lt;9)</P>
<P>#define GE_CONTENTS_SHEET&#9;&#9;&#9;(1&lt;&lt;10)</P>
<P>#define GE_CONTENTS_AIR&#9;&#9;&#9;&#9;(1&lt;&lt;11)&#9;&#9;// No brush lives in this leaf</P>
<P>#define GE_RESERVED4&#9;&#9;&#9;&#9;(1&lt;&lt;12)</P>
<P>#define GE_RESERVED5&#9;&#9;&#9;&#9;(1&lt;&lt;13)</P>
<P>#define GE_RESERVED6&#9;&#9;&#9;&#9;(1&lt;&lt;14)</P>
<P>#define GE_RESERVED7&#9;&#9;&#9;&#9;(1&lt;&lt;15)</P>

<P>// 16-31 reserved for user contents</P>
<P>#define GE_CONTENTS_USER1&#9;&#9;&#9;(1&lt;&lt;16)</P>
<P>#define GE_CONTENTS_USER2&#9;&#9;&#9;(1&lt;&lt;17)</P>
<P>#define GE_CONTENTS_USER3&#9;&#9;&#9;(1&lt;&lt;18)</P>
<P>#define GE_CONTENTS_USER4&#9;&#9;&#9;(1&lt;&lt;19)</P>
<P>#define GE_CONTENTS_USER5&#9;&#9;&#9;(1&lt;&lt;20)</P>
<P>#define GE_CONTENTS_USER6&#9;&#9;&#9;(1&lt;&lt;21)</P>
<P>#define GE_CONTENTS_USER7&#9;&#9;&#9;(1&lt;&lt;22)</P>
<P>#define GE_CONTENTS_USER8&#9;&#9;&#9;(1&lt;&lt;23)</P>
<P>#define GE_CONTENTS_USER9&#9;&#9;&#9;(1&lt;&lt;24)</P>
<P>#define GE_CONTENTS_USER10&#9;&#9;&#9;(1&lt;&lt;25)</P>
<P>#define GE_CONTENTS_USER11&#9;&#9;&#9;(1&lt;&lt;26)</P>
<P>#define GE_CONTENTS_USER12&#9;&#9;&#9;(1&lt;&lt;27)</P>
<P>#define GE_CONTENTS_USER13&#9;&#9;&#9;(1&lt;&lt;28)</P>
<P>#define GE_CONTENTS_USER14&#9;&#9;&#9;(1&lt;&lt;29)</P>
<P>#define GE_CONTENTS_USER15&#9;&#9;&#9;(1&lt;&lt;30)</P>
<P>#define GE_CONTENTS_USER16&#9;&#9;&#9;(1&lt;&lt;31)</P>
<P>// 16-31 reserved for user contents</P>

<P>&nbsp;</P>
<P>// These contents are all solid types</P>
<P>#define GE_CONTENTS_SOLID_CLIP&#9;&#9;(GE_CONTENTS_SOLID | GE_CONTENTS_WINDOW | GE_CONTENTS_CLIP)</P>
<P>#define GE_CONTENTS_CANNOT_OCCUPY&#9;GE_CONTENTS_SOLID_CLIP</P>

<P>// These contents are all visible types</P>
<P>#define GE_VISIBLE_CONTENTS&#9;&#9;&#9;(&#9;GE_CONTENTS_SOLID | \</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_CONTENTS_EMPTY | \</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_CONTENTS_WINDOW | \</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_CONTENTS_WAVY)</P>

<P>#endif</P>
<P>//*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=</P>
<P>//*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=</P>

<P>// NOTES - Fills in first Model/Mesh hit</P>
<P>// Exceptions:</P>
<P>//&#9;&#9;Returns the last solid model hit...</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;geMesh&#9;&#9;&#9;*Mesh;</P>
<P>&#9;geWorld_Model&#9;*Model;</P>
<P>&#9;geActor&#9;&#9;&#9;*Actor;</P>
<P>&#9;int32&#9;&#9;&#9;Contents;</P>
<P>} GE_Contents;</P>

<P>typedef geBoolean GE_CollisionCB(geWorld_Model *Model, geActor *Actor, void *Context);</P>

<P>// Collision</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;geVec3d&#9;Normal;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Orientation of plane</P>
<P>&#9;float&#9;Dist;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Distance from origin</P>
<P>} GE_Plane;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;geWorld_Model&#9;*Model;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Pointer to what model was hit (if any)</P>
<P>&#9;geMesh&#9;&#9;&#9;*Mesh;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Pointer to what mesh was hit (if any)</P>
<P>&#9;geActor&#9;&#9;&#9;*Actor;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Pointer to what actor was hit (if any)&#9;</P>
<P>&#9;geVec3d&#9;&#9;&#9;Impact;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Impact Point</P>
<P>&#9;float&#9;&#9;&#9;Ratio;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Percent from 0 to 1.0, how far along the line for the impact point</P>
<P>&#9;GE_Plane&#9;&#9;Plane;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Impact Plane</P>
<P>} GE_Collision;</P>

<P>// If these render states change, they must change in DCommon.h too!!!</P>
<P>// These are still under construction, and are for debug purposes only.</P>
<P>// They are merely means of overriding ways the engine normally renders primitives, etc...</P>
<P>//</P>
<P>//&#9;RenderState States</P>
<P>//</P>
<P>#define GE_RENDERSTATE_ZWRITE&#9;&#9;0&#9;&#9;// Z Writes</P>
<P>#define GE_RENDERSTATE_ZCMP&#9;&#9;&#9;1&#9;&#9;// Z Compares</P>
<P>#define GE_RENDERSTATE_BILINEAR&#9;&#9;2&#9;&#9;// Bilinear filtering</P>
<P>#define&#9;GE_RENDERSTATE_ANTI_ALIAS&#9;3&#9;&#9;// Anti-Aliasing</P>
<P>#define GE_RENDERSTATE_POLYMODE&#9;&#9;4&#9;&#9;// Normal, Gouraud only, Lines only, etc</P>

<P>//</P>
<P>//&#9;RenderState Flags</P>
<P>//</P>
<P>#define GE_RENDERFLAG_OFF&#9;&#9;0</P>
<P>#define GE_RENDERFLAG_ON&#9;&#9;1</P>

<P>//</P>
<P>//  PolyMode flags&#9;(A method to override how polys are drawn for debugging purposes...)</P>
<P>//</P>
<P>#define GE_POLYMODE_NORMAL&#9;&#9;1&#9;&#9;&#9;// Draw as is</P>
<P>#define GE_POLYMODE_GOURAUD&#9;&#9;2&#9;&#9;&#9;// Gouraud only</P>
<P>#define GE_POLYMODE_LINES&#9;&#9;3&#9;&#9;&#9;// Outlines only</P>

<P>//================================================================================</P>
<P>//&#9;Engine Management functions</P>
<P>//================================================================================</P>

<P>&nbsp;</P>
<P>#ifdef _INC_WINDOWS&#9;</P>
<P>&#9;// Windows.h must be included before genesis.h for this api to be exposed.</P>
<P>&#9;</P>

<P>GENESISAPI&#9;geEngine&#9;*geEngine_CreateWithVersion(HWND hWnd, const char *AppName, const char *DriverDirectory, uint32 Version);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;// use geEngine_Create, rather than calling this directly.</P>

<P>#define geEngine_Create( hWnd, AppName, DriverDirectory)   geEngine_CreateWithVersion(hWnd,AppName,DriverDirectory,GE_VERSION)</P>

<P>#endif</P>

<P>GENESISAPI void&#9;&#9;&#9;geEngine_Free(geEngine *Engine);</P>

<P>GENESISAPI geBoolean&#9;geEngine_AddWorld(geEngine *Engine, geWorld *World);</P>
<P>GENESISAPI geBoolean&#9;geEngine_RemoveWorld(geEngine *Engine, geWorld *World);</P>

<P>GENESISAPI geBoolean&#9;geEngine_AddBitmap(geEngine *Engine, geBitmap *Bitmap);</P>
<P>GENESISAPI geBoolean&#9;geEngine_RemoveBitmap(geEngine *Engine, geBitmap *Bitmap);</P>

<P>GENESISAPI geDriver_System *geEngine_GetDriverSystem(geEngine *Engine);</P>

<P>GENESISAPI geBoolean&#9;geEngine_SetDriverAndMode(&#9;geEngine *Engine, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geDriver *Driver, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geDriver_Mode *DriverMode);</P>

<P>GENESISAPI geBoolean&#9;geEngine_ShutdownDriver(geEngine *Engine);</P>

<P>GENESISAPI geBoolean&#9;geEngine_BeginFrame(geEngine *Engine, geCamera *Camera, geBoolean ClearScreen);</P>
<P>GENESISAPI geBoolean&#9;geEngine_EndFrame(geEngine *Engine);</P>

<P>GENESISAPI geBoolean&#9;geEngine_RenderWorld(geEngine *Engine, geWorld *World, geCamera *Camera, geFloat Time);</P>
<P>GENESISAPI geBoolean&#9;geEngine_Printf(geEngine *Engine, int32 x, int32 y, const char *String, ...);</P>

<P>GENESISAPI void&#9;&#9;&#9;GENESISCC geEngine_RenderPoly(const geEngine *Engine, const GE_TLVertex *Points, int NumPoints, const geBitmap *Texture, uint32 Flags);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;//RenderPoly : if Texture is null, we Gouraud shade</P>

<P>GENESISAPI void&#9;&#9;&#9;GENESISCC geEngine_RenderPolyArray(const geEngine *Engine, const GE_TLVertex ** pPoints, int * pNumPoints, int NumPolys, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geBitmap *Texture, uint32 Flags);</P>

<P>GENESISAPI geBoolean&#9;GENESISCC geEngine_DrawBitmap(const geEngine *Engine,const geBitmap *Bitmap,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geRect * Source, uint32 x, uint32 y);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;//DrawBitmap &amp; RenderPoly : must Engine_AddBitmap first!</P>

<P>&nbsp;</P>
<P>GENESISAPI void&#9;&#9;&#9;geEngine_FillRect(geEngine *Engine, const GE_Rect *Rect, const GE_RGBA *Color);</P>

<P>GENESISAPI geBoolean&#9;geEngine_SetGamma(geEngine *Engine, float Gamma);</P>
<P>GENESISAPI geBoolean&#9;geEngine_GetGamma(geEngine *Engine, float *Gamma);</P>

<P>GENESISAPI geBoolean&#9;geEngine_ScreenShot(geEngine *Engine, const char *FileName);</P>

<P>GENESISAPI void&#9;&#9;&#9;geEngine_EnableFrameRateCounter(geEngine *Engine, geBoolean Enabled);</P>

<P>GENESISAPI geBoolean&#9;geEngine_Activate(geEngine *Engine, geBoolean bActive);</P>

<P>#ifdef _INC_WINDOWS</P>
<P>&#9;// Windows.h must be included before genesis.h for this api to be exposed.</P>
<P>GENESISAPI geBoolean&#9;geEngine_UpdateWindow(geEngine *Engine);</P>
<P>#endif</P>

<P>// geDriver</P>
<P>GENESISAPI geDriver&#9;&#9;*geDriver_SystemGetNextDriver(geDriver_System *DriverSystem, geDriver *Start);</P>
<P>GENESISAPI geDriver_Mode *geDriver_GetNextMode(geDriver *Driver, geDriver_Mode *Start);</P>
<P>GENESISAPI geBoolean&#9;geDriver_GetName(geDriver *Driver, const char **Name);</P>
<P>GENESISAPI geBoolean&#9;geDriver_ModeGetName(geDriver_Mode *Mode, const char **Name);</P>
<P>GENESISAPI geBoolean&#9;geDriver_ModeGetWidthHeight(geDriver_Mode *Mode, int32 *Width, int32 *Height);</P>

<P>//================================================================================</P>
<P>//&#9;Sound Management functions</P>
<P>//================================================================================</P>
<P>#ifdef _INC_WINDOWS</P>
<P>&#9;// Windows.h must be included before genesis.h for this api to be exposed.</P>
<P>GENESISAPI &#9;geSound_System *geSound_CreateSoundSystem(HWND hWnd);</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>GENESISAPI void&#9;&#9;&#9;geSound_DestroySoundSystem(geSound_System *Sound);</P>

<P>&nbsp;</P>
<P>GENESISAPI geSound_Def&#9;   *geSound_LoadSoundDef(geSound_System *SoundS, geVFile *File);</P>
<P>GENESISAPI void&#9;&#9;&#9;&#9;geSound_FreeSoundDef(geSound_System *SoundS, geSound_Def *SoundDef);</P>

<P>GENESISAPI geSound&#9;&#9;   *geSound_PlaySoundDef(geSound_System *SoundS, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geSound_Def *SoundDef, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Volume, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Pan, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Frequency, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean Loop);</P>
<P>GENESISAPI geBoolean&#9;&#9;geSound_StopSound(geSound_System *SoundS, geSound *Sound);</P>
<P>GENESISAPI geBoolean&#9;&#9;geSound_ModifySound(geSound_System *SoundS, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geSound *Sound, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Volume, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Pan, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Frequency);</P>
<P>GENESISAPI geBoolean&#9;&#9;geSound_SoundIsPlaying(geSound_System *SoundS, geSound *Sound);</P>
<P>GENESISAPI geBoolean&#9;&#9;geSound_SetMasterVolume( geSound_System *SoundS, geFloat Volume );</P>

<P>GENESISAPI void geSound3D_GetConfig(</P>
<P>&#9;&#9;&#9;const geWorld *World, </P>
<P>&#9;&#9;&#9;const geXForm3d *CameraTransform, </P>
<P>&#9;&#9;&#9;const geVec3d *SoundPos, </P>
<P>&#9;&#9;&#9;geFloat Min, </P>
<P>&#9;&#9;&#9;geFloat Ds,</P>
<P>&#9;&#9;&#9;geFloat *Volume,</P>
<P>&#9;&#9;&#9;geFloat *Pan,</P>
<P>&#9;&#9;&#9;geFloat *Frequency);</P>

<P>//================================================================================</P>
<P>//  Path Support</P>
<P>//================================================================================</P>
<P>#include "Path.h"</P>
<P>//================================================================================</P>
<P>//  Motion Support</P>
<P>//================================================================================</P>
<P>#include "Motion.h"</P>
<P>//================================================================================</P>
<P>//  Actor Support</P>
<P>//================================================================================</P>
<P>#include "Actor.h"</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>//================================================================================</P>
<P>//&#9;World Management functions</P>
<P>//================================================================================</P>
<P>GENESISAPI geWorld&#9;&#9;*geWorld_Create(geVFile *File);</P>
<P>GENESISAPI void&#9;&#9;&#9;geWorld_Free(geWorld *World);</P>

<P>// World Actors</P>
<P>GENESISAPI geBoolean&#9;geWorld_RemoveActor    (geWorld *World, geActor *Actor);</P>
<P>GENESISAPI geBoolean    geWorld_AddActor       (geWorld *World, geActor *Actor, uint32 Flags, uint32 UserFlags);</P>
<P>GENESISAPI geBoolean&#9;geWorld_SetActorFlags  (geWorld *World, geActor *Actor, uint32 Flags);</P>

<P>// World Bitmaps</P>
<P>GENESISAPI geBoolean&#9;geWorld_AddBitmap(&#9;&#9;geWorld *World, geBitmap *Bitmap);</P>
<P>GENESISAPI geBoolean&#9;geWorld_RemoveBitmap(&#9;geWorld *World, geBitmap *Bitmap);</P>
<P>GENESISAPI geBoolean&#9;geWorld_HasBitmap(const geWorld *World, const geBitmap *Bitmap);</P>
<P>GENESISAPI geBitmap&#9;&#9;*geWorld_GetBitmapByName(geWorld *World, const char *BitmapName);</P>
<P>GENESISAPI geBoolean&#9;geWorld_BitmapIsVisible(geWorld *World, const geBitmap *Bitmap);</P>

<P>// World BModels</P>
<P>GENESISAPI geWorld_Model&#9;*geWorld_GetNextModel(geWorld *World, geWorld_Model *Start);</P>
<P>GENESISAPI geBoolean&#9;&#9;geWorld_SetModelXForm(geWorld *World, geWorld_Model *Model, const geXForm3d *XForm);</P>
<P>GENESISAPI geBoolean&#9;&#9;geWorld_GetModelXForm(const geWorld *World, const geWorld_Model *Model, geXForm3d *XForm);</P>
<P>GENESISAPI geBoolean&#9;&#9;geWorld_OpenModel(geWorld *World, geWorld_Model *Model, geBoolean Open);</P>
<P>GENESISAPI geBoolean&#9;&#9;geWorld_GetModelRotationalCenter(const geWorld *World, const geWorld_Model *Model, geVec3d *Center);</P>
<P>GENESISAPI geBoolean&#9;&#9;geWorld_ModelGetBBox(const geWorld *World, const geWorld_Model *Model, geVec3d *Mins, geVec3d *Maxs);</P>
<P>GENESISAPI geMotion *&#9;&#9;geWorld_ModelGetMotion(geWorld_Model *Model);</P>

<P>GENESISAPI void&#9;&#9;&#9;*geWorld_ModelGetUserData(const geWorld_Model *Model);</P>
<P>GENESISAPI void&#9;&#9;&#9;geWorld_ModelSetUserData(geWorld_Model *Model, void *UserData);</P>
<P>GENESISAPI void&#9;&#9;&#9;geWorld_ModelSetFlags(geWorld_Model *Model, uint32 ModelFlags);</P>
<P>GENESISAPI uint32&#9;&#9;geWorld_ModelGetFlags(geWorld_Model *Model);</P>

<P>// World Lights</P>
<P>GENESISAPI geLight&#9;&#9;*geWorld_AddLight(geWorld *World);</P>
<P>GENESISAPI void&#9;&#9;&#9;geWorld_RemoveLight(geWorld *World, geLight *Light);</P>
<P>GENESISAPI geBoolean&#9;geWorld_SetLightAttributes(&#9;geWorld *World,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geLight&#9;&#9;*Light, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const&#9;&#9;geVec3d *Pos, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const&#9;&#9;GE_RGBA *RGBA, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float&#9;&#9;Radius,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean&#9;CastShadow);</P>
<P>GENESISAPI geBoolean&#9;geWorld_SetLTypeTable(geWorld *World, int32 LType, const char *Table);</P>

<P>// World fog</P>
<P>GENESISAPI geFog&#9;&#9;*geWorld_AddFog(geWorld *World);</P>
<P>GENESISAPI geBoolean&#9;geWorld_RemoveFog(geWorld *World, geFog *Fog);</P>

<P>GENESISAPI geBoolean geFog_SetAttributes(&#9;geFog&#9;&#9;&#9;*Fog, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d&#9;*Pos, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_RGBA&#9;&#9;&#9;*Color,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float&#9;&#9;&#9;LightBrightness, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float&#9;&#9;&#9;VolumeBrightness, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float&#9;&#9;&#9;VolumeRadius);</P>

<P>// World Classes/Entities</P>
<P>GENESISAPI geEntity_EntitySet *geWorld_GetEntitySet(geWorld *World, const char *ClassName);</P>
<P>GENESISAPI geEntity&#9;&#9;*geEntity_EntitySetGetNextEntity(geEntity_EntitySet *EntitySet, geEntity *Entity);</P>
<P>GENESISAPI void&#9;&#9;&#9;*geEntity_GetUserData(geEntity *Entity);</P>
<P>GENESISAPI void&#9;&#9;&#9;geEntity_GetName(const geEntity *Entity, char *Buff, int MaxLen);</P>

<P>// World collision</P>
<P>GENESISAPI geBoolean&#9;geWorld_ModelCollision(&#9;geWorld&#9;&#9;&#9;*World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geWorld_Model&#9;*Model, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d&#9;*DXForm, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_Collision&#9;*Collision);</P>
<P>GENESISAPI geBoolean geWorld_TestModelMove(&#9;geWorld&#9;&#9;&#9;*World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geWorld_Model&#9;*Model, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d&#9;*DXForm, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d&#9;*Mins, const geVec3d *Maxs,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d&#9;*In, geVec3d *Out);</P>

<P>GENESISAPI geBoolean geWorld_Collision(&#9;geWorld *World,&#9;&#9;&#9;&#9;// World to collide with</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Mins,&#9;&#9;// Mins of object (in object-space).  This CAN be NULL</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Maxs,&#9;&#9;// Maxs of object (in object-space).  This CAN be NULL</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Front,&#9;&#9;// Front of line (in world-space)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Back,&#9;&#9;// Back of line (in world-space)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 Contents,&#9;&#9;&#9;// Contents to collide with (use GE_CONTENTS_SOLID_CLIP for default)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 CollideFlags,&#9;&#9;// To mask out certain object types (GE_COLLIDE_ALL, etc...)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 UserFlags,&#9;&#9;&#9;// To mask out actors (refer to geActor_SetUserFlags)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_CollisionCB *CollisionCB, // A callback to allow user to reject collisions with certain objects)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;void *Context,&#9;&#9;&#9;&#9;// User data passed through above callback</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_Collision *Col);&#9;&#9;&#9;// Structure filled with info about what was collided with</P>
<P>&#9;// NOTE - Mins/Maxs CAN be NULL.  If you are just testing a point, then use NULL (it's faster!!!).</P>

<P>GENESISAPI geBoolean geWorld_GetContents(geWorld *World, const geVec3d *Pos, const geVec3d *Mins, const geVec3d *Maxs, uint32 Flags, uint32 UserFlags, GE_CollisionCB *CollisionCB, void *Context, GE_Contents *Contents);</P>

<P>// World Polys</P>
<P>GENESISAPI&#9;gePoly *geWorld_AddPolyOnce(geWorld *World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_LVertex *Verts, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap *Bitmap,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;gePoly_Type Type, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 RenderFlags,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float Scale);</P>
<P>GENESISAPI&#9;gePoly *geWorld_AddPoly(geWorld *World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_LVertex *Verts, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap *Bitmap,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;gePoly_Type Type,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 RenderFlags,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float Scale);</P>

<P>GENESISAPI&#9;void geWorld_RemovePoly(geWorld *World, gePoly *Poly);</P>
<P>GENESISAPI&#9;geBoolean gePoly_GetLVertex(gePoly *Poly, int32 Index, GE_LVertex *LVert);</P>
<P>GENESISAPI&#9;geBoolean gePoly_SetLVertex(gePoly *Poly, int32 Index, const GE_LVertex *LVert);</P>

<P>// World visibility</P>
<P>GENESISAPI geBoolean&#9;geWorld_GetLeaf(const geWorld *World, const geVec3d *Pos, int32 *Leaf);</P>
<P>GENESISAPI geBoolean&#9;geWorld_MightSeeLeaf(const geWorld *World, int32 Leaf);</P>

<P>GENESISAPI geBoolean&#9;geWorld_LeafMightSeeLeaf(const geWorld *World, int32 Leaf1, int32 Leaf2, uint32 VisFlags);</P>
<P>&#9;// Checks to see if Leaf1 can see Leaf2</P>
<P>&#9;// Currently VisFlags is not used yet.  It could be used for checking against areas, etc...</P>
<P>&#9;// Eventually you could also pass in a VisObject, that is manipulated with a camera...</P>

<P>GENESISAPI geBoolean GENESISCC geWorld_IsActorPotentiallyVisible(const geWorld *World, const geActor *Actor, const geCamera *Camera);</P>

<P>&nbsp;</P>
<P>//================================================================================</P>
<P>//&#9;Camera Management functions</P>
<P>//================================================================================</P>

<P>GENESISAPI geCamera&#9;&#9;&#9;*GENESISCC geCamera_Create(geFloat Fov, const geRect *Rect);</P>
<P>GENESISAPI void&#9;&#9;&#9;&#9;GENESISCC geCamera_Destroy(geCamera **pCamera);</P>
<P>GENESISAPI void&#9;&#9;&#9;&#9;GENESISCC geCamera_SetZScale(geCamera *Camera, geFloat ZScale);</P>
<P>GENESISAPI geFloat&#9;&#9;&#9;GENESISCC geCamera_GetZScale(const geCamera *Camera);</P>
<P>GENESISAPI void&#9;&#9;&#9;&#9;GENESISCC geCamera_SetAttributes(geCamera *Camera,geFloat Fov, const geRect *Rect);</P>
<P>GENESISAPI void&#9;&#9;&#9;&#9;GENESISCC geCamera_GetClippingRect(const geCamera *Camera, geRect *Rect);</P>

<P>GENESISAPI void&#9;&#9;&#9;&#9;GENESISCC geCamera_ScreenPointToWorld(const geCamera&#9;*Camera,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32&#9;&#9;&#9; ScreenX,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32&#9;&#9;&#9; ScreenY,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d&#9;&#9;&#9;*Vector&#9;);</P>
<P>GENESISAPI void&#9;GENESISCC geCamera_Project(const geCamera&#9;*Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d&#9;*PointInCameraSpace, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d&#9;&#9;&#9;*ProjectedPoint);</P>
<P>GENESISAPI void GENESISCC geCamera_Transform(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *WorldSpacePoint, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  geVec3d *CameraSpacePoint);</P>

<P>GENESISAPI void GENESISCC geCamera_TransformArray(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *WorldSpacePointPtr, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;      geVec3d *CameraSpacePointPtr,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int count);</P>

<P>GENESISAPI void GENESISCC geCamera_TransformAndProject(const geCamera *Camera,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const&#9;geVec3d *Point, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *ProjectedPoint);</P>

<P>GENESISAPI void GENESISCC geCamera_TransformAndProjectArray(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *WorldSpacePointPtr, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;      geVec3d *ProjectedSpacePointPtr,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int count);</P>
<P>&#9;</P>
<P>GENESISAPI void GENESISCC geCamera_TransformAndProjectL(const geCamera *Camera,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const GE_LVertex *Point, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_TLVertex *ProjectedPoint);</P>
<P>&#9;&#9;</P>
<P>GENESISAPI void GENESISCC geCamera_TransformAndProjectLArray(const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const GE_LVertex *WorldSpacePointPtr, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;      GE_TLVertex *ProjectedSpacePointPtr,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int count);</P>

<P>&nbsp;</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCamera_SetWorldSpaceXForm(geCamera *Camera, const geXForm3d *XForm);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCamera_SetWorldSpaceVisXForm(geCamera *Camera, const geXForm3d *XForm);</P>
<P>GENESISAPI const geXForm3d&#9;*GENESISCC geCamera_GetWorldSpaceXForm( const geCamera *Camera);</P>
<P>GENESISAPI const geXForm3d * GENESISCC geCamera_GetWorldSpaceVisXForm( const geCamera *Camera);</P>
<P>GENESISAPI geBoolean GENESISCC geCamera_ConvertWorldSpaceToCameraSpace(const geXForm3d *WXForm, geXForm3d *CXForm);</P>

<P>&nbsp;</P>
<P>//================================================================================</P>
<P>// NetPlay Management functions</P>
<P>//================================================================================</P>

<P>typedef uint32&#9;&#9;&#9;&#9;geCSNetMgr_NetID;</P>
<P>#define&#9;MAX_CLIENT_NAME&#9;&#9;256</P>

<P>// Types for messages received from GE_ReceiveSystemMessage</P>
<P>typedef enum </P>
<P>{</P>
<P>&#9;NET_MSG_NONE,&#9;&#9;&#9;&#9;&#9;// No msg</P>
<P>&#9;NET_MSG_USER,&#9;&#9;&#9;&#9;&#9;// User message</P>
<P>&#9;NET_MSG_CREATE_CLIENT,&#9;&#9;&#9;// A new client has joined in</P>
<P>&#9;NET_MSG_DESTROY_CLIENT,&#9;&#9;&#9;// An existing client has left</P>
<P>&#9;NET_MSG_HOST,&#9;&#9;&#9;&#9;&#9;// We are the server now</P>
<P>&#9;NET_MSG_SESSIONLOST,&#9;&#9;&#9;// Connection was lost</P>
<P>&#9;NET_MSG_SERVER_ID,&#9;&#9;&#9;&#9;// Internal, for hand shaking process</P>
<P>} geCSNetMgr_NetMsgType;</P>

<P>&nbsp;</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;char&#9;&#9;&#9;&#9;Name[MAX_CLIENT_NAME];</P>
<P>&#9;geCSNetMgr_NetID&#9;Id;</P>
<P>} geCSNetMgr_NetClient;</P>

<P>#ifdef _INC_WINDOWS</P>
<P>&#9;// Windows.h must be included before genesis.h for this api to be exposed.</P>
<P>&#9;typedef struct geCSNetMgr_NetSession</P>
<P>&#9;{</P>
<P>&#9;&#9;char&#9;&#9;SessionName[200];&#9;&#9;&#9;&#9;&#9;// Description of Service provider</P>
<P>&#9;&#9;GUID&#9;&#9;Guid;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Service Provider GUID</P>
<P>&#9;} geCSNetMgr_NetSession;</P>
<P>GENESISAPI &#9;geBoolean&#9;&#9;GENESISCC geCSNetMgr_FindSession(geCSNetMgr *M, const char *IPAdress, geCSNetMgr_NetSession **SessionList, int32 *SessionNum );</P>
<P>GENESISAPI &#9;geBoolean&#9;&#9;GENESISCC geCSNetMgr_JoinSession(geCSNetMgr *M, const char *Name, const geCSNetMgr_NetSession* Session);</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>GENESISAPI geCSNetMgr&#9;*&#9;GENESISCC geCSNetMgr_Create(void);</P>
<P>GENESISAPI void&#9;&#9;&#9;&#9;GENESISCC geCSNetMgr_Destroy(geCSNetMgr **ppM);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_ReceiveFromServer(geCSNetMgr *M, geCSNetMgr_NetMsgType *Type, int32 *Size, uint8 **Data);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_ReceiveFromClient(geCSNetMgr *M, geCSNetMgr_NetMsgType *Type, geCSNetMgr_NetID *IdClient, int32 *Size, uint8 **Data);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_ReceiveSystemMessage(geCSNetMgr *M, geCSNetMgr_NetID IdFor, geCSNetMgr_NetMsgType *Type, geCSNetMgr_NetClient *Client);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_ReceiveAllMessages(geCSNetMgr *M, geCSNetMgr_NetID *IdFrom, geCSNetMgr_NetID *IdTo, geCSNetMgr_NetMsgType *Type, int32 *Size, uint8 **Data);</P>
<P>GENESISAPI geCSNetMgr_NetID&#9;GENESISCC geCSNetMgr_GetServerID(geCSNetMgr *M);</P>
<P>GENESISAPI geCSNetMgr_NetID&#9;GENESISCC geCSNetMgr_GetOurID(geCSNetMgr *M);</P>
<P>GENESISAPI geCSNetMgr_NetID&#9;GENESISCC geCSNetMgr_GetAllPlayerID(geCSNetMgr *M);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_WeAreTheServer(geCSNetMgr *M);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_StartSession(geCSNetMgr *M, const char *SessionName, const char *PlayerName );</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_StopSession(geCSNetMgr *M);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_SendToServer(geCSNetMgr *M, geBoolean Guaranteed, uint8 *Data, int32 DataSize);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC geCSNetMgr_SendToClient(geCSNetMgr *M, geCSNetMgr_NetID To, geBoolean Guaranteed, uint8 *Data, int32 DataSize);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069942">GETypes.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  GeTypes.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Description: Genesis Types (not primitive enough for basetype)                      */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_TYPES_H</P>
<P>#define GE_TYPES_H</P>

<P>#include "BaseType.h"</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//</P>
<P>//&#9;Collision defines (for geWorld_Collision)</P>
<P>//</P>
<P>#define GE_COLLIDE_MESHES&#9;&#9;&#9;(1&lt;&lt;0)</P>
<P>#define GE_COLLIDE_MODELS&#9;&#9;&#9;(1&lt;&lt;1)</P>
<P>#define GE_COLLIDE_ACTORS&#9;&#9;&#9;(1&lt;&lt;2)</P>
<P>#define GE_COLLIDE_NO_SUB_MODELS&#9;(1&lt;&lt;3)</P>
<P>#define GE_COLLIDE_ALL&#9;&#9;&#9;&#9;(GE_COLLIDE_MESHES | GE_COLLIDE_MODELS | GE_COLLIDE_ACTORS)</P>

<P>//</P>
<P>// Actor flags (geWorld_AddActor)</P>
<P>//</P>
<P>#define GE_ACTOR_RENDER_NORMAL&#9;&#9;&#9;(1&lt;&lt;0)&#9;&#9;// Render in normal views</P>
<P>#define GE_ACTOR_RENDER_MIRRORS&#9;&#9;&#9;(1&lt;&lt;1)&#9;&#9;// Render in mirror views</P>
<P>#define GE_ACTOR_RENDER_ALWAYS&#9;&#9;&#9;(1&lt;&lt;2)&#9;&#9;// Render always, skipping all visibility tests</P>
<P>#define GE_ACTOR_COLLIDE&#9;&#9;&#9;&#9;(1&lt;&lt;3)&#9;&#9;// Collide when calling geWorld_Collision</P>

<P>//</P>
<P>//&#9;Model flags (geWorld_ModelSetFlags)</P>
<P>//</P>
<P>#define GE_MODEL_RENDER_NORMAL&#9;&#9;&#9;(1&lt;&lt;0)&#9;&#9;// Render in normal views</P>
<P>#define GE_MODEL_RENDER_MIRRORS&#9;&#9;&#9;(1&lt;&lt;1)&#9;&#9;// Render in mirror views</P>
<P>#define GE_MODEL_RENDER_ALWAYS&#9;&#9;&#9;(1&lt;&lt;2)&#9;&#9;// Render always, skipping all visibility tests</P>
<P>#define GE_MODEL_COLLIDE&#9;&#9;&#9;&#9;(1&lt;&lt;3)&#9;&#9;// Collide when calling geWorld_Collision</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;float r, g, b, a;</P>
<P>} GE_RGBA;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;int32&#9;Left;</P>
<P>&#9;int32&#9;Right;</P>
<P>&#9;int32&#9;Top;</P>
<P>&#9;int32&#9;Bottom;</P>
<P>} GE_Rect;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;geFloat MinX,MaxX;</P>
<P>&#9;geFloat MinY,MaxY;</P>
<P>} geFloatRect;</P>

<P>// Lit vertex</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;// FIXME:  Convert 3d X,Y,Z to geVec3d</P>
<P>&#9;float X, Y, Z;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 3d vertex</P>
<P>&#9;float u, v;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Uv's</P>
<P>&#9;// FIXME:  Convert r,g,b,a to GE_RGBA</P>
<P>&#9;float r, g, b, a;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// color</P>
<P>} GE_LVertex;</P>

<P>// Transformed Lit vertex</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;float x, y, z;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// screen points</P>
<P>&#9;float u, v;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Uv's</P>
<P>&#9;float r, g, b, a;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// color</P>
<P>} GE_TLVertex;</P>

<P>typedef GE_Rect geRect;</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif GETYPES_H</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069943">List.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>#ifndef LIST_H</P>
<P>#define LIST_H</P>

<P>/****************************************************************************************/</P>
<P>/*  List                                                                                */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description: List/Link/Node Primitives                                              */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#include "basetype.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define LISTCALL&#9;__fastcall</P>

<P>/*******************************************/</P>
<P>/** you must wrap any calls to this module with these: **/</P>

<P>geBoolean List_Start(void);</P>
<P>geBoolean List_Stop(void);</P>

<P>/*******************************************/</P>
<P>/** basic list types ****/</P>

<P>typedef struct List List;</P>

<P>extern List *&#9;LISTCALL List_Create(void);</P>
<P>extern void&#9;&#9;LISTCALL List_Destroy(List * pList);</P>
<P>extern List *&#9;LISTCALL List_AddTail(List *pList,void * Data);</P>
<P>extern List *&#9;LISTCALL List_AddHead(List *pList,void * Data);</P>
<P>&#9;// returns a pointer to the node created</P>
<P>extern void *&#9;LISTCALL List_CutHead(List *pList);</P>
<P>extern void *&#9;LISTCALL List_CutTail(List *pList);</P>
<P>extern void *&#9;LISTCALL List_PeekHead(List *pList);</P>
<P>extern void *&#9;LISTCALL List_PeekTail(List *pList);</P>

<P>extern List *&#9;LISTCALL List_Next(List *pNode);</P>
<P>extern List *&#9;LISTCALL List_Prev(List *pNode);</P>

<P>extern void&#9;&#9;LISTCALL List_CutNode(List *pNode);</P>
<P>extern void&#9;&#9;LISTCALL List_DeleteNode(List *pNode);</P>
<P>extern void&#9;&#9;LISTCALL List_FreeNode(List *pNode);</P>
<P>extern void *&#9;LISTCALL List_NodeData(List *pNode);</P>

<P>extern List *&#9;List_Find(List *pList,void *Data);</P>

<P>/****</P>

<P>&#9;Iterate on a list via :</P>

<P>&#9;List *pNode,*pList;</P>
<P>&#9;for( pNode = List_Next(pList); pNode != pList; pNode = List_Next(pNode) )</P>
<P>&#9;{</P>
<P>&#9;&#9;//do stuff to pNode</P>
<P>&#9;}</P>

<P>****/</P>

<P>typedef struct Stack Stack;</P>

<P>extern Stack * &#9;LISTCALL Stack_Create(void);</P>
<P>extern void &#9;LISTCALL Stack_Destroy(Stack * pStack);</P>
<P>extern void &#9;LISTCALL Stack_Push_Func(Stack *pStack,void * Data);</P>
<P>extern void * &#9;LISTCALL Stack_Pop_Func(Stack *pStack);</P>
<P>extern int &#9;&#9;LISTCALL Stack_Extend(Stack *pStack);&#9;// returns new length</P>

<P>#ifdef _DEBUG</P>

<P>#define Stack_Push&#9;Stack_Push_Func</P>
<P>#define Stack_Pop&#9;Stack_Pop_Func</P>

<P>#else</P>

<P>// this struct is exposed only in release mode!</P>
<P>// don't look into it!</P>

<P>struct Stack</P>
<P>{</P>
<P>&#9;void ** Buffer, **End;</P>
<P>&#9;void ** Head;</P>
<P>&#9;int members;</P>
<P>};</P>

<P>//#define Stack_Push(pStack,Data)&#9;do { *((pStack)-&gt;Head)++ = (void *)(Data); if ( (pStack)-&gt;Head == (pStack)-&gt;End ) Stack_Extend(pStack); } while(0)</P>
<P>#define Stack_Push(pStack,Data)&#9;*((pStack)-&gt;Head)++ = (void *)(Data), ( (pStack)-&gt;Head != (pStack)-&gt;End ) || Stack_Extend(pStack)</P>
<P>#define Stack_Pop(pStack)&#9;&#9;( ((pStack)-&gt;Head == (pStack)-&gt;Buffer) ? NULL : *( -- ((pStack)-&gt;Head) ) )</P>

<P>#endif</P>

<P>typedef struct Link Link;</P>

<P>extern Link * &#9;LISTCALL Link_Create(void);</P>
<P>extern void&#9;&#9;LISTCALL Link_Destroy(Link * pLink);</P>
<P>extern void&#9;&#9;LISTCALL Link_Push(Link *pLink,void * Data);</P>
<P>extern void *&#9;LISTCALL Link_Pop(Link *pLink);</P>
<P>extern void *&#9;LISTCALL Link_Peek(Link *pLink);</P>

<P>typedef struct LinkNode LinkNode;</P>

<P>/************************************/</P>
<P>/*** a radix of each type ****/</P>

<P>typedef struct RadixList RadixList;</P>

<P>extern RadixList * RadixList_Create(int RadixListMax);</P>
<P>extern void RadixList_Destroy(RadixList * pRadixList);</P>
<P>extern List * RadixList_Add(RadixList *pRadixList,void * Data,int Key);</P>
<P>&#9;// returns a pointer to the node created</P>
<P>extern void * RadixList_CutMax(RadixList *pRadixList,int * pMaxKey);</P>
<P>extern void * RadixList_CutMin(RadixList *pRadixList,int * pMinKey);</P>
<P>extern void * RadixList_CutKey(RadixList *pRadixList,int Key);</P>

<P>typedef struct RadixLN RadixLN;</P>

<P>extern RadixLN * RadixLN_Create(int RadixLNMax);</P>
<P>extern void RadixLN_Destroy(RadixLN * pRadixLN);</P>
<P>extern void RadixLN_AddTail(RadixLN *pRadixLN,LinkNode * LN,int Key);</P>
<P>extern void RadixLN_AddHead(RadixLN *pRadixLN,LinkNode * LN,int Key);</P>
<P>extern LinkNode * RadixLN_CutMax(RadixLN *pRadixLN,int * pMaxKey);</P>
<P>extern LinkNode * RadixLN_CutMin(RadixLN *pRadixLN,int * pMinKey);</P>
<P>extern LinkNode * RadixLN_CutKey(RadixLN *pRadixLN,int Key);</P>
<P>extern LinkNode * RadixLN_PeekMax(RadixLN *pRadixLN,int * pMaxKey);</P>
<P>extern LinkNode * RadixLN_PeekMin(RadixLN *pRadixLN,int * pMinKey);</P>

<P>typedef struct RadixLink RadixLink;</P>

<P>extern&#9;&#9;&#9;RadixLink * RadixLink_Create(int RadixLinkMax);</P>
<P>extern void&#9;&#9;RadixLink_Destroy(RadixLink * pRadixLink);</P>
<P>extern void&#9;&#9;RadixLink_Add(RadixLink *pRadixLink,void * Data,int Key);</P>
<P>extern void *&#9;RadixLink_CutMax(RadixLink *pRadixLink,int * pMaxKey);</P>
<P>extern void *&#9;RadixLink_CutMin(RadixLink *pRadixLink,int * pMinKey);</P>
<P>extern void *&#9;RadixLink_CutKey(RadixLink *pRadixLink,int Key);</P>
<P>extern void&#9;&#9;RadixLink_Grow(RadixLink *pRadixLink,int NewMax);</P>

<P>/******************************/</P>

<P>typedef struct Hash Hash;</P>
<P>typedef struct HashNode HashNode;</P>

<P>extern Hash *&#9;Hash_Create(void);</P>
<P>extern void&#9;&#9;Hash_Destroy(Hash *pHash);</P>
<P>HashNode *&#9;LISTCALL Hash_Add(Hash *pHash,uint32 Key,uint32 Data);</P>
<P>void&#9;&#9;LISTCALL Hash_DeleteNode(Hash *pHash,HashNode *pNode);</P>
<P>HashNode *&#9;LISTCALL Hash_Get(Hash *pHash,uint32 Key,uint32 *pData);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;// pdata is optional</P>
<P>HashNode *&#9;LISTCALL Hash_WalkNext(Hash *pHash,HashNode *pCur);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;//use pCur == NULL to start walking</P>

<P>uint32&#9;&#9;LISTCALL Hash_NumMembers(Hash *pHash);</P>

<P>void&#9;HashNode_SetData(HashNode *pNode,uint32 Data);</P>
<P>void&#9;HashNode_GetData(HashNode *pNode,uint32 *pKey,uint32 *pData);</P>
<P>uint32&#9;HashNode_Key(HashNode *pNode);</P>
<P>uint32&#9;HashNode_Data(HashNode *pNode);</P>

<P>uint32&#9;Hash_StringToKey(const char * String);</P>

<P>/******************************/</P>

<P>struct LinkNode </P>
<P>{</P>
<P>&#9;LinkNode *Next,*Prev;</P>
<P>}; </P>

<P>#define zLN_InitList(List)&#9;&#9;&#9;do { (List)-&gt;Next = List; (List)-&gt;Prev = List; } while(0)</P>
<P>#define zLN_Cut(Node)&#9;&#9;&#9;&#9;do { (Node)-&gt;Prev-&gt;Next = (Node)-&gt;Next; (Node)-&gt;Next-&gt;Prev = (Node)-&gt;Prev; zLN_InitList(Node); } while(0)</P>
<P>#define zLN_Fix(Node)&#9;&#9;&#9;&#9;do { (Node)-&gt;Prev-&gt;Next = Node; (Node)-&gt;Next-&gt;Prev = Node; } while(0)</P>
<P>#define zLN_AddAfter(Node,List)&#9;&#9;do { (Node)-&gt;Prev = List; (Node)-&gt;Next = (List)-&gt;Next; LN_Fix(Node); } while(0)</P>
<P>#define zLN_AddBefore(Node,List)&#9;do { (Node)-&gt;Next = List; (Node)-&gt;Prev = (List)-&gt;Prev; LN_Fix(Node); } while(0)</P>
<P>#define zLN_Walk_Editting(Node,List,Holder)&#9;for( Node = (List)-&gt;Next; (Node) != (List) &amp;&amp; ((Holder) = (Node)-&gt;Next) != NULL ; Node = Holder )</P>
<P>#define zLN_Walk(Node,List)&#9;&#9;&#9;for( Node = (List)-&gt;Next; (Node) != (List) ; Node = (Node)-&gt;Next )</P>
<P>#define zLN_EmptyList(List)&#9;&#9;&#9;( (List)-&gt;Next == (List) )</P>

<P>#define LN_InitList(List)&#9;&#9;&#9;zLN_InitList((LinkNode *)List)</P>
<P>#define LN_Cut(Node)&#9;&#9;&#9;&#9;zLN_Cut((LinkNode *)Node)</P>
<P>#define LN_Fix(Node)&#9;&#9;&#9;&#9;zLN_Fix((LinkNode *)Node)</P>
<P>#define LN_AddAfter(Node,List)&#9;&#9;zLN_AddAfter((LinkNode *)Node,(LinkNode *)List)</P>
<P>#define LN_AddBefore(Node,List)&#9;&#9;zLN_AddBefore((LinkNode *)Node,(LinkNode *)List)</P>
<P>#define LN_Walk(Node,List)&#9;&#9;&#9;zLN_Walk((LinkNode *)Node,(LinkNode *)List)</P>
<P>#define LN_Walk_Editting(Node,List,Holder)&#9;&#9;&#9;zLN_Walk_Editting((LinkNode *)Node,(LinkNode *)List,((LinkNode *)Holder))</P>
<P>#define LN_EmptyList(List)&#9;&#9;&#9;zLN_EmptyList((LinkNode *)List)</P>
<P>#define LN_Prev(Node)&#9;&#9;&#9;&#9;(void *)(((LinkNode *)Node)-&gt;Prev)</P>
<P>#define LN_Next(Node)&#9;&#9;&#9;&#9;(void *)(((LinkNode *)Node)-&gt;Next)</P>

<P>#define LN_Null(node)&#9;LN_InitList(node)</P>

<P>LinkNode *&#9;LISTCALL LN_CutHead(LinkNode *pList);</P>
<P>LinkNode *&#9;LISTCALL LN_CutTail(LinkNode *pList);</P>

<P>int LN_ListLen(LinkNode *pList);</P>

<P>#define LN_AddHead(list,node)&#9;LN_AddAfter(node,list)</P>
<P>#define LN_AddTail(list,node)&#9;LN_AddBefore(node,list)</P>
<P>#define LN_IsEmpty&#9;LN_EmptyList</P>

<P>&nbsp;</P>
<P>&#9;/* use LN_Walk as :</P>
<P>&#9;*</P>

<P>&#9;&#9;void doStuffOnAllNodes(LinkNode *pList)</P>
<P>&#9;&#9;{</P>
<P>&#9;&#9;&#9;LinkNode *pNode;</P>
<P>&#9;&#9;&#9;LN_Walk(pNode,pList) {</P>
<P>&#9;&#9;&#9;&#9;doStuff(pNode);</P>
<P>&#9;&#9;&#9;}</P>
<P>&#9;&#9;}</P>

<P>&#9;*</P>
<P>&#9;*/</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif  // LIST_H</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069944">NetPlay.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  NetPlay.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: DirectPlay wrapper                                                     */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_NETPLAY_H</P>
<P>#define GE_NETPLAY_H</P>

<P>#include &lt;windows.h&gt;</P>
<P>#include &lt;dplay.h&gt;</P>

<P>#include "BaseType.h"</P>

<P>#ifdef&#9;__cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>// ************************************************************************************</P>
<P>//&#9;Defines</P>
<P>// ************************************************************************************</P>
<P>#define NETPLAY_OPEN_CREATE&#9;&#9;1</P>
<P>#define NETPLAY_OPEN_JOIN&#9;&#9;2</P>

<P>&nbsp;</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;char&#9;Desc[200];&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Description of Service provider</P>
<P>&#9;GUID&#9;Guid;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Global Service Provider GUID</P>
<P>} SP_DESC;</P>

<P>// must match stuct AFX_SESSION in cengine.h</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;char&#9;SessionName[200];&#9;&#9;&#9;&#9;&#9;&#9;// Description of Service provider</P>
<P>&#9;GUID&#9;Guid;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Global Service Provider GUID</P>
<P>} SESSION_DESC;</P>

<P>extern&#9;SP_DESC&#9;&#9;&#9;&#9;&#9;GlobalSP;&#9;&#9;&#9;// Global info about the sp</P>
<P>extern  SESSION_DESC*&#9;&#9;&#9;GlobalSession;&#9;&#9;// Global sessions availible</P>
<P>extern&#9;LPGUID&#9;&#9;&#9;&#9;&#9;glpGuid;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>void DoDPError(HRESULT Hr);</P>
<P>BOOL InitNetPlay(LPGUID lpGuid);</P>
<P>BOOL NetPlayEnumSession(LPSTR IPAdress, SESSION_DESC** SessionList, DWORD* SessionNum);</P>
<P>BOOL NetPlayJoinSession(SESSION_DESC* SessionList);</P>
<P>BOOL NetPlayCreateSession(LPSTR SessionName, DWORD MaxPlayers);</P>
<P>BOOL NetPlayCreatePlayer(LPDPID lppidID, LPTSTR lptszPlayerName, HANDLE hEvent, LPVOID lpData, DWORD dwDataSize, geBoolean ServerPlayer);</P>
<P>BOOL NetPlayDestroyPlayer(DPID pid);</P>
<P>HRESULT NetPlaySend(DPID idFrom, DPID idTo, DWORD dwFlags, LPVOID lpData, DWORD dwDataSize);</P>
<P>HRESULT NetPlayReceive(LPDPID lpidFrom, LPDPID lpidTo, DWORD dwFlags, LPVOID lpData, LPDWORD lpdwDataSize);</P>
<P>BOOL DeInitNetPlay(void);</P>

<P>// HACK!!!! Function is in Engine.cpp (So NetPlay.C can call it...)</P>
<P>BOOL&#9;&#9;&#9;AFX_CPrintfC(char *String);</P>

<P>#ifdef&#9;__cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069945">PtrTypes.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  NetPlay.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: DirectPlay wrapper                                                     */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_NETPLAY_H</P>
<P>#define GE_NETPLAY_H</P>

<P>#include &lt;windows.h&gt;</P>
<P>#include &lt;dplay.h&gt;</P>

<P>#include "BaseType.h"</P>

<P>#ifdef&#9;__cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>// ************************************************************************************</P>
<P>//&#9;Defines</P>
<P>// ************************************************************************************</P>
<P>#define NETPLAY_OPEN_CREATE&#9;&#9;1</P>
<P>#define NETPLAY_OPEN_JOIN&#9;&#9;2</P>

<P>&nbsp;</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;char&#9;Desc[200];&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Description of Service provider</P>
<P>&#9;GUID&#9;Guid;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Global Service Provider GUID</P>
<P>} SP_DESC;</P>

<P>// must match stuct AFX_SESSION in cengine.h</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;char&#9;SessionName[200];&#9;&#9;&#9;&#9;&#9;&#9;// Description of Service provider</P>
<P>&#9;GUID&#9;Guid;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Global Service Provider GUID</P>
<P>} SESSION_DESC;</P>

<P>extern&#9;SP_DESC&#9;&#9;&#9;&#9;&#9;GlobalSP;&#9;&#9;&#9;// Global info about the sp</P>
<P>extern  SESSION_DESC*&#9;&#9;&#9;GlobalSession;&#9;&#9;// Global sessions availible</P>
<P>extern&#9;LPGUID&#9;&#9;&#9;&#9;&#9;glpGuid;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>void DoDPError(HRESULT Hr);</P>
<P>BOOL InitNetPlay(LPGUID lpGuid);</P>
<P>BOOL NetPlayEnumSession(LPSTR IPAdress, SESSION_DESC** SessionList, DWORD* SessionNum);</P>
<P>BOOL NetPlayJoinSession(SESSION_DESC* SessionList);</P>
<P>BOOL NetPlayCreateSession(LPSTR SessionName, DWORD MaxPlayers);</P>
<P>BOOL NetPlayCreatePlayer(LPDPID lppidID, LPTSTR lptszPlayerName, HANDLE hEvent, LPVOID lpData, DWORD dwDataSize, geBoolean ServerPlayer);</P>
<P>BOOL NetPlayDestroyPlayer(DPID pid);</P>
<P>HRESULT NetPlaySend(DPID idFrom, DPID idTo, DWORD dwFlags, LPVOID lpData, DWORD dwDataSize);</P>
<P>HRESULT NetPlayReceive(LPDPID lpidFrom, LPDPID lpidTo, DWORD dwFlags, LPVOID lpData, LPDWORD lpdwDataSize);</P>
<P>BOOL DeInitNetPlay(void);</P>

<P>// HACK!!!! Function is in Engine.cpp (So NetPlay.C can call it...)</P>
<P>BOOL&#9;&#9;&#9;AFX_CPrintfC(char *String);</P>

<P>#ifdef&#9;__cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069946">Resource.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>//{{NO_DEPENDENCIES}}</P>
<P>// Microsoft Developer Studio generated include file.</P>
<P>// Used by genesis.rc</P>
<P>//</P>

<P>// Next default values for new objects</P>
<P>// </P>
<P>#ifdef APSTUDIO_INVOKED</P>
<P>#ifndef APSTUDIO_READONLY_SYMBOLS</P>
<P>#define _APS_NEXT_RESOURCE_VALUE        101</P>
<P>#define _APS_NEXT_COMMAND_VALUE         40001</P>
<P>#define _APS_NEXT_CONTROL_VALUE         1000</P>
<P>#define _APS_NEXT_SYMED_VALUE           101</P>
<P>#endif</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069947">Sound.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Sound.h                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Brian Adelberg                                                              */</P>
<P>/*  Description: DirectSound wrapper                                                    */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef&#9;GE_SOUND_H</P>
<P>#define&#9;GE_SOUND_H</P>

<P>#ifdef&#9;__cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>// GENESIS_PUBLIC_APIS</P>

<P>typedef struct geSound_System&#9;geSound_System;</P>
<P>typedef struct geSound_Def&#9;&#9;geSound_Def;</P>
<P>typedef struct geSound&#9;&#9;&#9;geSound;</P>

<P>&nbsp;</P>
<P>#ifdef _INC_WINDOWS</P>
<P>&#9;// Windows.h must be previously included for this api to be exposed.</P>
<P>GENESISAPI&#9;geSound_System *geSound_CreateSoundSystem(HWND hWnd);</P>
<P>#endif</P>

<P>GENESISAPI&#9;void&#9;&#9;&#9;geSound_DestroySoundSystem(geSound_System *Sound);</P>

<P>&nbsp;</P>
<P>GENESISAPI&#9;geSound_Def&#9;   *geSound_LoadSoundDef(geSound_System *SoundS, geVFile *File);</P>
<P>GENESISAPI&#9;void&#9;&#9;&#9;geSound_FreeSoundDef(geSound_System *SoundS, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geSound_Def *SoundDef);</P>

<P>GENESISAPI&#9;geSound&#9;&#9;   *geSound_PlaySoundDef(geSound_System *SoundS, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geSound_Def *SoundDef, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Volume, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Pan, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Frequency, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean Loop);</P>
<P>GENESISAPI&#9;geBoolean&#9;&#9;geSound_StopSound(geSound_System *SoundS, geSound *Sound);</P>
<P>GENESISAPI&#9;geBoolean&#9;&#9;geSound_ModifySound(geSound_System *SoundS, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geSound *Sound, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Volume, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Pan, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Frequency);</P>
<P>GENESISAPI&#9;geBoolean&#9;&#9;geSound_SoundIsPlaying(geSound_System *SoundS, geSound *Sound);</P>
<P>GENESISAPI&#9;geBoolean&#9;&#9;geSound_SetMasterVolume( geSound_System *SoundS, geFloat Volume );</P>

<P>// GENESIS_PRIVATE_APIS</P>

<P>#ifdef&#9;__cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069948">Sound3D.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Sound3D.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Brian Adelberg                                                              */</P>
<P>/*  Description: 3D Sound code                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_SOUND3D_H</P>
<P>#define GE_SOUND3D_H</P>

<P>#include "BaseType.h"</P>
<P>#include "Sound.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>// GENESIS_PUBLIC_APIS</P>

<P>GENESISAPI&#9;void geSound3D_GetConfig(</P>
<P>&#9;&#9;&#9;const geWorld *World, </P>
<P>&#9;&#9;&#9;const geXForm3d *CameraTransform, </P>
<P>&#9;&#9;&#9;const geVec3d *SoundPos, </P>
<P>&#9;&#9;&#9;geFloat Min, </P>
<P>&#9;&#9;&#9;geFloat Ds,</P>
<P>&#9;&#9;&#9;geFloat *Volume,</P>
<P>&#9;&#9;&#9;geFloat *Pan,</P>
<P>&#9;&#9;&#9;geFloat *Frequency);</P>

<P>// GENESIS_PRIVATE_APIS</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069949">Tclip.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  TClip                                                                               */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige &amp; Charles Bloom                                                */</P>
<P>/*  Description: Triangle Clipping to the screen rectangle                              */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#ifndef GE_TCLIP_H</P>
<P>#define GE_TCLIP_H</P>

<P>#include "basetype.h"</P>
<P>#include "getypes.h"</P>
<P>#include "bitmap.h"</P>
<P>#include "engine.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>/*******</P>

<P>TClip is a state machine like OpenGL</P>

<P>you should call it like :</P>

<P>&#9;_Push()</P>
<P>&#9;_SetupEdges()</P>
<P>&#9;_SetTexture()</P>
<P>&#9;_Triangle()</P>
<P>&#9;_Triangle()</P>
<P>&#9;_SetTexture()</P>
<P>&#9;_Triangle()</P>
<P>&#9;_Triangle()</P>
<P>&#9;...</P>
<P>&#9;_Pop()</P>

<P>********/</P>

<P>void&#9;&#9;GENESISCC geTClip_SetupEdges(geEngine *Engine,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;geFloat&#9;LeftEdge, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;geFloat RightEdge,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;geFloat TopEdge ,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;geFloat BottomEdge,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;geFloat BackEdge);</P>

<P>geBoolean&#9;GENESISCC geTClip_Push(void);</P>
<P>geBoolean&#9;GENESISCC geTClip_Pop(void);</P>

<P>geBoolean&#9;GENESISCC geTClip_SetTexture(const geBitmap * Bitmap);</P>
<P>void&#9;&#9;GENESISCC geTClip_Triangle(const GE_LVertex TriVertex[3]);</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069950">Timer.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>#ifndef TIMER_H</P>
<P>#define TIMER_H</P>

<P>/****************************************************************************************/</P>
<P>/*  Timer                                                                               */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description: A nice little profiling utility                                        */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#include &lt;stdio.h&gt;</P>
<P>#include "tsc.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//{</P>

<P>extern FILE * timerFP;</P>
<P>extern int timerCount;</P>
<P>extern double time_Master;</P>

<P>extern void Timer_Start(void);</P>
<P>extern void Timer_Stop(void);</P>

<P>#ifdef DO_TIMER&#9;//}{</P>

<P>#pragma message("timer ON")</P>

<P>#define TIMER_VARS(func)&#9;static double time_##func =0.0;&#9;static tsc_type tsc_##func##1,tsc_##func##2;</P>

<P>#define TIMER_P(func)&#9;readTSC(tsc_##func##1)</P>
<P>#define TIMER_Q(func)&#9;do { readTSC(tsc_##func##2); time_##func += diffTSC(tsc_##func##1,tsc_##func##2); } while(0)</P>

<P>#define TIMER_REPORT(func)&#9;fprintf(timerFP,"%-20s : %1.6f : %2.1f %%\n", (#func) , (time_##func)/(double)timerCount , (time_##func)*100.0/(time_Master) );</P>

<P>#define TIMER_COUNT()&#9;timerCount++</P>

<P>#define TIMER_START()&#9;Timer_Start();</P>
<P>#define TIMER_STOP()&#9;Timer_Stop();</P>

<P>#else&#9;//}{</P>

<P>#pragma message("timer OFF")</P>

<P>#define TIMER_VARS(func)</P>
<P>#define TIMER_P(func)</P>
<P>#define TIMER_Q(func)</P>
<P>#define TIMER_REPORT(func)</P>

<P>#define TIMER_COUNT()</P>

<P>#define TIMER_START()</P>
<P>#define TIMER_STOP()</P>

<P>#endif //}{</P>

<P>/**********</P>

<P>//example usage:</P>

<P>TIMER_VARS(test1);</P>
<P>TIMER_VARS(test2);</P>

<P>int main(int argc,char *argv[])</P>
<P>{</P>
<P>int i,j;</P>

<P>&#9;timerFP = stdout;</P>

<P>&#9;TIMER_START();</P>

<P>&#9;&#9;TIMER_P(test1);</P>

<P>&#9;&#9;for(i=0;i&lt;1000;i++)</P>
<P>&#9;&#9;{</P>
<P>&#9;&#9;&#9;TIMER_P(test2);</P>
<P>&#9;&#9;&#9;j = 99/(i+1);</P>
<P>&#9;&#9;&#9;TIMER_Q(test2);</P>
<P>&#9;&#9;}</P>
<P>&#9;&#9;&#9;</P>
<P>&#9;&#9;TIMER_Q(test1);</P>

<P>&#9;TIMER_COUNT();</P>
<P>&#9;TIMER_STOP();</P>

<P>&#9;TIMER_REPORT(test2);</P>
<P>&#9;TIMER_REPORT(test1);</P>

<P>return 0;</P>
<P>}</P>

<P>**********/</P>

<P>//}</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif // TIMER_H</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069951">TSC.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  TSC                                                                                 */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description: tsc accessors                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#ifndef TSC_H</P>
<P>#define TSC_H</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>/**********</P>
<P>*</P>

<P>&#9;routines to access the TSC</P>
<P>&#9;will do nothing unless you compile tsc.c with _TSC turned on</P>

<P>&#9;to convert clocks to seconds we use this MHZ define:</P>

<P>*</P>
<P>********/</P>

<P>#define _TSC_CPU_MHZ&#9;300</P>

<P>&#9;// show() will Pop() two and print the delta to log()</P>
<P>&#9;// does nothing unless debug is on</P>

<P>extern void pushTSC(void);</P>

<P>&#9;// the pop reads once &amp; pop once &amp; take difference</P>

<P>extern double popTSC(void);</P>
<P>extern void showPopTSC(const char *tag);</P>
<P>extern void showPopTSCper(const char *tag,int items,const char *itemTag);</P>

<P>&#9;// primitives</P>

<P>typedef unsigned long tsc_type [2];</P>

<P>extern void readTSC(unsigned long *tsc);</P>
<P>extern double diffTSC(unsigned long *tsc1,unsigned long*tsc2);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<I><P><A NAME="_Toc454069952">OpenSource/Source/Actor Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>This is the subdirectory which contains all the files for model movement and model display.</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069953">Actor.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  ACTOR.H                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description:  Actor interface&#9;&#9;                                                */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>/*   Actor</P>
<P>&#9;</P>
<P>&#9;This object is designed to support character animation.</P>
<P>&#9;There are two basic objects to deal with.  </P>
<P>&#9;</P>
<P>&#9;Actor Definition (geActor_Def)</P>
<P>&#9;&#9;A geActor_Def embodies the geometry (polygon, and bone information), </P>
<P>&#9;&#9;and a library of motions that can be applied to that geometry.</P>

<P>&#9;Actor</P>
<P>&#9;&#9;A geActor is an instance of an actor definition.  The definition is used for </P>
<P>&#9;&#9;the geometry, but all additional settings, such as the bone pose, lighting information,</P>
<P>&#9;&#9;and cuing information is unique for a geActor.</P>
<P>// GENESIS_PRIVATE_API</P>
<P>&#9;An Actor Definition is created either from an existing Actor Definition file, or from scratch by </P>
<P>&#9;first creating a geBody and geMotions and selecting these into an Actor.  If the Actor Definition</P>
<P>&#9;is constructed from scratch, the objects selected into it (via SetBody and AddMotion) are</P>
<P>&#9;then 'owned' by the actor and will be destroyed along with the Actor when it is destroyed.</P>
<P>    Of course, when the Actor is loaded from a file, the Body and Motion it creates as it is</P>
<P>&#9;loaded are cleaned up when the Actor is destroyed.</P>

<P>&#9;Once an Actor is created, prepare it for rendering and animating by calling </P>
<P>&#9;Actor_RenderPrep().  This must be called (and it must succeed) before any render or</P>
<P>&#9;pose setting functions can be called.</P>
<P>// GENESIS_PUBLIC_API</P>

<P>&#9;There are two ways to use an Actor.</P>
<P>&#9;Direct Control</P>
<P>&#9;&#9;One method is to directly control the skeleton configuration.  Use _SetPose() to set its </P>
<P>&#9;&#9;skeleton using a geMotion animation.  The pose is positioned in world space relative to the </P>
<P>&#9;&#9;transform given in SetPose().  Whenever a new skeleton pose is required, call _SetPose() </P>
<P>&#9;&#9;to reposition the skeleton for a new point in time. </P>

<P>&#9;&#9;More complex positioning can be achieved by blending more than one animation.  Use</P>
<P>&#9;&#9;_BlendPose() after a _SetPose() to blend the second geMotion into the first.  Additional</P>
<P>&#9;&#9;blends can be applied by additional _BlendPose() calls.  Each blend is performed on the</P>
<P>&#9;&#9;the existing skeleton (the results of any previous blends).</P>
<P>&#9;Cuing</P>
<P>&#9;&#9;Another method is to 'cue' up motions that are applied with parameterized blending over time.</P>
<P>&#9;&#9;A cued motion takes effect 'now' in time.  The Actor advances in time and repositions itself</P>
<P>&#9;&#9;according to its currently cued motions with a call to _AnimationStep().  AnimationStep() </P>
<P>&#9;&#9;redefines what the actor thinks 'now' is.  This causes historical cues to be forgotten, and </P>
<P>&#9;&#9;motions that are no longer valid are cleaned up.  AnimationTestStep() can be used to position </P>
<P>&#9;&#9;the actor for potential queries with its currently cued motions at some arbitrary future time </P>
<P>&#9;&#9;- relative to the last AnimationTestStep() call.  AnimationNudge() applies a given transform </P>
<P>&#9;&#9;'instantly' to the current actor's cue list.  This is usefull for moving the actor as a </P>
<P>&#9;&#9;result of a collision with another object.</P>

<P>&#9;If a motion contains joint information that does not exactly match the Actor's skeleton </P>
<P>&#9;joints, only the joints that match by name are applied.  So a geMotion can be applied to</P>
<P>&#9;a portion of the Actor, or a geMotion that has more joint information than the skeleton can</P>
<P>&#9;be applied and the extra joint information is ignored.  </P>
<P>&#9; </P>
<P>&#9;Examples of this:  If the Actor is a biped and has no tail, but the motion is for a </P>
<P>&#9;biped with a tail, the geMotion can be applied, but the tail information will be ignored.</P>
<P>&#9;Also if there is a geMotion for only a left arm, it can be applied and it will only affect</P>
<P>&#9;the left arm of the Actor, and consequently its left hand and fingers, but no other </P>
<P>&#9;bones that are not children of the affected bones will be changed.</P>

<P>&#9; &#9;</P>
<P>*/</P>
<P>#ifndef GE_ACTOR_H</P>
<P>#define GE_ACTOR_H</P>

<P>#include "genesis.h"&#9;&#9;&#9;&#9;</P>
<P>#include "basetype.h"</P>
<P>#include "extbox.h"</P>
<P>#include "bitmap.h"</P>

<P>#include "Motion.h"</P>

<P>#ifdef GE_WORLD_H</P>
<P>#include "camera.h"</P>
<P>#include "Frustum.h"</P>
<P>#endif</P>

<P>#include "Body.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>// GENESIS_PUBLIC_APIS</P>

<P>#ifndef GE_ACTOR_ENUMS</P>
<P>#define GE_ACTOR_ENUMS</P>
<P>typedef enum </P>
<P>{</P>
<P>&#9;&#9;GE_ACTOR_BLEND_LINEAR,&#9;&#9;// Treats the blending amount as a linear value</P>
<P>&#9;&#9;GE_ACTOR_BLEND_HERMITE&#9;&#9;// Applies a parametric smoothing curve to the blending amount</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//  so that a linear change in BlendAmount parameters will</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//  result in a smooth (non-linear) change in blending.</P>
<P>} geActor_BlendingType;</P>

<P>#endif</P>

<P>typedef struct geActor geActor;&#9;&#9;&#9;// an instance of an actor</P>
<P>typedef struct geActor_Def geActor_Def;&#9;&#9;// the deinition of an actor's geometry/bone structure</P>

<P>&nbsp;</P>
<P>// GENESIS_PRIVATE_APIS</P>

<P>//---------------------------------------------------------------------------------</P>
<P>//   Creation/Destruction functions</P>
<P>//---------------------------------------------------------------------------------</P>
<P>&#9;// Create an 'empty' Actor Definition.</P>
<P>GENESISAPI geActor_Def *GENESISCC geActor_DefCreate(void);</P>

<P>&#9;// Create an Actor Definition from a file image.</P>
<P>GENESISAPI geActor_Def *GENESISCC geActor_DefCreateFromFile(geVFile *pFile);</P>

<P>&#9;// Create an additional reference (owner) for the Actor_Definition</P>
<P>GENESISAPI void GENESISCC geActor_DefCreateRef(geActor_Def *pActorDefinition);</P>

<P>&#9;// Destroy a geActor_Def (its geBody and its geMotions)  Actors that rely on this definition become invalid.</P>
<P>&#9;// can fail if there are actors still referencing this definition.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_DefDestroy(geActor_Def **pActorDefinition);</P>

<P>&#9;// Create an Actor instance associated with the given Actor Definition </P>
<P>GENESISAPI geActor *GENESISCC geActor_Create(geActor_Def *ActorDefinition);</P>

<P>&#9;// Create an additional reference (owner) for the Actor</P>
<P>GENESISAPI void GENESISCC geActor_CreateRef(geActor *Actor);</P>

<P>&#9;// Give the Actor Definition a Body.  geActor becomes responsible for its destruction.</P>
<P>&#9;// sets up default materials as referenced by the Body.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_SetBody( geActor_Def *ActorDefinition, geBody *geBodyGeometry);</P>

<P>&#9;// Adds a geMotion to the Actor Definition's library.  The ActorDefinition becomes responsible for its destruction.</P>
<P>&#9;// returns the library index to the new geMotion.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AddMotion(geActor_Def *ActorDefinition, geMotion *M, int *Index);</P>

<P>&#9;// Destroy an Actor.  </P>
<P>GENESISAPI void GENESISCC geActor_Destroy(geActor **pA);</P>

<P>GENESISAPI geBoolean GENESISCC geActor_DefIsValid(const geActor_Def *A);</P>
<P>GENESISAPI geBoolean GENESISCC geActor_IsValid(const geActor *A);</P>

<P>// GENESIS_PUBLIC_APIS</P>
<P>//---------------------------------------------------------------------------------</P>
<P>//   Queries </P>
<P>//---------------------------------------------------------------------------------</P>
<P>// GENESIS_PRIVATE_APIS</P>

<P>&#9;// In general: Objects retuned from Get functions should not not be destroyed. </P>
<P>&#9;// if ownership is desired, call the objects _CreateRef() function to create another owner. </P>
<P>&#9;// (An 'owner' has access to the object regardless of the number of other owners, and </P>
<P>&#9;// an owner must call the object's _Destroy() function to relinquish ownership )</P>

<P>&#9;// Returns the Actor Definition associated with Actor A</P>
<P>GENESISAPI geActor_Def *GENESISCC geActor_GetActorDef(const geActor *A);</P>

<P>&#9;// Writes an existing geActor to a file image.  Returns GE_TRUE on success, GE_FALSE on failure.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_DefWriteToFile(const geActor_Def *A, geVFile *pFile);</P>
<P>&#9;</P>
<P>&#9;// Returns a geBody pointer from the geActor </P>
<P>GENESISAPI geBody *GENESISCC geActor_GetBody(const geActor_Def *ActorDefinition);</P>

<P>&#9;// Returns GE_TRUE if the actor definition has a bone named 'Name'</P>
<P>GENESISAPI geBoolean GENESISCC geActor_DefHasBoneNamed(const geActor_Def *Ad, const char *Name );</P>

<P>&#9;// Selects a blending type.  BlendingType only affects the meaning of the </P>
<P>&#9;// BlendAmount parameter for the blend functions.  Can be changed anytime.</P>
<P>GENESISAPI void GENESISCC geActor_SetBlendingType( geActor *A, geActor_BlendingType BlendingType );</P>

<P>// GENESIS_PUBLIC_APIS</P>

<P>&#9;// Returns the number of geMotions in the geActors geMotion library.</P>
<P>GENESISAPI int GENESISCC geActor_GetMotionCount(const geActor_Def *ActorDefinition);</P>

<P>&#9;// Returns a geMotion pointer from the geActors geMotion library</P>
<P>&#9;//   This is an aliased pointer - Not a copy.  Changes to this motion will be reflected</P>
<P>&#9;//   in the actor.  Destroying this return motion will confuse the actor.</P>
<P>&#9;// Index must be in range [0..geActor_GetMotionCount-1]</P>
<P>GENESISAPI geMotion *GENESISCC geActor_GetMotionByIndex(const geActor_Def *ActorDefinition, int Index );</P>

<P>&#9;// Returns a geMotion pointer from the geActors geMotion library</P>
<P>&#9;//   This is an aliased pointer - Not a copy.  Changes to this motion will be reflected</P>
<P>&#9;//   in the actor.  Destroying this return motion will confuse the actor.</P>
<P>&#9;// if there is no motion that matches the given name, the return value will be NULL</P>
<P>GENESISAPI geMotion *GENESISCC geActor_GetMotionByName(const geActor_Def *ActorDefinition, const char *Name );</P>

<P>&#9;// Returns a motion name given an ActorDef and a motion index.</P>
<P>GENESISAPI const char *GENESISCC geActor_GetMotionName(const geActor_Def *ActorDefinition, int Index );</P>

<P>&#9;// Returns the number of materials for an instance of an actor.</P>
<P>GENESISAPI int GENESISCC geActor_GetMaterialCount(const geActor *A);</P>

<P>&#9;// Returns the current material for an instance of an actor</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetMaterial(const geActor *Actor, int MaterialIndex,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap **Bitmap, geFloat *Red, geFloat *Green, geFloat *Blue);</P>

<P>&#9;// Allows a material to be overriden in an actor instance</P>
<P>GENESISAPI geBoolean GENESISCC geActor_SetMaterial(geActor *Actor, int MaterialIndex,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap *Bitmap,  geFloat Red,  geFloat Green,  geFloat Blue);</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&#9;// Gets the current transform for a single bone in A.  (actor space-&gt;world space transform)</P>
<P>&#9;// with a NULL BoneName, this returns the current 'root' transform</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetBoneTransform(const geActor *A, const char *BoneName, geXForm3d *Transform);</P>
<P>&#9;</P>
<P>&#9;// Gets the extent box (axial-aligned bounding box) for a given bone (for the current pose)</P>
<P>&#9;// if BoneName is NULL, gets the a general bounding box from the body of the actor if it has been set.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetBoneExtBox(const geActor *A,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; const char *BoneName,geExtBox *ExtBox);</P>

<P>&#9;// Gets the non-axial-aligned bounding box for a given bone (for the current pose)</P>
<P>&#9;//  The box is specified by a corner, and</P>
<P>&#9;//  a non-normalized orientation transform.  Add DX,DY,DZ components </P>
<P>&#9;//  of the orientation to get other corners of the box</P>
<P>&#9;// if BoneName is NULL, gets the a general bounding box from the body of the actor if it has been set.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetBoneBoundingBox(const geActor *A,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; const char *BoneName,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; geVec3d *Corner,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; geVec3d *DX,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; geVec3d *DY,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; geVec3d *DZ);</P>

<P>&#9;// Gets the current axial-aligned bounding box for an actor's bone configuration</P>
<P>&#9;// takes all bones into account</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetDynamicExtBox( const geActor *A, geExtBox *ExtBox);</P>
<P>&#9;</P>
<P>&#9;// Gets an assigned general non changing bounding box from the actor</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetExtBox(const geActor *A, geExtBox *ExtBox);</P>

<P>&#9;// Sets an assigned general non changing bounding box from the actor</P>
<P>GENESISAPI geBoolean GENESISCC geActor_SetExtBox(geActor *A, const geExtBox *ExtBox,</P>
<P>&#9;&#9;&#9;&#9;&#9;const char *CenterBoxOnThisNamedBone);&#9;&#9;// NULL uses root position of actor</P>

<P>&#9;// Gets the rendering hint bounding box from the actor</P>
<P>&#9;//   if the RenderHintExtBox is disabled, Enabled is GE_FALSE, and the box returned has zero dimensions, </P>
<P>&#9;//   centered at the root position of the actor.  If the RenderHintExtBox is enabled, Enabled is</P>
<P>&#9;//   GE_TRUE, and the box returned is the one set with _SetRenderHintExtBox, offset by the </P>
<P>&#9;//   bone position of the bone named in _SetRenderHintExtBox().</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetRenderHintExtBox(const geActor *A, geExtBox *Box, geBoolean *Enabled);</P>

<P>&#9;// Sets a rendering hint bounding box from the actor.  Increases performance by </P>
<P>&#9;//   enabling the rendering of the actor to occur only if the box is visible.</P>
<P>&#9;//   If the box is not visible, a detailed analysis of the actor's current geometry is avoided.</P>
<P>&#9;//   This does allow errors to occur: </P>
<P>&#9;//   If the actor has a bit of geometry that extends outside this box for some</P>
<P>&#9;//   animation, that extended geometry may not be drawn, if the box if off-screen.   </P>
<P>&#9;//   If the render hint box is not set, the engine will make no conservative assumptions </P>
<P>&#9;//   about the visibility of an actor - it will always be drawn if any portion of it is</P>
<P>&#9;//   visible.</P>
<P>&#9;//   To attach the box to the 'root' bone, pass NULL for CenterBoxOnThisNamedBone</P>
<P>&#9;//   For disabling the hint box: (disabled is default) pass Box with zero mins and maxs</P>
<P>GENESISAPI geBoolean GENESISCC geActor_SetRenderHintExtBox(geActor *A, const geExtBox *Box,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const char *CenterBoxOnThisNamedBone );</P>

<P>&nbsp;</P>
<P>&#9;// Returns the pointer which was set with geActor_SetUserData.  NULL if not set.</P>
<P>GENESISAPI void *GENESISCC geActor_GetUserData(const geActor *A);</P>

<P>&#9;// Sets the actors user data pointer to the given value.  For clients only.</P>
<P>GENESISAPI void GENESISCC geActor_SetUserData(geActor *A, void *UserData);</P>

<P>&nbsp;</P>
<P>//--------------------------------------------------------------------------------</P>
<P>//   Posing and Rendering</P>
<P>//--------------------------------------------------------------------------------</P>

<P>// GENESIS_PRIVATE_APIS</P>

<P>#ifdef GE_WORLD_H</P>
<P>&#9;// Prepares the geActor for rendering and posing.  Call Once once the actor is fully created.</P>
<P>&#9;// Must be called prior to render/pose/setworldtransform </P>
<P>geBoolean GENESISCC geActor_RenderPrep( geActor *A, geWorld *World);</P>

<P>&#9;// Draws the geActor.  (RenderPrep must be called first)</P>
<P>geBoolean GENESISCC geActor_RenderThroughFrustum(const geActor *A, geEngine *Engine, geWorld *World, geCamera *Camera, Frustum_Info *FInfo);</P>
<P>geBoolean GENESISCC geActor_Render(const geActor *A, geEngine *Engine, geWorld *World, geCamera *Camera);</P>
<P>#endif</P>

<P>// GENESIS_PUBLIC_APIS</P>

<P>&#9;// Poses the actor in its default pose</P>
<P>&#9;// Transform is where to position the root for this pose.</P>
<P>&#9;//  if Transform is NULL, the root for the pose is assumed to be the root of the actor.</P>
<P>GENESISAPI void GENESISCC geActor_ClearPose(geActor *A, const geXForm3d *Transform);</P>

<P>&#9;// Poses the actor using given motion M at a time offset of Time</P>
<P>&#9;// Transform is where to position the root for this pose.</P>
<P>&#9;//  if Transform is NULL, the root for the pose is assumed to be the root of the actor.</P>
<P>GENESISAPI void GENESISCC geActor_SetPose(geActor *A, const geMotion *Motion, geFloat Time, const geXForm3d *Transform);</P>

<P>&#9;// Blends the current pose of the geActor with </P>
<P>&#9;//  a new pose using motion M at a time offset of Time</P>
<P>&#9;// A BlendAmount of 0 will result in the existing pose, A BlendAmount of 1 will</P>
<P>&#9;// result in the new pose from M.  The BlendingType set by _SetBlendingType() determines</P>
<P>&#9;// the blending function between 0 and 1</P>
<P>&#9;// Transform is where to position the root for this pose.</P>
<P>&#9;//  if Transform is NULL, the root for the pose is assumed to be the root of the actor.</P>
<P>GENESISAPI void GENESISCC geActor_BlendPose(geActor *A, const geMotion *Motion, geFloat Time,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d *Transform, geFloat BlendAmount);</P>

<P>&nbsp;</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetBoneAttachment(const geActor *A, const char *BoneName, geXForm3d *Transform);</P>
<P>GENESISAPI geBoolean GENESISCC geActor_SetBoneAttachment(geActor *A, const char *BoneName, geXForm3d *Transform);</P>

<P>// GENESIS_PRIVATE_APIS</P>

<P>GENESISAPI geBoolean GENESISCC geActor_Attach( geActor *Slave,  const char *SlaveBoneName,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geActor *Master, const char *MasterBoneName, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d *Attachment);</P>

<P>GENESISAPI void GENESISCC geActor_Detach(geActor *Slave);</P>

<P>&nbsp;</P>
<P>// GENESIS_PUBLIC_APIS</P>
<P>GENESISAPI geBoolean GENESISCC geActor_SetLightingOptions(geActor *A,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean UseFillLight,&#9;&#9;&#9;&#9;// GE_TRUE or GE_FALSE</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *FillLightNormal,&#9;&#9;// normalized vector</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat FillLightRed,&#9;&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat FillLightGreen,&#9;&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat FillLightBlue,&#9;&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat AmbientLightRed,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat AmbientLightGreen,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat AmbientLightBlue,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean AmbientLightFromFloor,&#9;// GE_TRUE or GE_FALSE</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int MaximumDynamicLightsToUse,&#9;&#9;// 0 for none</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const char *LightReferenceBoneName, //NULL for root</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean PerBoneLighting);&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// if GE_TRUE, then dynamic lighting attenuation and direction is computed</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// for each bone.  if GE_FALSE, then the computations are relative to the </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// single bone named by the LightReferenceBoneName</P>

<P>GENESISAPI geBoolean GENESISCC geActor_GetLightingOptions(const geActor *A,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean *UseFillLight,&#9;&#9;&#9;// GE_TRUE or GE_FALSE</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *FillLightNormal,&#9;&#9;&#9;// normalized vector</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *FillLightRed,&#9;&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *FillLightGreen,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *FillLightBlue,&#9;&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *AmbientLightRed,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *AmbientLightGreen,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *AmbientLightBlue,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean *UseAmbientLightFromFloor,// GE_TRUE or GE_FALSE</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int *MaximumDynamicLightsToUse,&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const char **LightReferenceBoneName,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean *PerBoneLighting);&#9;&#9;// NULL for root</P>

<P>&nbsp;</P>
<P>GENESISAPI void GENESISCC geActor_SetScale(geActor *A, geFloat ScaleX,geFloat ScaleY,geFloat ScaleZ);</P>

<P>GENESISAPI geBoolean GENESISCC geActor_SetShadow(geActor *A, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;geBoolean DoShadow, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;geFloat Radius,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geBitmap *ShadowMap,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const char * BoneName);</P>

<P>//  Animation Cuing API:</P>
<P>// high level Actor animation:  The principle is that motions can be applied to an actor</P>
<P>// and the actor will keep track of which motions are currently appropriate.  Call </P>
<P>//&#9;_AnimationStep() to compute a new pose for an elapsed time interval.  The new pose</P>
<P>//  will take into account all motions that are 'currently' cued up to be set or blended.</P>

<P>&nbsp;</P>
<P>&#9;// cue up a new motion.  The motion begins at the current time.  The motion can be </P>
<P>&#9;// blended in or out over time and time scaled.  If the return value is GE_FALSE, the </P>
<P>&#9;// animation was not cued up (failure implies Actor is incompletely initialized).</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AnimationCue( </P>
<P>&#9;&#9;geActor *A,&#9;&#9;&#9;&#9;&#9;&#9;// actor to apply animation to</P>
<P>&#9;&#9;geMotion *Motion,&#9;&#9;&#9;&#9;// motion to Cue</P>
<P>&#9;&#9;geFloat TimeScaleFactor,&#9;&#9;// time scale to apply to cued motion</P>
<P>&#9;&#9;geFloat TimeIntoMotion,&#9;&#9;&#9;// time offset to begin motion with (Not TimeScaled)</P>
<P>&#9;&#9;geFloat BlendTime,&#9;&#9;&#9;&#9;// time to apply a blend. </P>
<P>&#9;&#9;geFloat BlendFromAmount,&#9;&#9;// blend value at current time</P>
<P>&#9;&#9;geFloat BlendToAmount,&#9;&#9;&#9;// blend value after BlendTime time has elapsed</P>
<P>&#9;&#9;const geXForm3d *MotionTransform);&#9;// local transform to adjust motion by (NULL implies NO transform)</P>

<P>&#9;// removes the last animation cue that was cued up.  Can be called repeatedly to successively</P>
<P>&#9;// remove older and older cues.  Returns GE_TRUE when a cue was removed, GE_FALSE if there </P>
<P>&#9;// are no cues to remove.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AnimationRemoveLastCue( geActor *A );</P>

<P>&#9;// applies a time step to actor A.  re-poses the actor according to all currently applicable</P>
<P>&#9;// Animation Cues. (failure implies Actor is incompletely initialized)</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AnimationStep(geActor *A, geFloat DeltaTime );</P>

<P>&#9;// applies a 'temporary' time step to actor A.  re-poses the actor according to all </P>
<P>&#9;// currently appliciable cues.  (failure implies Actor is incompletely initialized)</P>
<P>&#9;// DeltaTime is always relative to the the last AnimationStep()</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AnimationTestStep(geActor *A, geFloat DeltaTime);</P>

<P>&#9;// optimized version of geActor_AnimationStep.  Limits calculations to the bone named BoneName, and it's </P>
<P>&#9;// parents.  BoneName will be correctly computed, but the other bones will be wrong.  This is usefull for </P>
<P>&#9;// moving and animating an actor that is not actually visible.  Rendering and queries will be 'optimized'</P>
<P>&#9;// until the actor is given any pose or animation that doesn't go through geActor_AnimationStepBoneOptimized() or </P>
<P>&#9;//  geActor_AnimationTestStepBoneOptimized().  BoneName can be NULL to compute only 'root' bone.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AnimationStepBoneOptimized(geActor *A, geFloat DeltaTime, const char *BoneName );</P>

<P>&#9;// optimized version of geActor_AnimationTestStep.  Limits calculations to the bone named BoneName, and it's </P>
<P>&#9;// parents.  BoneName will be correctly computed, but the other bones will be wrong.  This is usefull for </P>
<P>&#9;// moving and animating an actor that is not actually visible.  Rendering and queries will be 'optimized'</P>
<P>&#9;// until the actor is given any pose or animation that doesn't go through geActor_AnimationStepBoneOptimized() or </P>
<P>&#9;//  geActor_AnimationTestStepBoneOptimized().  BoneName can be NULL to compute only 'root' bone.</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AnimationTestStepBoneOptimized(geActor *A, geFloat DeltaTime, const char *BoneName);</P>

<P>&nbsp;</P>
<P>&#9;// applies an 'immediate' offset to the animated actor</P>
<P>GENESISAPI geBoolean GENESISCC geActor_AnimationNudge(geActor *A, geXForm3d *Offset);</P>

<P>&nbsp;</P>
<P>GENESISAPI geBoolean GENESISCC geActor_GetAnimationEvent(geActor *A,&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;const char **ppEventString);&#9;&#9;// Return data, if return value is GE_TRUE</P>

<P>&#9;// returns number of actors that are currently created.</P>
<P>GENESISAPI int GENESISCC geActor_GetCount(void);</P>

<P>// GENESIS_PRIVATE_APIS</P>
<P>&#9;// call setscale and setshadow after preparing the actor for rendering (renderprep)</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>

<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069954">Body._h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  BODY._H                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description:  Exports private BODY data structures for "friends".&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_BODY__H</P>
<P>#define GE_BODY__H </P>

<P>#include "basetype.h"</P>
<P>#include "xform3d.h"</P>
<P>#include "body.h"</P>
<P>#include "strblock.h"</P>
<P>#include "bitmap.h"</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define GE_BODY_INDEX_MAX (0xEFFF)</P>

<P>#define GE_BODY_REALLY_BIG_NUMBER (9e9f)&#9;&#9;// bigger than any skin point</P>

<P>#define GE_BODY_HIGHEST_LOD_MASK&#9;( 1 &lt;&lt; GE_BODY_HIGHEST_LOD )</P>
<P>#define GE_BODY_BBOX_LOD_MASK&#9;&#9;( 1 &lt;&lt; GE_BODY_NUMBER_OF_LOD ) // bounding box mask</P>

<P>&nbsp;</P>
<P>typedef int16 geBody_Index;</P>

<P>typedef struct geBody_XSkinVertex</P>
<P>{</P>
<P>&#9;geVec3d&#9;&#9;&#9;XPoint;</P>
<P>&#9;geFloat&#9;&#9;&#9;XU,XV;</P>
<P>&#9;int8&#9;&#9;&#9;LevelOfDetailMask;</P>
<P>&#9;geBody_Index&#9;BoneIndex;</P>
<P>} geBody_XSkinVertex;</P>

<P>typedef struct geBody_Normal</P>
<P>{</P>
<P>&#9;geVec3d&#9;&#9;&#9;Normal;</P>
<P>&#9;int8&#9;&#9;&#9;LevelOfDetailMask;</P>
<P>&#9;geBody_Index&#9;BoneIndex;</P>
<P>} geBody_Normal;</P>

<P>typedef struct geBody_Bone</P>
<P>{</P>
<P>&#9;geVec3d&#9;&#9;&#9;BoundingBoxMin;</P>
<P>&#9;geVec3d&#9;&#9;&#9;BoundingBoxMax;</P>
<P>&#9;geXForm3d       AttachmentMatrix;</P>
<P>&#9;geBody_Index&#9;ParentBoneIndex;</P>
<P>} geBody_Bone;</P>
<P>&#9;&#9;</P>
<P>typedef struct geBody_Triangle</P>
<P>{</P>
<P>&#9;geBody_Index&#9;VtxIndex[3];</P>
<P>&#9;geBody_Index&#9;NormalIndex[3];</P>
<P>&#9;geBody_Index&#9;MaterialIndex;</P>
<P>&#9;//geBody_Index    FaceNormal;</P>
<P>} geBody_Triangle;</P>
<P>&#9;&#9;&#9;</P>
<P>typedef struct geBody_TriangleList</P>
<P>{</P>
<P>&#9;geBody_Index&#9;  FaceCount;</P>
<P>&#9;geBody_Triangle  *FaceArray;&#9;&#9;// Sorted by MaterialIndex</P>
<P>} geBody_TriangleList;</P>

<P>typedef struct geBody_Material</P>
<P>{</P>
<P>&#9;geBitmap *Bitmap;</P>
<P>&#9;geFloat Red,Green,Blue;</P>
<P>} geBody_Material;</P>

<P>typedef struct geBody</P>
<P>{</P>
<P>&#9;geVec3d&#9;&#9;&#9;&#9;  BoundingBoxMin;</P>
<P>&#9;geVec3d&#9;&#9;&#9;&#9;  BoundingBoxMax;</P>

<P>&#9;geBody_Index&#9;&#9;  XSkinVertexCount;</P>
<P>&#9;geBody_XSkinVertex&#9; *XSkinVertexArray;&#9;&#9;// Sorted by BoneIndex</P>

<P>&#9;geBody_Index&#9;&#9;  SkinNormalCount;</P>
<P>&#9;geBody_Normal&#9;&#9; *SkinNormalArray;</P>

<P>&#9;geBody_Index&#9;&#9;  BoneCount;</P>
<P>&#9;geBody_Bone&#9;&#9;&#9; *BoneArray;</P>
<P>&#9;geStrBlock&#9;&#9;&#9; *BoneNames;</P>

<P>&#9;geBody_Index&#9;&#9;  MaterialCount;</P>
<P>&#9;geBody_Material&#9;&#9; *MaterialArray;</P>
<P>&#9;geStrBlock&#9;&#9;&#9; *MaterialNames;&#9;&#9;</P>

<P>&#9;int&#9;&#9;&#9;&#9;&#9;  LevelsOfDetail;</P>
<P>&#9;geBody_TriangleList&#9;  SkinFaces[GE_BODY_NUMBER_OF_LOD];</P>
<P>&#9;</P>
<P>&#9;geBody&#9;&#9;&#9;&#9; *IsValid;</P>
<P>} geBody;</P>

<P>#if defined(DEBUG) || !defined(NDEBUG)</P>
<P>geBoolean GENESISCC geBody_SanityCheck(const geBody *B);</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069955">Body.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  BODY.H                                                                              */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description: Actor body interface.&#9;&#9;                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_BODY_H</P>
<P>#define GE_BODY_H </P>

<P>/* This object is for managing the data associated with a skeletal-based mesh, </P>
<P>   a 'body'.</P>
<P>   This object holds the geometry for the body and the list of materials needed.</P>
<P>*/</P>

<P>#include "basetype.h"</P>
<P>#include "xform3d.h"</P>
<P>#include "vfile.h"</P>
<P>#include "bitmap.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define GE_BODY_NUMBER_OF_LOD&#9;&#9;&#9;(4)&#9;&#9;// 0 is highest detail</P>
<P>#define GE_BODY_NO_PARENT_BONE         (-1)   </P>
<P>#define GE_BODY_HIGHEST_LOD            (0)</P>

<P>#define GE_BODY_ROOT&#9;&#9;&#9;&#9;&#9;(-1)&#9;// for specifying 'root' bounding box.</P>

<P>typedef struct geBody geBody;</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>geBody *GENESISCC geBody_Create(void);</P>

<P>void GENESISCC geBody_Destroy(geBody **B);</P>

<P>geBoolean GENESISCC geBody_IsValid(const geBody *B);</P>

<P>&nbsp;</P>
<P>geBoolean GENESISCC geBody_GetGeometryStats(const geBody *B, int lod, int *Vertices, int *Faces, int *Normals);</P>

<P>geBoolean GENESISCC geBody_AddFace(&#9;geBody *B,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Vertex1, const geVec3d *Normal1, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat U1, geFloat V1, int BoneIndex1,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Vertex2, const geVec3d *Normal2, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat U2, geFloat V2, int BoneIndex2,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Vertex3, const geVec3d *Normal3, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat U3, geFloat V3, int BoneIndex3,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int MaterialIndex);</P>

<P>&#9;&#9;&#9;// Bitmap is added to body.  It's reference count is increased.  Caller still owns a pointer</P>
<P>&#9;&#9;&#9;// to the bitmap, and is responsible for destroying it.</P>
<P>geBoolean GENESISCC geBody_AddMaterial( geBody *B, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const char *MaterialName, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap *Bitmap,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Red, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Green, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Blue,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int *MaterialIndex);</P>

<P>&#9;&#9;&#9;// returned bitmap is a pointer to the bitmap in the body's list.  It may not be destroyed.</P>
<P>&#9;&#9;&#9;// if caller would like to 'own' a copy of that bitmap pointer, it should call geBitmap_CreateRef()</P>
<P>geBoolean GENESISCC geBody_GetMaterial(const geBody *Body, int MaterialIndex,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const char **MaterialName,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap **Bitmap, geFloat *Red, geFloat *Green, geFloat *Blue);</P>

<P>&#9;&#9;&#9;// Bitmap is set into the body.  It's reference count is increased.  Caller still owns a pointer</P>
<P>&#9;&#9;&#9;// to the bitmap, and is responsible for destroying it.</P>
<P>geBoolean GENESISCC geBody_SetMaterial(geBody *Body, int MaterialIndex,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap *Bitmap,  geFloat Red,  geFloat Green,  geFloat Blue);</P>

<P>int GENESISCC geBody_GetMaterialCount(const geBody *B);</P>

<P>geBoolean GENESISCC geBody_AddBone( geBody *B, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;int ParentBoneIndex,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;const char *BoneName, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d *AttachmentMatrix,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;int *BoneIndex);</P>

<P>geBoolean GENESISCC geBody_ComputeLevelsOfDetail( geBody *B ,int Levels);</P>

<P>int GENESISCC geBody_GetBoneCount(const geBody *B);</P>

<P>void GENESISCC geBody_GetBone(&#9;const geBody *B, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;int BoneIndex, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const char **BoneName,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;geXForm3d *Attachment, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;int *ParentBoneIndex);</P>

<P>int32 GENESISCC geBody_GetBoneNameChecksum(const geBody *B);</P>

<P>void GENESISCC geBody_SetBoundingBox( geBody *B,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;int BoneIndex,&#9;&#9;// GE_BODY_ROOT for specifing 'root' bounding box.</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *MinimumBoxCorner,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *MaximumBoxCorner);</P>
<P> </P>

<P>geBoolean GENESISCC geBody_GetBoundingBox( const geBody *B, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;int BoneIndex,&#9;&#9;// GE_BODY_ROOT for specifing 'root' bounding box.</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *MinimumBoxCorner,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *MaximumBoxCorner);</P>

<P>geBoolean GENESISCC geBody_GetBoneByName(const geBody* B,</P>
<P>&#9;const char* BoneName,</P>
<P>&#9;int* pBoneIndex,</P>
<P>&#9;geXForm3d* Attachment,</P>
<P>&#9;int* pParentBoneIndex);</P>

<P>geBoolean GENESISCC geBody_WriteToFile(const geBody *B, geVFile *pFile);</P>
<P>geBody  *GENESISCC  geBody_CreateFromFile(geVFile *pFile);</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069956">Bodyinst.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  BODYINST.H                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description: Actor body instance interface.&#9;&#9;                                    */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_BODYINST_H</P>
<P>#define GE_BODYINST_H </P>

<P>/* This object is for accessing and retrieving an 'instance' of the geometry</P>
<P>   for a body.  </P>
<P>   </P>
<P>   The retrieval is a list of drawing commands in world space or </P>
<P>   in camera space.  </P>

<P>   An array of transforms that corresponds to the bones in the body is needed.</P>
<P> */</P>

<P>&nbsp;</P>
<P>#include "basetype.h"</P>
<P>#include "xform3d.h"</P>
<P>#include "body.h"</P>
<P>#include "XFArray.h"</P>
<P>#include "camera.h"</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>typedef struct geBodyInst geBodyInst;</P>

<P>typedef int16 geBodyInst_Index;</P>

<P>typedef enum </P>
<P>{</P>
<P>&#9;GE_BODYINST_FACE_TRIANGLE,</P>
<P>&#9;GE_BODYINST_FACE_TRISTRIP,</P>
<P>&#9;GE_BODYINST_FACE_TRIFAN</P>
<P>} geBodyInst_FaceType;</P>

<P>&nbsp;</P>
<P>typedef struct geBodyInst_SkinVertex</P>
<P>{</P>
<P>&#9;geVec3d SVPoint;</P>
<P>&#9;geFloat SVU,SVV;</P>
<P>&#9;int&#9;ReferenceBoneIndex;</P>
<P>} geBodyInst_SkinVertex;</P>

<P>typedef struct geBodyInst_Geometry </P>
<P>{</P>
<P>&#9;geBodyInst_Index&#9;&#9; SkinVertexCount;</P>
<P>&#9;geBodyInst_SkinVertex&#9;*SkinVertexArray;</P>

<P>&#9;geBodyInst_Index&#9;&#9; NormalCount;</P>
<P>&#9;geVec3d&#9;&#9;&#9;&#9;&#9;*NormalArray;</P>

<P>&#9;geBodyInst_Index&#9;&#9; FaceCount;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9; FaceListSize;</P>
<P>&#9;geBodyInst_Index&#9;&#9;*FaceList;</P>

<P>&#9;geVec3d&#9;&#9;&#9;&#9;&#9; Maxs, Mins;</P>
<P>}&#9;geBodyInst_Geometry;</P>

<P>/* format for geBodyInst_Geometry.FaceList:</P>
<P>&#9;primitive type (GE_BODY_FACE_TRIANGLE,&#9;  GE_BODY_FACE_TRISTRIP,  GE_BODY_FACE_TRIFAN )</P>
<P>&#9;followed by material index</P>
<P>&#9;followed by...</P>
<P>&#9;case primitive </P>
<P>&#9;&#9;GE_BODY_FACE_TRIANGLE:</P>
<P>&#9;&#9;  vertex index 1, normal index 1</P>
<P>&#9;&#9;  vertex index 2, normal index 2</P>
<P>&#9;&#9;  vertex index 3, normal index 3</P>
<P>&#9;&#9;  (next primitive)</P>
<P>&#9;&#9;GE_BODY_FACE_TRISTRIP:</P>
<P>&#9;&#9;  triangle count</P>
<P>&#9;&#9;  vertex index 1, normal index 1</P>
<P>&#9;&#9;  vertex index 2, normal index 2</P>
<P>&#9;&#9;  vertex index 3, normal index 3</P>
<P>&#9;&#9;  vertex index 4, normal index 4</P>
<P>&#9;&#9;  ...  # vertices is triangle count+2</P>
<P>&#9;&#9;  (next primitive)</P>
<P>&#9;&#9;GE_BODY_FACE_TRIFAN:</P>
<P>&#9;&#9;  triangle count</P>
<P>&#9;&#9;  vertex index 1, normal index 1</P>
<P>&#9;&#9;  vertex index 2, normal index 2</P>
<P>&#9;&#9;  vertex index 3, normal index 3</P>
<P>&#9;&#9;  vertex index 4, normal index 4</P>
<P>&#9;&#9;  ...  # vertices is triangle count+2</P>
<P>&#9;&#9;  (next primitive)</P>
<P>*/</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>geBodyInst *GENESISCC geBodyInst_Create( const geBody *B );</P>
<P>void GENESISCC geBodyInst_Destroy(geBodyInst **BI);</P>

<P>const geBodyInst_Geometry *GENESISCC geBodyInst_GetGeometry( </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geBodyInst *BI,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Scale,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geXFArray *BoneXformArray,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int LevelOfDetail,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geCamera *Camera);</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P>&#9;&#9;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069957">Motion.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  MOTION.H&#9;                                                                        */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description: Motion interface.&#9;&#9;&#9;&#9;&#9;                                    */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_MOTION_H</P>
<P>#define GE_MOTION_H</P>

<P>/*&#9;motion</P>

<P>&#9;This object is a list of named Path objects</P>

<P>*/</P>

<P>#include &lt;stdio.h&gt;</P>
<P>#include "basetype.h"</P>
<P>#include "path.h"</P>
<P>#include "vfile.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>// GENESIS_PUBLIC_APIS</P>
<P>typedef struct geMotion geMotion;</P>

<P>GENESISAPI geMotion *GENESISCC geMotion_Create(geBoolean ManageNames);</P>

<P>GENESISAPI void GENESISCC geMotion_Destroy(geMotion **PM);</P>

<P>// GENESIS_PRIVATE_APIS</P>

<P>GENESISAPI geBoolean GENESISCC geMotion_IsValid(const geMotion *M);</P>

<P>&#9;// AddPath adds a reference of P to the motion M.  Ownership is shared - The caller must destroy P.</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_AddPath(geMotion *M, gePath *P,const char *Name,int *Index);</P>

<P>GENESISAPI geBoolean GENESISCC geMotion_HasNames(const geMotion *M);</P>
<P>GENESISAPI int32 GENESISCC geMotion_GetNameChecksum(const geMotion *M);</P>

<P>GENESISAPI geBoolean GENESISCC geMotion_RemoveNames(geMotion *M);</P>

<P>GENESISAPI void GENESISCC geMotion_SampleChannels(const geMotion *M, int PathIndex, geFloat Time, geQuaternion *Rotation, geVec3d *Translation);</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_SampleChannelsNamed(const geMotion *M, const char *PathName, geFloat Time, geQuaternion *Rotation, geVec3d *Translation);</P>

<P>GENESISAPI void GENESISCC geMotion_Sample(const geMotion *M, int PathIndex, geFloat Time, geXForm3d *Transform);</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_SampleNamed(const geMotion *M, const char *PathName, geFloat Time, geXForm3d *Transform);</P>

<P>&#9;// the returned Paths from _Get functions should not be destroyed.  </P>
<P>&#9;// if ownership is desired, call gePath_CreateRef() to create another owner. </P>
<P>&#9;// an 'owner' has access to the object regardless of the number of other owners, and </P>
<P>&#9;// an owner must call the object's destroy method to relinquish ownership</P>
<P>GENESISAPI gePath *GENESISCC geMotion_GetPathNamed(const geMotion *M,const char *Name);</P>
<P>GENESISAPI const char *GENESISCC geMotion_GetNameOfPath(const geMotion *M, int Index);</P>

<P>// GENESIS_PUBLIC_APIS</P>
<P>GENESISAPI gePath *GENESISCC geMotion_GetPath(const geMotion *M,int Index);</P>
<P>GENESISAPI int GENESISCC geMotion_GetPathCount(const geMotion *M);</P>

<P>&nbsp;</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_SetName(geMotion *M, const char * Name);</P>
<P>GENESISAPI const char *GENESISCC geMotion_GetName(const geMotion *M);</P>

<P>// GENESIS_PRIVATE_APIS</P>

<P>&#9;// support for compound motions.  A motion can either have sub-motions, or be single motion.</P>
<P>&#9;// these functions support motions that have sub-motions.</P>
<P>GENESISAPI int GENESISCC geMotion_GetSubMotionCount(const geMotion*M);</P>

<P>&#9;// the returned motions from these _Get functions should not be destroyed.  </P>
<P>&#9;// if ownership is desired, call geMotion_CreateRef() to create another owner. </P>
<P>&#9;// an 'owner' has access to the object regardless of the number of other owners, and </P>
<P>&#9;// an owner must call the object's destroy method to relinquish ownership</P>
<P>GENESISAPI geMotion *GENESISCC geMotion_GetSubMotion(const geMotion *M,int Index);</P>
<P>GENESISAPI geMotion *GENESISCC geMotion_GetSubMotionNamed(const geMotion *M,const char *Name);</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_AddSubMotion(</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geMotion *ParentMotion,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat TimeScale,&#9;&#9;&#9;// Scale factor for this submotion</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat TimeOffset,&#9;&#9;&#9;// Time in parent motion when submotion should start</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geMotion *SubMotion,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat StartTime,&#9;&#9;&#9;// Blend start time (relative to submotion)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat StartMagnitude,&#9;&#9;// Blend start magnitude (0..1)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat EndTime,&#9;&#9;&#9;// Blend ending time (relative to submotion)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat EndMagnitude,&#9;&#9;// Blend ending magnitude (0..1)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d *Transform,&#9;// Base transform to apply to this submotion</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int *Index);&#9;&#9;&#9;&#9;// returned motion index</P>

<P>GENESISAPI geMotion *GENESISCC  geMotion_RemoveSubMotion(geMotion *ParentMotion, int SubMotionIndex);</P>

<P>// Get/Set submotion time offset.  The time offset is the offset into the </P>
<P>// compound (parent) motion at which the submotion should start.</P>
<P>GENESISAPI geFloat   GENESISCC  geMotion_GetTimeOffset( const geMotion *M,int SubMotionIndex );</P>
<P>GENESISAPI geBoolean  GENESISCC geMotion_SetTimeOffset( geMotion *M,int SubMotionIndex,geFloat TimeOffset );</P>

<P>// Get/Set submotion time scale.  Time scaling is applied to the submotion after the TimeOffset</P>
<P>// is applied.  The formula is:  (CurrentTime - TimeOffset) * TimeScale</P>
<P>GENESISAPI geFloat   GENESISCC  geMotion_GetTimeScale( const geMotion *M,int SubMotionIndex );</P>
<P>GENESISAPI geBoolean  GENESISCC geMotion_SetTimeScale( geMotion *M,int SubMotionIndex,geFloat TimeScale );</P>

<P>// Get blending amount for a particular submotion.  The Time parameter is parent-relative.</P>
<P>GENESISAPI geFloat    GENESISCC geMotion_GetBlendAmount( const geMotion *M, int SubMotionIndex, geFloat Time);</P>

<P>// Get/Set blending path.  The keyframe times in the blend path are relative to the submotion.</P>
<P>GENESISAPI gePath    *GENESISCC geMotion_GetBlendPath( const geMotion *M,int SubMotionIndex );</P>
<P>GENESISAPI geBoolean  GENESISCC geMotion_SetBlendPath( geMotion *M,int SubMotionIndex, gePath *Blend );</P>

<P>GENESISAPI const geXForm3d *GENESISCC geMotion_GetBaseTransform( const geMotion *M,int SubMotionIndex );</P>
<P>GENESISAPI geBoolean  GENESISCC geMotion_SetBaseTransform( geMotion *M,int SubMotionIndex, geXForm3d *BaseTransform );</P>
<P>GENESISAPI geBoolean  GENESISCC geMotion_GetTransform(const geMotion *M, geFloat Time, geXForm3d *Transform);</P>
<P>// GENESIS_PUBLIC_APIS</P>

<P>&#9;// gets time of first key and time of last key (as if motion did not loop)</P>
<P>&#9;// if there are no paths in the motion: returns GE_FALSE and times are not set</P>
<P>&#9;// otherwise returns GE_TRUE</P>
<P>&#9;//</P>
<P>&#9;// For a compound motion, GetTimeExtents will return the extents of the scaled submotions.</P>
<P>&#9;// For a single motion, no scaling is applied.</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_GetTimeExtents(const geMotion *M,geFloat *StartTime,geFloat *EndTime);</P>

<P>// Only one event is allowed per time key.</P>

<P>GENESISAPI geBoolean GENESISCC geMotion_InsertEvent(geMotion *M, geFloat tKey, const char* String);</P>
<P>&#9;// Inserts the new event and corresponding string.</P>

<P>GENESISAPI geBoolean GENESISCC geMotion_DeleteEvent(geMotion *M, geFloat tKey);</P>
<P>&#9;// Deletes the event</P>

<P>GENESISAPI void GENESISCC geMotion_SetupEventIterator(</P>
<P>&#9;geMotion *M,</P>
<P>&#9;geFloat StartTime,&#9;&#9;&#9;&#9;// Inclusive search start</P>
<P>&#9;geFloat EndTime);&#9;&#9;&#9;&#9;// Non-inclusive search stop</P>
<P>&#9;// For searching or querying the array for events between two times</P>
<P>&#9;// times are compaired [StartTime,EndTime), '[' is inclusive, ')' is </P>
<P>&#9;// non-inclusive.  This prepares the geMotion_GetNextEvent() function.</P>

<P>GENESISAPI geBoolean GENESISCC geMotion_GetNextEvent(</P>
<P>&#9;geMotion *M,&#9;&#9;&#9;&#9;&#9;&#9;// Event list to iterate</P>
<P>&#9;geFloat *pTime,&#9;&#9;&#9;&#9;// Return time, if found</P>
<P>&#9;const char **ppEventString);&#9;// Return data, if found</P>
<P>&#9;// Iterates from StartTime to EndTime as setup in geMotion_SetupEventIterator()</P>
<P>&#9;// and for each event between these times [StartTime,EndTime)</P>
<P>&#9;// this function will return Time and EventString returned for that event</P>
<P>&#9;// and the iterator will be positioned for the next search.  When there </P>
<P>&#9;// are no more events in the range, this function will return GE_FALSE (Time</P>
<P>&#9;// will be 0 and ppEventString will be empty).</P>

<P>GENESISAPI geBoolean GENESISCC geMotion_GetEventExtents(const geMotion *M,</P>
<P>&#9;&#9;&#9;geFloat *FirstEventTime,</P>
<P>&#9;&#9;&#9;geFloat *LastEventTime);</P>
<P>&#9;// returns the time associated with the first and last events </P>
<P>&#9;// returns GE_FALSE if there are no events (and Times are not set)</P>

<P>&nbsp;</P>
<P>// GENESIS_PRIVATE_APIS</P>
<P>GENESISAPI geMotion *GENESISCC geMotion_CreateFromFile(geVFile *f);</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_WriteToFile(const geMotion *M, geVFile *f);</P>
<P>GENESISAPI geBoolean GENESISCC geMotion_WriteToBinaryFile(const geMotion *M,geVFile *pFile);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069958">Path.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  PATH.H&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description: Time-indexed keyframe creation, maintenance, and sampling.&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_PATH_H</P>
<P>#define GE_PATH_H</P>

<P>#include "basetype.h"</P>
<P>#include "xform3d.h"</P>
<P>#include "quatern.h"</P>
<P>#include "vfile.h"</P>

<P>#ifdef __cplusplus</P>
<P>&#9;extern "C" {</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>// GENESIS_PUBLIC_APIS</P>
<P>typedef struct _gePath gePath;</P>

<P>#define GE_PATH_ROTATION_CHANNEL    1</P>
<P>#define GE_PATH_TRANSLATION_CHANNEL 2</P>

<P>#define GE_PATH_ALL_CHANNELS (GE_PATH_ROTATION_CHANNEL | GE_PATH_TRANSLATION_CHANNEL)</P>

<P>#ifndef GE_PATH_ENUMS</P>
<P>&#9;#define GE_PATH_ENUMS</P>
<P>&#9;typedef enum </P>
<P>&#9;{</P>
<P>&#9;&#9;GE_PATH_INTERPOLATE_LINEAR  = 0,&#9;// linear blend for translation or rotation channel</P>
<P>&#9;&#9;GE_PATH_INTERPOLATE_HERMITE,&#9;&#9;// hermite cubic spline for translation channel</P>
<P>&#9;&#9;GE_PATH_INTERPOLATE_SLERP,&#9;&#9;&#9;// spherical-linear blend for rotation channel</P>
<P>&#9;&#9;GE_PATH_INTERPOLATE_SQUAD,&#9;&#9;&#9;// higher order blend for rotation channel 'G1' continuity</P>
<P>&#9;&#9;//GE_PATH_INTEROPLATE_TRIPOD,&#9;&#9; // not supported yet.</P>
<P>&#9;&#9;GE_PATH_INTERPOLATE_HERMITE_ZERO_DERIV = 7&#9;// hermite cubic with zero derivative at keyframes ('easing' curve)</P>
<P>&#9;}gePath_Interpolator;</P>
<P>#endif</P>

<P>GENESISAPI void GENESISCC gePath_CreateRef( gePath *P );</P>

<P>GENESISAPI gePath *GENESISCC gePath_Create(</P>
<P>&#9;gePath_Interpolator TranslationInterpolation,&#9;// type of interpolation for translation channel</P>
<P>&#9;gePath_Interpolator RotationInterpolation,&#9;// type of interpolation for rotation channel</P>
<P>&#9;geBoolean Looped);&#9;&#9;&#9;&#9;// True if end of path is connected to head</P>
<P>&#9;// creates new gePath</P>
<P>&#9;//  A looping path should have the same first &amp; last point.  The path</P>
<P>&#9;//  generator will choose arbitrarily between these points for a </P>
<P>&#9;//  sample exactly at the end of the loop.</P>

<P>GENESISAPI gePath *GENESISCC gePath_CreateCopy( const gePath *P );</P>
<P>&#9;</P>
<P>GENESISAPI void GENESISCC gePath_Destroy(gePath **PP);&#9;&#9;</P>
<P>&#9;// destroys path *PP</P>

<P>//------------------ time based keyframe operations</P>
<P>GENESISAPI geBoolean GENESISCC gePath_InsertKeyframe(</P>
<P>&#9;gePath *P, </P>
<P>&#9;int ChannelMask, </P>
<P>&#9;geFloat Time, </P>
<P>&#9;const geXForm3d *Matrix); </P>
<P>&#9;// inserts a keyframe at a specific time.</P>
<P>&#9;</P>
<P>GENESISAPI geBoolean GENESISCC gePath_DeleteKeyframe(</P>
<P>&#9;gePath *P,</P>
<P>&#9;int Index,</P>
<P>&#9;int ChannelMask); </P>
<P>&#9;// deletes the nth keyframe</P>

<P>GENESISAPI geBoolean GENESISCC gePath_GetTimeExtents(</P>
<P>&#9;const gePath *P,</P>
<P>&#9;geFloat *StartTime, </P>
<P>&#9;geFloat *EndTime);</P>
<P>&#9;// gets the time for the first and last keys in the path (ignoring looping)</P>
<P>&#9;// if there are no keys, return GE_FALSE and times are not set.</P>
<P>&#9;// returns GE_TRUE if there are keys.</P>

<P>//----------------- index based keyframe operations</P>
<P>GENESISAPI void GENESISCC gePath_GetKeyframe(</P>
<P>&#9;const gePath *P, </P>
<P>&#9;int Index,&#9;&#9;&#9;&#9;// gets keyframe[index]</P>
<P>&#9;int Channel,&#9;&#9;&#9;// for this channel</P>
<P>&#9;geFloat *Time,&#9;&#9;&#9;// returns the time of the keyframe</P>
<P>&#9;geXForm3d *Matrix);&#9;&#9;// returns the matrix of the keyframe</P>
<P>&#9;// retrieves keyframe[index], and it's time</P>

<P>GENESISAPI int GENESISCC gePath_GetKeyframeCount(const gePath *P,int Channel);</P>
<P>&#9;// retrieves count of keyframes for a specific channel</P>

<P>GENESISAPI int GENESISCC gePath_GetKeyframeIndex(const gePath *P, int Channel, geFloat Time);</P>
<P>&#9;// retrieves the index of the keyframe at a specific time for a specific channel</P>

<P>//----------------- sampling a path  (time based)</P>
<P>GENESISAPI void GENESISCC gePath_Sample(const gePath *P, geFloat Time,geXForm3d *Matrix);</P>
<P>&#9;// returns a transform matrix sampled at 'Time'.</P>
<P>&#9;// p is not const because information is cached in p for next sample</P>

<P>// GENESIS_PRIVATE_APIS</P>
<P>void GENESISCC gePath_SampleChannels(</P>
<P>&#9;const gePath *P, </P>
<P>&#9;geFloat Time, </P>
<P>&#9;geQuaternion *Rotation, </P>
<P>&#9;geVec3d *Translation);</P>
<P>&#9;// returns a rotation and a translation for the path at 'Time'</P>
<P>&#9;// p is not const because information is cached in p for next sample</P>

<P>GENESISAPI geBoolean GENESISCC gePath_OffsetTimes(gePath *P, </P>
<P>&#9;int StartingIndex, int ChannelMask, geFloat TimeOffset );</P>
<P>&#9;&#9;// slides all samples in path starting with StartingIndex down by TimeOffset</P>

<P>GENESISAPI geBoolean GENESISCC gePath_ModifyKeyframe(</P>
<P>&#9;gePath *P,</P>
<P>&#9;int Index,</P>
<P>&#9;int ChannelMask,</P>
<P>&#9;const geXForm3d *Matrix);</P>
<P>&#9;</P>

<P>// GENESIS_PUBLIC_APIS</P>

<P>//------------------ saving/loading a path</P>
<P>GENESISAPI gePath* GENESISCC gePath_CreateFromFile(geVFile *F);</P>
<P>&#9;// loads a file  (binary or ascii)</P>

<P>GENESISAPI geBoolean GENESISCC gePath_WriteToFile(const gePath *P, geVFile *F);</P>
<P>&#9;// dumps formatted ascii to the file.  </P>

<P>GENESISAPI geBoolean GENESISCC gePath_WriteToBinaryFile(const gePath *P, geVFile *F);</P>
<P>&#9;// dumps a minimal binary image for fastest reading</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>&#9;}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069959">Pose.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  POSE.H&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description: Bone hierarchy interface.&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;.&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_POSE_H</P>
<P>#define GE_POSE_H</P>

<P>/*&#9;gePose</P>

<P>&#9;This object is a hierarchical set of attached joints.  The joints can have names.</P>
<P>&#9;A 'gePose' keeps track of which children joints move in the hierarchy when a parent</P>
<P>&#9;joint moves.  A gePose also remembers the position transform matrices for each joint.</P>

<P>&#9;The gePose is set by applying a motion at a specific time.  This queries the motion</P>
<P>&#9;to determine each joint's change and applies them to the hierarchy.  Each joint can</P>
<P>&#9;then be queried for it's world transform (for drawing, etc.)</P>

<P>&#9;Additional motions can modify or be blended into the pose.  A motion that describes </P>
<P>&#9;only a few joint changes can be applied to only those joints, or a motion can be</P>
<P>&#9;blended with the current pose. </P>

<P>&#9;Something to watch for:  since setting the pose by applying a motion is powerful</P>
<P>&#9;enough to resolve intentionally mismatched motion-pose sets, this can lead to </P>
<P>&#9;problems if the motion UNintentionally does not match the pose.  Use </P>
<P>&#9;gePose_MatchesgeMotionExactly() to test for an exact name-based match.</P>
<P>&#9;</P>

<P>*/</P>

<P>#include &lt;stdio.h&gt;</P>
<P>#include "Motion.h"</P>
<P>#include "XFArray.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#define GE_POSE_ROOT_JOINT (-1)</P>

<P>typedef enum </P>
<P>{</P>
<P>&#9;&#9;GE_POSE_BLEND_LINEAR,</P>
<P>&#9;&#9;GE_POSE_BLEND_HERMITE</P>
<P>} gePose_BlendingType;</P>

<P>typedef struct gePose gePose;</P>

<P>&#9;// Creates a new pose with no joints.</P>
<P>gePose *GENESISCC gePose_Create(void);</P>

<P>&#9;// Destroys an existing pose.</P>
<P>void GENESISCC gePose_Destroy(gePose **PM);</P>

<P>&#9;// Adds a new joint to a pose.</P>
<P>geBoolean GENESISCC gePose_AddJoint(</P>
<P>&#9;gePose *P,</P>
<P>&#9;int ParentJointIndex,</P>
<P>&#9;const char *JointName,</P>
<P>&#9;const geXForm3d *Attachment,</P>
<P>&#9;int *JointIndex);</P>

<P>&nbsp;</P>
<P>void GENESISCC gePose_GetScale(const gePose *P, geVec3d *Scale);</P>
<P>&#9;// Retrieves current joint attachment scaling factors</P>

<P>void GENESISCC gePose_SetScale(gePose *P, const geVec3d *Scale);</P>
<P>&#9;// Scales all joint attachments by component scaling factors in Scale</P>

<P>&#9;// Returns the index of a joint named JointName.  Returns GE_TRUE if it is</P>
<P>&#9;// located, and Index is set.  Returns GE_FALSE if not, and Index is not changed.</P>
<P>geBoolean GENESISCC gePose_FindNamedJointIndex(const gePose *P, const char *JointName, int *Index);</P>

<P>&#9;// returns the number of joints in the pose</P>
<P>int GENESISCC gePose_GetJointCount(const gePose *P);</P>

<P>geBoolean GENESISCC gePose_MatchesMotionExactly(const gePose *P, const geMotion *M);</P>

<P>void GENESISCC gePose_Clear(gePose *P, const geXForm3d *Transform);</P>

<P>&#9;// set the pose according to a motion.  Use the motion at time 'Time'.</P>
<P>&#9;// if the motion does not describe motion for all joints, name-based resolution</P>
<P>&#9;// will be used to decide which motion to attach to which joints.</P>
<P>&#9;// joints that are unaffected are unchanged.</P>
<P>&#9;// if Transform is non-NULL, it is applied to the Motion</P>
<P>void GENESISCC gePose_SetMotion(gePose *P, const geMotion *M,geFloat Time,const geXForm3d *Transform);</P>

<P>&#9;// optimization:  if this is called, then all pose computations are limited to the BoneIndex'th bone, and</P>
<P>&#9;// it's parents (including the root bone).  This is true for all queries until an entire motion is set or blended</P>
<P>&#9;// into the pose.</P>
<P>void GENESISCC gePose_SetMotionForABone(gePose *P, const geMotion *M, geFloat Time,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d *Transform,int BoneIndex);</P>

<P>&nbsp;</P>
<P>&#9;// blend in the pose according to a motion.  Use the motion at time 'Time'.</P>
<P>&#9;// the blending is between the 'current' pose and the pose described by the motion.</P>
<P>&#9;// a BlendAmount of 0 will result in the 'current' pose, and a BlendAmount of 1.0</P>
<P>&#9;// will result in the pose according to the new motion.</P>
<P>&#9;// if the motion does not describe motion for all joints, name-based resolution</P>
<P>&#9;// will be used to decide which motion to attach to which joints.</P>
<P>&#9;// joints that are unaffected are unchanged.</P>
<P>&#9;// if Transform is non-NULL, it is applied to the Motion prior to blending</P>
<P>void GENESISCC gePose_BlendMotion(gePose *P, const geMotion *M, geFloat Time, </P>
<P>&#9;&#9;&#9;&#9;&#9;const geXForm3d *Transform,</P>
<P>&#9;&#9;&#9;&#9;&#9;geFloat BlendAmount, gePose_BlendingType BlendingType);</P>

<P>&#9;// get a joint's current transform (relative to world space)</P>
<P>void GENESISCC gePose_GetJointTransform(const gePose *P, int JointIndex,geXForm3d *Transform);</P>

<P>&#9;// get the transforms for the entire pose. *TransformArray must not be changed.</P>
<P>const geXFArray *GENESISCC gePose_GetAllJointTransforms(const gePose *P);</P>

<P>&#9;// query a joint's current transform relative to it's attachment to it's parent.</P>
<P>void GENESISCC gePose_GetJointLocalTransform(const gePose *P, int JointIndex,geXForm3d *Transform);</P>

<P>&#9;// adjust a joint's current transform relative to it's attachment to it's parent.</P>
<P>&#9;//   this is like setting a mini-motion into this joint only:  this will only affect</P>
<P>&#9;//   the current pose </P>
<P>void GENESISCC gePose_SetJointLocalTransform(gePose *P, int JointIndex,const geXForm3d *Transform);</P>

<P>&#9;// query how a joint is attached to it's parent. (it's base attachment)</P>
<P>void GENESISCC gePose_GetJointAttachment(const gePose *P,int JointIndex,geXForm3d *AttachmentTransform);</P>

<P>&#9;// adjust how a joint is attached to it's parent.  These changes are permanent:  all</P>
<P>&#9;//  future pose motions will incorporate this joint's new relation to it's parent */</P>
<P>void GENESISCC gePose_SetJointAttachment(gePose *P,int JointIndex,const geXForm3d *AttachmentTransform);</P>

<P>const char* GENESISCC gePose_GetJointName(const gePose* P, int JointIndex);</P>

<P>geBoolean GENESISCC gePose_Attach(gePose *Slave, int SlaveBoneIndex,</P>
<P>&#9;&#9;&#9;&#9;  gePose *Master, int MasterBoneIndex, </P>
<P>&#9;&#9;&#9;&#9;  const geXForm3d *Attachment);</P>

<P>void GENESISCC gePose_Detach(gePose *P);</P>

<P>&#9;// a pose can also maintain a record of which joints are touched by a given motion.</P>
<P>&#9;// these funtions set,clear and query the record.</P>
<P>&#9;// ClearCoverage clears the coverage flag for all joints </P>
<P>void GENESISCC gePose_ClearCoverage(gePose *P, int ClearTo);</P>
<P>&#9;// AccumulateCoverage returns the number of joints that are not already 'covered' </P>
<P>&#9;// that will be affected by a motion M,  </P>
<P>&#9;// if QueryOnly is GE_FALSE, affected joints are tagged as 'covered', otherwise no changes</P>
<P>&#9;// are made to the joint coverage flags.</P>
<P>int GENESISCC gePose_AccumulateCoverage(gePose *P, const geMotion *M, geBoolean QueryOnly);</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069960">Puppet.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  PUPPET.H&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description: Puppet interface.&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;.&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_PUPPET_H</P>
<P>#define GE_PUPPET_H</P>

<P>#include "Motion.h"</P>
<P>#include "Camera.h"</P>
<P>#include "Body.h"</P>
<P>#include "Pose.h"</P>
<P>#include "ExtBox.h"&#9;&#9;&#9;// geExtBox for gePuppet_RenderThroughFrustum</P>

<P>#include "Frustum.h"</P>
<P>#include "vfile.h"</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>typedef struct gePuppet gePuppet;</P>

<P>gePuppet *GENESISCC gePuppet_Create(geVFile *TextureFS, const geBody *B, geWorld *World);</P>

<P>void GENESISCC gePuppet_Destroy(gePuppet **P);</P>

<P>geBoolean GENESISCC gePuppet_RenderThroughFrustum(const gePuppet *P, </P>
<P>&#9;&#9;&#9;&#9;&#9;const gePose *Joints, </P>
<P>&#9;&#9;&#9;&#9;&#9;const geExtBox *Box, </P>
<P>&#9;&#9;&#9;&#9;&#9;geEngine *Engine, </P>
<P>&#9;&#9;&#9;&#9;&#9;geWorld *World,</P>
<P>&#9;&#9;&#9;&#9;&#9;const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;Frustum_Info *FInfo);</P>

<P>geBoolean GENESISCC gePuppet_Render(const gePuppet *P,</P>
<P>&#9;&#9;&#9;&#9;&#9;const gePose *Joints,</P>
<P>&#9;&#9;&#9;&#9;&#9;geEngine *Engine, </P>
<P>&#9;&#9;&#9;&#9;&#9;geWorld *World,</P>
<P>&#9;&#9;&#9;&#9;&#9;const geCamera *Camera, </P>
<P>&#9;&#9;&#9;&#9;&#9;geExtBox *Box);</P>

<P>int GENESISCC gePuppet_GetMaterialCount( gePuppet *P );</P>
<P>geBoolean GENESISCC gePuppet_GetMaterial( gePuppet *P, int MaterialIndex,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap **Bitmap, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *Red, geFloat *Green, geFloat *Blue);</P>
<P>geBoolean GENESISCC gePuppet_SetMaterial(gePuppet *P, int MaterialIndex, geBitmap *Bitmap, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat Red, geFloat Green, geFloat Blue);</P>

<P>void GENESISCC gePuppet_SetShadow(gePuppet *P, geBoolean DoShadow, geFloat Scale, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geBitmap *ShadowMap,int BoneIndex);</P>

<P>void GENESISCC gePuppet_GetLightingOptions(const gePuppet *P,</P>
<P>&#9;geBoolean *UseFillLight,</P>
<P>&#9;geVec3d *FillLightNormal,</P>
<P>&#9;geFloat *FillLightRed,&#9;&#9;&#9;&#9;</P>
<P>&#9;geFloat *FillLightGreen,&#9;&#9;&#9;&#9;</P>
<P>&#9;geFloat *FillLightBlue,&#9;&#9;&#9;&#9;</P>
<P>&#9;geFloat *AmbientLightRed,&#9;&#9;&#9;</P>
<P>&#9;geFloat *AmbientLightGreen,&#9;&#9;&#9;</P>
<P>&#9;geFloat *AmbientLightBlue,&#9;&#9;&#9;</P>
<P>&#9;geBoolean *UseAmbientLightFromFloor,</P>
<P>&#9;int *MaximumDynamicLightsToUse,&#9;&#9;</P>
<P>&#9;int *LightReferenceBoneIndex,</P>
<P>&#9;geBoolean *PerBoneLighting</P>
<P>&#9;);</P>

<P>void GENESISCC gePuppet_SetLightingOptions(gePuppet *P,</P>
<P>&#9;geBoolean UseFillLight,</P>
<P>&#9;const geVec3d *FillLightNormal,</P>
<P>&#9;geFloat FillLightRed,&#9;&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;geFloat FillLightGreen,&#9;&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;geFloat FillLightBlue,&#9;&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;geFloat AmbientLightRed,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;geFloat AmbientLightGreen,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;geFloat AmbientLightBlue,&#9;&#9;&#9;// 0 .. 255</P>
<P>&#9;geBoolean AmbientLightFromFloor,</P>
<P>&#9;int MaximumDynamicLightsToUse,&#9;&#9;// 0 for none</P>
<P>&#9;int LightReferenceBoneIndex,</P>
<P>&#9;int PerBoneLighting);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069961">QKFrame.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  QKFRAME.H&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description: Quaternion keyframe interface.&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>/* geQKFrame   (geQuaternion - Keyframe)</P>
<P>&#9;This module handles interpolation for keyframes that contain a quaternion</P>
<P>&#9;This is intended to support Path.c</P>
<P>&#9;geTKArray supplies general support for a time-keyed array, and this supplements</P>
<P>&#9;that support to include the specific time-keyed arrays:</P>
<P>&#9;  An array of geQuaternion interpolated linearly</P>
<P>&#9;  An array of geQuaternion with spherical linear interpolation (SLERP)</P>
<P>&#9;  An array of geQuaternion with spherical quadrangle </P>
<P>&#9;&#9;interpolation (SQUAD) as defined by:</P>
<P>&#9;    Advanced Animation and Rendering Techniques by Alan Watt and Mark Watt</P>

<P>&#9;These are phycially separated and have different base structures because</P>
<P>&#9;the different interpolation techniques requre different additional data.</P>
<P>&#9;</P>
<P>&#9;The two lists are created with different creation calls,</P>
<P>&#9;interpolated with different calls, but insertion and queries share a call.</P>
<P>&#9;</P>
<P>&#9;Quadrangle interpolation requires additional computation after changes are</P>
<P>&#9;made to the keyframe list.  Call geQKFrame_SquadRecompute() to update the</P>
<P>&#9;calculations.</P>
<P>*/</P>
<P>#ifndef GE_QKFRAME_H</P>
<P>#define GE_QKFRAME_H</P>

<P>&nbsp;</P>
<P>#include "TKArray.h"</P>
<P>#include "Quatern.h"</P>
<P>#include "vfile.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef enum</P>
<P>{</P>
<P>&#9;QKFRAME_LINEAR,</P>
<P>&#9;QKFRAME_SLERP,</P>
<P>&#9;QKFRAME_SQUAD</P>
<P>} geQKFrame_InterpolationType;</P>

<P>&nbsp;</P>
<P>geTKArray *GENESISCC geQKFrame_LinearCreate(void);</P>
<P>&#9;// creates a frame list for linear interpolation</P>

<P>geTKArray *GENESISCC geQKFrame_SlerpCreate();</P>
<P>&#9;// creates a frame list for spherical linear interpolation&#9;</P>

<P>geTKArray *GENESISCC geQKFrame_SquadCreate();</P>
<P>&#9;// creates a frame list for spherical linear interpolation&#9;</P>

<P>&nbsp;</P>
<P>geBoolean GENESISCC geQKFrame_Insert(</P>
<P>&#9;geTKArray **KeyList,&#9;&#9;&#9;// keyframe list to insert into</P>
<P>&#9;geTKArray_TimeType Time,&#9;&#9;// time of new keyframe</P>
<P>&#9;const geQuaternion *Q,&#9;&#9;&#9;// quaternion at new keyframe</P>
<P>&#9;int *Index);&#9;&#9;&#9;&#9;&#9;// index of new frame</P>
<P>&#9;// inserts a new keyframe with the given time and vector into the list.</P>

<P>void GENESISCC geQKFrame_Query(</P>
<P>&#9;const geTKArray *KeyList,&#9;&#9;// keyframe list</P>
<P>&#9;int Index,&#9;&#9;&#9;&#9;&#9;&#9;// index of frame to return</P>
<P>&#9;geTKArray_TimeType *Time,&#9;&#9;// time of the frame is returned</P>
<P>&#9;geQuaternion *V);&#9;&#9;&#9;&#9;&#9;// vector from the frame is returned</P>
<P>&#9;// returns the vector and the time at keyframe[index] </P>

<P>void GENESISCC geQKFrame_Modify(</P>
<P>&#9;geTKArray *KeyList,&#9;&#9;&#9;&#9;// keyframe list</P>
<P>&#9;int Index,&#9;&#9;&#9;&#9;&#9;&#9;// index of frame to change</P>
<P>&#9;const geQuaternion *Q);&#9;&#9;&#9;// vector for the new key</P>
<P>&#9;// modifies a vector at keyframe[index]</P>

<P>void GENESISCC geQKFrame_LinearInterpolation(</P>
<P>&#9;const void *KF1,&#9;&#9;// pointer to first keyframe</P>
<P>&#9;const void *KF2,&#9;&#9;// pointer to second keyframe</P>
<P>&#9;geFloat T,&#9;&#9;&#9;&#9;// 0 &lt;= T &lt;= 1   blending parameter</P>
<P>&#9;void *Result);&#9;&#9;&#9;// put the result in here (geQuaternion)</P>
<P>&#9;&#9;// interpolates to get a vector between the two vectors at the two</P>
<P>&#9;&#9;// keyframes where T==0 returns the vector for KF1 </P>
<P>&#9;&#9;// and T==1 returns the vector for KF2</P>
<P>&#9;&#9;// interpolates linearly</P>
<P>&#9;</P>
<P>void GENESISCC geQKFrame_SlerpInterpolation(</P>
<P>&#9;const void *KF1,&#9;&#9;// pointer to first keyframe</P>
<P>&#9;const void *KF2,&#9;&#9;// pointer to second keyframe</P>
<P>&#9;geFloat T,&#9;&#9;&#9;&#9;// 0 &lt;= T &lt;= 1   blending parameter</P>
<P>&#9;void *Result);&#9;&#9;&#9;// put the result in here (geQuaternion)</P>
<P>&#9;&#9;// interpolates to get a vector between the two vectors at the two</P>
<P>&#9;&#9;// keyframes where T==0 returns the vector for KF1 </P>
<P>&#9;&#9;// and T==1 returns the vector for KF2</P>
<P>&#9;&#9;// interpolates using spherical linear blending</P>

<P>void GENESISCC geQKFrame_SquadInterpolation(</P>
<P>&#9;const void *KF1,&#9;&#9;// pointer to first keyframe</P>
<P>&#9;const void *KF2,&#9;&#9;// pointer to second keyframe</P>
<P>&#9;geFloat T,&#9;&#9;&#9;&#9;// 0 &lt;= T &lt;= 1   blending parameter</P>
<P>&#9;void *Result);&#9;&#9;&#9;// put the result in here (geQuaternion)</P>
<P>&#9;&#9;// interpolates to get a vector between the two vectors at the two</P>
<P>&#9;&#9;// keyframes where T==0 returns the vector for KF1 </P>
<P>&#9;&#9;// and T==1 returns the vector for KF2</P>
<P>&#9;&#9;// interpolates using spherical quadratic blending</P>

<P>void GENESISCC geQKFrame_SquadRecompute(</P>
<P>&#9;int Looped,&#9;&#9;&#9;&#9;// if keylist has the first key connected to last key</P>
<P>&#9;geTKArray *KeyList);</P>
<P>&#9;// rebuild precomputed data for keyframe list.</P>

<P>void GENESISCC geQKFrame_SlerpRecompute(</P>
<P>&#9;geTKArray *KeyList);&#9;&#9;// list of keys to recompute hermite values for</P>
<P>&#9;// rebuild precomputed data for keyframe list.</P>

<P>&nbsp;</P>
<P>geBoolean GENESISCC geQKFrame_LinearRead(geVFile* pFile, void* geQKFrame);</P>
<P>geBoolean GENESISCC geQKFrame_SlerpRead(geVFile* pFile, void* geQKFrame);</P>
<P>geBoolean GENESISCC geQKFrame_SquadRead(geVFile* pFile, void* geQKFrame);</P>

<P>geBoolean GENESISCC geQKFrame_WriteToFile(geVFile *pFile, void *geQKFrame, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geQKFrame_InterpolationType InterpolationType, int Looping);</P>
<P>geTKArray *GENESISCC geQKFrame_CreateFromFile(geVFile *pFile, geQKFrame_InterpolationType *InterpolationType, int *Looping);</P>
<P>geTKArray *GENESISCC geQKFrame_CreateFromBinaryFile(geVFile *pFile, int *InterpolationType, int *Looping);</P>
<P>geBoolean GENESISCC geQKFrame_WriteToBinaryFile(geVFile *pFile, geTKArray *KeyList, </P>
<P>&#9;&#9;geQKFrame_InterpolationType InterpolationType, int Looping);</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069962">strblock.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  STRBLOCK.H&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description: String block interface.&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>// geStrBlock</P>
<P>#ifndef GE_STRBLOCK_H</P>
<P>#define GE_STRBLOCK_H</P>

<P>#include "basetype.h"&#9;// geBoolean</P>
<P>#include "vfile.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct geStrBlock geStrBlock;</P>

<P>geStrBlock *GENESISCC geStrBlock_Create(void);</P>
<P>void GENESISCC geStrBlock_Destroy(geStrBlock **SB);</P>

<P>geBoolean GENESISCC geStrBlock_Append(geStrBlock **ppSB,const char *String);</P>

<P>void GENESISCC geStrBlock_Delete(geStrBlock **ppSB,int Nth);</P>

<P>const char *GENESISCC geStrBlock_GetString(const geStrBlock *SB, int Index);</P>

<P>// untested...</P>
<P>//geBoolean GENESISCC geStrBlock_SetString(geStrBlock **ppSB, int Index, const char *String);</P>
<P>//geBoolean GENESISCC geStrBlock_Insert(geStrBlock **ppSB,int InsertAfterIndex,const char *String);</P>

<P>geBoolean GENESISCC geStrBlock_FindString(const geStrBlock* pSB, const char* String, int* pIndex);</P>

<P>int GENESISCC geStrBlock_GetCount(const geStrBlock *SB);</P>
<P>int GENESISCC geStrBlock_GetChecksum(const geStrBlock *SB);</P>

<P>geStrBlock* GENESISCC geStrBlock_CreateFromFile(geVFile* pFile);</P>
<P>geBoolean GENESISCC geStrBlock_WriteToFile(const geStrBlock *SB, geVFile *pFile);</P>
<P>geBoolean GENESISCC geStrBlock_WriteToBinaryFile(const geStrBlock *SB,geVFile *pFile);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069963">tkarray.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  TKARRAY.H&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description: Time-keyed array interface.&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_TKARRAY_H</P>
<P>#define GE_TKARRAY_H</P>
<P>/* TKArray</P>
<P>&#9;(Time-Keyed-Array)</P>
<P>&#9;This module is designed primarily to support path.c</P>

<P>&#9;The idea is that there are these packed arrays of elements,</P>
<P>&#9;sorted by a geTKArray_TimeType key.  The key is assumed to be the </P>
<P>&#9;first field in each element.</P>

<P>&#9;the TKArray functions operate on this very specific array type.</P>

<P>&#9;Error conditions are reported to errorlog</P>
<P>*/</P>

<P>#include "basetype.h"</P>
<P>#include "vfile.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef geFloat geTKArray_TimeType;</P>

<P>#define GE_TKA_TIME_TOLERANCE (0.00001f)</P>

<P>typedef struct geTKArray geTKArray;</P>

<P>geTKArray *GENESISCC geTKArray_Create(int ElementSize);</P>
<P>&#9;// creates new array with given attributes</P>

<P>geTKArray *GENESISCC geTKArray_CreateEmpty(int ElementSize,int ElementCount);</P>
<P>&#9;// creates new array with given element size and given count of uninitialized members</P>

<P>geTKArray* GENESISCC geTKArray_CreateFromBinaryFile(</P>
<P>&#9;geVFile* pFile);&#9;&#9;&#9;&#9;&#9;// stream positioned at array data</P>
<P>&#9;// Creates a new array from the given stream.</P>

<P>geBoolean GENESISCC geTKArray_WriteToBinaryFile(</P>
<P>&#9;const geTKArray* Array,&#9;&#9;&#9;// sorted array to write</P>
<P>&#9;geVFile* pFile);&#9;&#9;&#9;&#9;&#9;// stream positioned for writing</P>
<P>&#9;// Writes the array to the given stream.</P>

<P>&nbsp;</P>
<P>int GENESISCC geTKArray_BSearch(</P>
<P>&#9;const geTKArray *Array,&#9;&#9;&#9;// sorted array to search</P>
<P>&#9;geTKArray_TimeType Key);&#9;&#9;// searching for this time</P>
<P>&#9;// Searches for key in the Array. (assumes array is sorted) </P>
<P>&#9;// if key is found (within +-tolerance), the index to that element is returned.</P>
<P>&#9;// if key is not found, the index to the key just smaller than the </P>
<P>&#9;// given key is returned.  (-1 if the key is smaller than the first element)</P>
<P>&#9;// search is only accurate to 2*TKA_TIME_TOLERANCE.  </P>
<P>&#9;// if multiple keys exist within 2*TKA_TIME_TOLERANCE, this will find an arbitrary one of them.</P>

<P>geBoolean GENESISCC geTKArray_Insert(</P>
<P>&#9;geTKArray **Array,</P>
<P>&#9;geTKArray_TimeType Key,&#9;&#9;&#9;// time to insert</P>
<P>&#9;int *Index);&#9;&#9;&#9;&#9;&#9;// new element index</P>
<P>&#9;// inserts a new element into Array.</P>
<P>&#9;// sets only the key for the new element - the rest is junk</P>
<P>&#9;// returns TRUE if the insertion was successful.</P>
<P>&#9;// returns FALSE if the insertion failed. </P>
<P>&#9;// if Array is empty (no elements, NULL pointer) it is allocated and filled </P>
<P>&#9;// with the one Key element</P>
<P>&#9;// Index is the index of the new element </P>

<P>geBoolean GENESISCC geTKArray_DeleteElement(</P>
<P>&#9;geTKArray **Array,</P>
<P>&#9;int N);&#9;&#9;&#9;&#9;&#9;&#9;&#9;// element to delete</P>
<P>&#9;// deletes an element from Array.</P>
<P>&#9;// returns TRUE if the deletion was successful. </P>
<P>&#9;// returns FALSE if the deletion failed. (key not found or realloc failed)</P>

<P>void GENESISCC geTKArray_Destroy(</P>
<P>&#9;geTKArray **Array);&#9;</P>
<P>&#9;// destroys array</P>

<P>void *GENESISCC geTKArray_Element(</P>
<P>&#9;const geTKArray *Array,</P>
<P>&#9;int N);</P>
<P>&#9;// returns a pointer to the Nth element of the array.</P>

<P>int GENESISCC geTKArray_NumElements(</P>
<P>&#9;const geTKArray *Array);</P>
<P>&#9;// returns the number of elements in the array</P>

<P>geTKArray_TimeType GENESISCC geTKArray_ElementTime(</P>
<P>&#9;const geTKArray *Array, </P>
<P>&#9;int N);</P>
<P>&#9;// returns the Time associated with the Nth element of the array</P>

<P>int GENESISCC geTKArray_ElementSize(</P>
<P>&#9;const geTKArray *A);</P>
<P>&#9;// returns the size of each element in the array</P>

<P>geBoolean GENESISCC geTKArray_SamplesAreTimeLinear(const geTKArray *Array,geFloat Tolerance);</P>
<P>&#9;// returns true if the samples are linear in time within a tolerance</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069964">tkevents.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  TKARRAY.H&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Stephen Balkum&#9;                                                            */</P>
<P>/*  Description: Time-keyed events interface.&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_TKEVENTS_H</P>
<P>#define GE_TKEVENTS_H</P>
<P>/* TKEvents</P>
<P>&#9;(Time-Keyed-Events)</P>
<P>&#9;This module is designed primarily to support motion.c</P>

<P>&#9;geTKEvents is a sorted array of times with an identifying descriptor.</P>
<P>&#9;The descriptors are stored as strings in a separate, packed buffer.</P>

<P>&#9;Error conditions are reported to errorlog</P>
<P>*/</P>

<P>#include "basetype.h"</P>
<P>#include "vfile.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct geTKEvents geTKEvents;</P>
<P>typedef geFloat geTKEvents_TimeType;</P>

<P>geTKEvents* GENESISCC geTKEvents_Create(void);</P>
<P>&#9;// Creates a new event array.</P>

<P>void GENESISCC geTKEvents_Destroy(geTKEvents** pEvents);</P>
<P>&#9;// Destroys array.</P>

<P>geBoolean GENESISCC geTKEvents_Insert(geTKEvents* pEvents, geTKEvents_TimeType tKey, const char* pEventData);</P>
<P>&#9;// Inserts the new key and corresponding data.</P>

<P>geBoolean GENESISCC geTKEvents_Delete(geTKEvents* pEvents, geTKEvents_TimeType tKey);</P>
<P>&#9;// Deletes the key </P>

<P>geTKEvents* GENESISCC geTKEvents_CreateFromFile(</P>
<P>&#9;geVFile* pFile);&#9;&#9;&#9;&#9;&#9;// stream positioned at array data</P>
<P>&#9;// Creates a new array from the given stream.</P>

<P>geBoolean GENESISCC geTKEvents_WriteToFile(</P>
<P>&#9;const geTKEvents* pEvents,&#9;&#9;// sorted array to write</P>
<P>&#9;geVFile* pFile);&#9;&#9;&#9;&#9;&#9;// stream positioned for writing</P>
<P>&#9;// Writes the array to the given stream.</P>

<P>geBoolean GENESISCC geTKEvents_WriteToBinaryFile(</P>
<P>&#9;const geTKEvents* pEvents,&#9;&#9;// sorted array to write (in binary format)</P>
<P>&#9;geVFile* pFile);&#9;&#9;&#9;&#9;&#9;// stream positioned for writing</P>
<P>&#9;// Writes the array to the given stream.</P>
<P>//---------------------------------------------------------------------------</P>
<P>// Event Iteration</P>

<P>void GENESISCC geTKEvents_SetupIterator(</P>
<P>&#9;geTKEvents* pEvents,&#9;&#9;&#9;&#9;// Event list to iterate</P>
<P>&#9;geTKEvents_TimeType StartTime,&#9;&#9;&#9;&#9;// Inclusive search start</P>
<P>&#9;geTKEvents_TimeType EndTime);&#9;&#9;&#9;&#9;// Non-inclusive search stop</P>
<P>&#9;// For searching or querying the array for events between two times</P>
<P>&#9;// times are compaired [StartTime,EndTime), '[' is inclusive, ')' is </P>
<P>&#9;// non-inclusive.  This prepares the PathGetNextEvent() function.</P>

<P>geBoolean GENESISCC geTKEvents_GetNextEvent(</P>
<P>&#9;geTKEvents* pEvents,&#9;&#9;&#9;&#9;// Event list to iterate</P>
<P>&#9;geTKEvents_TimeType *pTime,&#9;&#9;&#9;&#9;// Return time, if found</P>
<P>&#9;const char **ppEventString);&#9;// Return data, if found</P>
<P>&#9;// Iterates from StartTime to EndTime as setup in geTKEvents_CreateIterator()</P>
<P>&#9;// and for each event between these times [StartTime,EndTime)</P>
<P>&#9;// this function will return Time and EventString returned for that event</P>
<P>&#9;// and the iterator will be positioned for the next search.  When there </P>
<P>&#9;// are no more events in the range, this function will return GE_FALSE (Time</P>
<P>&#9;// will be 0 and ppEventString will be empty).</P>

<P>GENESISAPI geBoolean GENESISCC geTKEvents_GetExtents(</P>
<P>&#9;&#9;geTKEvents *Events,</P>
<P>&#9;&#9;geTKEvents_TimeType *FirstEventTime,&#9;// time of first event</P>
<P>&#9;&#9;geTKEvents_TimeType *LastEventTime);&#9;// time of last event</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#endif // __TKEVENTS_H__</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069965">vkframe.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  VKFRAME.H&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description: Vector keyframe interface.&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>/* VKFrame (Vector-Keyframe)</P>
<P>&#9;This module handles interpolation for keyframes that contain a vector (a geVec3d)</P>
<P>&#9;This is intended to support Path.c</P>
<P>&#9;geTKArray supplies general support for a time-keyed array, and this supplements</P>
<P>&#9;that support to include the two specific time-keyed arrays:</P>
<P>&#9;  An array of geVec3d interpolated linearly</P>
<P>&#9;  An array of geVec3d interpolated with hermite blending</P>
<P>&#9;These are phycially separated and have different base structures because:</P>
<P>&#9;&#9;linear blending requires less data.</P>
<P>&#9;&#9;future blending might require more data.</P>
<P>&#9;The two types of lists are created with different creation calls,</P>
<P>&#9;interpolated with different calls, but insertion and queries share a call.</P>

<P>&#9;Hermite interpolation requires additional computation after changes are</P>
<P>&#9;made to the keyframe list.  Call geVKFrame_HermiteRecompute() to update the</P>
<P>&#9;calculations.</P>
<P>*/</P>
<P>#ifndef GE_VKFRAME_H</P>
<P>#define GE_VKFRAME_H</P>

<P>#include "TKArray.h"</P>
<P>#include "vfile.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef enum</P>
<P>{</P>
<P>&#9;VKFRAME_LINEAR,</P>
<P>&#9;VKFRAME_HERMITE,</P>
<P>&#9;VKFRAME_HERMITE_ZERO_DERIV,</P>
<P>} geVKFrame_InterpolationType;</P>

<P>&nbsp;</P>
<P>geTKArray *GENESISCC geVKFrame_LinearCreate(void);</P>
<P>&#9;// creates a frame list for linear interpolation</P>

<P>geTKArray *GENESISCC geVKFrame_HermiteCreate(void);</P>
<P>&#9;// creates a frame list for hermite interpolation</P>

<P>&nbsp;</P>
<P>geBoolean GENESISCC geVKFrame_Insert(</P>
<P>&#9;geTKArray **KeyList,&#9;&#9;&#9;// keyframe list to insert into</P>
<P>&#9;geTKArray_TimeType Time,&#9;&#9;// time of new keyframe</P>
<P>&#9;const geVec3d *V,&#9;&#9;&#9;&#9;// vector at new keyframe</P>
<P>&#9;int *Index);&#9;&#9;&#9;&#9;&#9;// indx of new key</P>
<P>&#9;// inserts a new keyframe with the given time and vector into the list.</P>

<P>void GENESISCC geVKFrame_Query(</P>
<P>&#9;const geTKArray *KeyList,&#9;&#9;// keyframe list</P>
<P>&#9;int Index,&#9;&#9;&#9;&#9;&#9;&#9;// index of frame to return</P>
<P>&#9;geTKArray_TimeType *Time,&#9;&#9;// time of the frame is returned</P>
<P>&#9;geVec3d *V);&#9;&#9;&#9;&#9;&#9;&#9;// vector from the frame is returned</P>
<P>&#9;// returns the vector and the time at keyframe[index] </P>

<P>void GENESISCC geVKFrame_Modify(</P>
<P>&#9;geTKArray *KeyList,&#9;&#9;&#9;&#9;// keyframe list</P>
<P>&#9;int Index,&#9;&#9;&#9;&#9;&#9;&#9;// index of frame to change</P>
<P>&#9;const geVec3d *V);&#9;&#9;&#9;&#9;// vector for the key</P>
<P>&#9;// chganes the vector at keyframe[index] </P>

<P>void GENESISCC geVKFrame_LinearInterpolation(</P>
<P>&#9;const void *KF1,&#9;&#9;// pointer to first keyframe</P>
<P>&#9;const void *KF2,&#9;&#9;// pointer to second keyframe</P>
<P>&#9;geFloat T,&#9;&#9;&#9;&#9;// 0 &lt;= T &lt;= 1   blending parameter</P>
<P>&#9;void *Result);&#9;&#9;&#9;// put the result in here (geVec3d)</P>
<P>&#9;&#9;// interpolates to get a vector between the two vectors at the two</P>
<P>&#9;&#9;// keyframes where T==0 returns the vector for KF1 </P>
<P>&#9;&#9;// and T==1 returns the vector for KF2</P>
<P>&#9;&#9;// interpolates linearly</P>

<P>void GENESISCC geVKFrame_HermiteInterpolation(</P>
<P>&#9;const void *KF1,&#9;&#9;// pointer to first keyframe</P>
<P>&#9;const void *KF2,&#9;&#9;// pointer to second keyframe</P>
<P>&#9;geFloat T,&#9;&#9;&#9;&#9;// 0 &lt;= T &lt;= 1   blending parameter</P>
<P>&#9;void *Result);&#9;&#9;&#9;// put the result in here (geVec3d)</P>
<P>&#9;&#9;// interpolates to get a vector between the two vectors at the two</P>
<P>&#9;&#9;// keyframes where T==0 returns the vector for KF1 </P>
<P>&#9;&#9;// and T==1 returns the vector for KF2</P>
<P>&#9;&#9;// interpolates using 'hermite' blending</P>

<P>&nbsp;</P>
<P>void GENESISCC geVKFrame_HermiteRecompute(</P>
<P>&#9;int Looped,&#9;&#9;&#9;&#9;&#9;// if keylist has the first key connected to last key</P>
<P>&#9;geBoolean ZeroDerivative,&#9;// if each key should have a zero derivatives (good for 2 point S curves)</P>
<P>&#9;geTKArray *KeyList);&#9;&#9;// list of keys to recompute hermite values for</P>
<P>&#9;// rebuild precomputed data for keyframe list.</P>

<P>&nbsp;</P>
<P>geBoolean GENESISCC geVKFrame_LinearRead(geVFile* pFile, void* geVKFrame);</P>
<P>geBoolean GENESISCC geVKFrame_HermiteRead(geVFile* pFile, void* geVKFrame);</P>

<P>geBoolean GENESISCC geVKFrame_WriteToFile(geVFile *pFile, void *geVKFrame, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVKFrame_InterpolationType InterpolationType,int Looping);</P>
<P>geTKArray *GENESISCC geVKFrame_CreateFromFile(geVFile *pFile, geVKFrame_InterpolationType *InterpolationType, int *Looping);</P>
<P>geBoolean GENESISCC geVKFrame_WriteToBinaryFile(geVFile *pFile, void *geVKFrame, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVKFrame_InterpolationType InterpolationType, int Looping);</P>
<P>geTKArray *GENESISCC geVKFrame_CreateFromBinaryFile(geVFile *pFile, geVKFrame_InterpolationType *InterpolationType, int *Looping);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069966">xfarray.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  XFARRAY.H&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description: Array of transforms interface.&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_XFARRAY_H</P>
<P>#define GE_XFARRAY_H</P>

<P>/* This is a simple object to formalize an array of transforms (geXForm3d)</P>

<P>   Unfortunately, it's not a very safe object.</P>

<P>   This object exports data (allows external access to one of it's data members)</P>
<P>   This is dangerous - no checking can be done on the use of that data, and no</P>
<P>   checking can be done on array boundry conditions.  This is on purpose.</P>
<P>   </P>
<P>   ...In the name of optimal access to the array.</P>
<P>*/</P>

<P>#include "xform3d.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct geXFArray geXFArray;</P>

<P>&#9;// Create the object.  Creates an array of Size elements.  </P>
<P>&#9;// All elements are initialized to the identity transform</P>
<P>geXFArray *GENESISCC geXFArray_Create(int Size);</P>

<P>&#9;// Destroy the object.  Don't use the pointer returned by _GetElements</P>
<P>&#9;// after destroying the ojbect!</P>
<P>void GENESISCC geXFArray_Destroy( geXFArray **XFA );</P>

<P>&#9;// Get a pointer to the array.  For external iteration.  The size of the </P>
<P>&#9;// array is returned in Size.  Valid array indicies are (0..Size-1)</P>
<P>geXForm3d *GENESISCC geXFArray_GetElements(const geXFArray *XFA, int *Size);</P>

<P>&#9;// Sets every transform in the array to the given transform.</P>
<P>void GENESISCC geXFArray_SetAll(geXFArray *XFA, const geXForm3d *Matrix);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069967">OpenSource/Source/Bitmap Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>The routines in this subdirectory handle bitmap graphics and apply textures to walls and objects.</P>
</FONT><FONT FACE="Arial" SIZE=2><P>#ifndef GE_BITMAP____H</P>
<P>#define GE_BITMAP____H</P>

<P>/****************************************************************************************/</P>
<P>/*  Bitmap.__h                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description:  Bitmap*.c Internal Header (contains the Bitmap Struct)                */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#include "bitmap.h"</P>
<P>#include "bitmap._h"</P>

<P>// Hey ! </P>
<P>// this is bitmap.__h : for inclusion by bitmap friends ONLY!</P>
<P>//&#9;included by bitmap.c , bitmap_blitdata.c</P>

<P>/*}{ *********** the bitmap type *******************/</P>

<P>// the Version Major indicates an incompatibility</P>

<P>#define GEBM_VERSION_MAJOR&#9;&#9;(0x0004)</P>
<P>#define GEBM_VERSION_MINOR&#9;&#9;(0x0000)</P>

<P>#define&#9;MAXMIPLEVELS&#9;&#9;&#9;(8)</P>

<P>#define PALETTE_FORMAT_DEFAULT&#9;(GE_PIXELFORMAT_24BIT_RGB)</P>

<P>#define ALPHA_TO_TRANSPARENCY_THRESHOLD&#9;&#9;(80)</P>

<P>struct geBitmap_Palette</P>
<P>{</P>
<P>&#9;int&#9;&#9;&#9;&#9;LockCount,RefCount;</P>
<P>&#9;gePixelFormat&#9;Format;</P>
<P>&#9;int&#9;&#9;&#9;&#9;Size;</P>
<P>&#9;geBoolean&#9;&#9;HasColorKey;</P>
<P>&#9;uint32&#9;&#9;&#9;ColorKey;&#9;&#9;// the color which is the colorkey</P>
<P>&#9;int&#9;&#9;&#9;&#9;ColorKeyIndex;&#9;// the palette index which is the color;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Bitmap-&gt;CK == Bitmap-&gt;Pal-&gt;CK_Index</P>

<P>&#9;// we have EITHER Data or DriverHandle</P>
<P>&#9;void&#9;&#9;&#9;*Data;&#9;&#9;//Size * BytesPerPixel(Format)</P>
<P>&#9;DRV_Driver&#9;&#9;*Driver;</P>
<P>&#9;geRDriver_THandle*DriverHandle;</P>
<P>&#9;void&#9;&#9;&#9;*DriverBits;&#9;//only non-null inside a Lock/UnLock</P>
<P>};</P>

<P>struct geBitmap</P>
<P>{</P>
<P>&#9;int &#9;&#9;&#9;&#9;RefCount;</P>
<P>&#9;geBitmap_Info&#9;&#9;Info;</P>
<P>&#9;void *&#9;&#9;&#9;&#9;Data[MAXMIPLEVELS];</P>
<P>&#9;geBoolean&#9;&#9;&#9;Modified[MAXMIPLEVELS];</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;// modified tells whether a mip != a scaledown of mip 0</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;// modified[0] is ignored</P>
<P>&#9;geBitmap *&#9;&#9;&#9;Alpha;</P>

<P>&#9;int&#9;&#9;&#9;&#9;&#9;LockCount;&#9;// -Nmips for 'write' , &gt; 0 for 'read's</P>
<P>&#9;geBitmap *&#9;&#9;&#9;LockOwner;&#9;// this points to our owner and doubles as boolean 'islocked'</P>
<P>&#9;geBitmap *&#9;&#9;&#9;DataOwner;&#9;// if this is set, then my Data is not mine to free</P>

<P>&#9;gePixelFormat&#9;&#9;PreferredFormat;&#9;// user's favorite</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;SeekMipCount;&#9;&#9;// when we attach to driver, ask for this many mips</P>

<P>&#9;&#9;// must support any number of locks for read</P>
<P>&#9;&#9;// a lock for read can be a pointer to my raw bits, or a whole different bitmap</P>

<P>&#9;geBitmap_Info&#9;&#9;DriverInfo;&#9;&#9;&#9;// all the driver mess..</P>
<P>&#9;uint32&#9;&#9;&#9;&#9;DriverFlags;</P>
<P>&#9;DRV_Driver *&#9;&#9;Driver;</P>
<P>&#9;geRDriver_THandle *&#9;DriverHandle;</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;DriverMipLock;&#9;&#9;// which mip to lock on GetBits</P>
<P>&#9;geBoolean&#9;&#9;&#9;DriverBitsLocked;</P>
<P>&#9;geBoolean&#9;&#9;&#9;DriverDataChanged;&#9;// relative to system copy</P>
<P>&#9;geFloat&#9;&#9;&#9;&#9;DriverGamma;</P>
<P>&#9;geFloat&#9;&#9;&#9;&#9;DriverGammaLast;</P>
<P>&#9;geBoolean&#9;&#9;&#9;DriverGammaSet;</P>
<P>};</P>

<P>&nbsp;</P>
<P>/*}{ ************* internal protos *****************/</P>

<P>//geBitmap * geBitmap_CreateXerox(geBitmap *BmpSrc);</P>

<P>geBoolean geBitmap_IsValid(const geBitmap *Bmp);</P>
<P>geBoolean geBitmap_Info_IsValid(const geBitmap_Info *Info);</P>
<P>geBoolean geBitmap_Palette_IsValid(const geBitmap_Palette *Pal);</P>

<P>geBoolean geBitmap_BlitMipRect(const geBitmap * Src, int SrcMip, int SrcX,int SrcY,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; geBitmap * Dst, int DstMip, int DstX,int DstY,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;int SizeX,int SizeY);</P>

<P>geBitmap * geBitmap_CreateLock_CopyInfo(geBitmap *BmpSrc,int LockCnt,int mip);</P>
<P>geBitmap * geBitmap_CreateLockFromMip(geBitmap *Src,int mip,</P>
<P>&#9;gePixelFormat Format,geBoolean HasColorKey,uint32 ColorKey,int LockCnt);</P>
<P>geBitmap * geBitmap_CreateLockFromMipSystem(geBitmap *Src,int mip,int LockCnt);</P>
<P>geBitmap * geBitmap_CreateLockFromMipOnDriver(geBitmap *Src,int mip,int LockCnt);</P>

<P>geBoolean geBitmap_UnLock_NoChange(geBitmap *Bmp);</P>
<P>geBoolean geBitmap_UnLockArray_NoChange(geBitmap **Locks,int Size);</P>

<P>geBoolean geBitmap_Update_SystemToDriver(geBitmap *Bmp);</P>
<P>geBoolean geBitmap_Update_DriverToSystem(geBitmap *Bmp);</P>

<P>geBoolean geBitmap_MakeSystemMips(geBitmap *Bmp,int low,int high);</P>
<P>geBoolean geBitmap_UpdateMips_Data(&#9;geBitmap_Info * FmInfo,void * FmBits,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap_Info * ToInfo,void * ToBits);</P>
<P>geBoolean geBitmap_UpdateMips_System(geBitmap *Bmp,int fm,int to);</P>

<P>geBoolean geBitmap_UsesColorKey(const geBitmap * Bmp);</P>

<P>void&#9;  geBitmap_MakeMipInfo(  geBitmap_Info *Src,int mip,geBitmap_Info *Into);</P>
<P>geBoolean geBitmap_MakeDriverLockInfo(geBitmap *Bmp,int mip,geBitmap_Info *Into);</P>
<P>&#9;&#9;&#9;&#9;&#9;// MakeDriverLockInfo also doesn't full out the full info, so it must be a valid info first!</P>
<P>&#9;&#9;&#9;&#9;&#9;// Bmp also gets some crap written into him.</P>

<P>geBoolean geBitmap_AllocSystemMip(geBitmap *Bmp,int mip);</P>
<P>geBoolean geBitmap_AllocPalette(geBitmap *Bmp,gePixelFormat Format,DRV_Driver * Driver);</P>

<P>geBoolean geBitmap_ReadInfo( geBitmap *Bmp,geVFile * F);</P>
<P>geBoolean geBitmap_WriteInfo(const geBitmap *Bmp,geVFile * F);</P>

<P>geBoolean geBitmap_FixDriverFlags(uint32 *pFlags);</P>

<P>/*}{ ************* end *****************/</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069968">bitmap._h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>#ifndef BITMAP_PRIVATE_H</P>
<P>#define BITMAP_PRIVATE_H</P>

<P>/****************************************************************************************/</P>
<P>/*  Bitmap._h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description:  Engine-Internal Bitmap Functions                                      */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>&nbsp;</P>
<P>#include&#9;"bitmap.h"</P>
<P>#include&#9;"dcommon.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>/***</P>
<P>**</P>
<P>*</P>
<P>* These functions are intended for internal Genesis use only.</P>
<P>*</P>
<P>* This can become public once Driver is exposed/formalized. !@@!</P>
<P>*</P>
<P>* Only engine.c , and maybe world &amp; bitmaplist should include this !</P>
<P>*</P>
<P>* You MUST DetachDriver from a bitmap, before you change the Driver</P>
<P>*</P>
<P>**</P>
<P> **/</P>

<P>#define BITMAP_GENESIS_INTERNAL&#9;GENESISCC</P>

<P>geBoolean&#9;&#9;&#9;GENESISCC geBitmap_AttachToDriver(geBitmap *Bmp, DRV_Driver * Driver, uint32 DriverFlags);</P>
<P>&#9;// use Driverflags == 0 to use the flags from _SetDriverFlags</P>

<P>geBoolean&#9;&#9;&#9;GENESISCC geBitmap_DetachDriver(geBitmap *Bmp, geBoolean DoUpdate);</P>
<P>&#9;// You MUST Detach the Driver while it is identical to the way it was when attached!</P>

<P>geBitmap_Palette *&#9;GENESISCC geBitmap_Palette_CreateFromDriver(DRV_Driver * Driver,gePixelFormat Format,int Size); /*&lt;&gt;*/</P>

<P>geRDriver_THandle * GENESISCC geBitmap_GetTHandle(const geBitmap *Bmp);</P>

<P>geBoolean&#9;&#9;&#9;GENESISCC geBitmap_SetDriverFlags(geBitmap *Bmp,uint32 flags);</P>

<P>geBoolean&#9;&#9;&#9;GENESISCC geBitmap_SetGammaCorrection_DontChange(geBitmap *Bmp,geFloat Gamma);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif // BITMAP_PRIVATE_H</P>

<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069969">bitmap.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>#ifndef BITMAP_H</P>
<P>#define BITMAP_H</P>

<P>/****************************************************************************************/</P>
<P>/*  Bitmap.h                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description:  Abstract Bitmap system                                                */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#include "basetype.h"</P>
<P>#include "pixelformat.h"</P>
<P>#include "vfile.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>/***********************************************************************************/</P>

<P>typedef struct geBitmap&#9;&#9;&#9;geBitmap;</P>
<P>typedef struct geBitmap_Palette&#9;geBitmap_Palette;</P>

<P>typedef struct geBitmap_Info</P>
<P>{</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;&#9;Width;</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;&#9;Height;</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;&#9;Stride;&#9;&#9;// stride is in *pixels* ; it is the step to the next line : Stride &gt;= Width</P>
<P>&#9;gePixelFormat&#9;&#9;&#9;Format;</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;&#9;MinimumMip;&#9;//*including* minimumMip == 0 often</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;&#9;MaximumMip;&#9;//*including* maximumMip == nummips-1</P>
<P>&#9;geBoolean&#9;&#9;&#9;&#9;HasColorKey;</P>
<P>&#9;uint32&#9;&#9;&#9;&#9;&#9;ColorKey;&#9;// meaningless unless HasColorKey ; the ColorKey is a Pixel in Format</P>
<P>&#9;geBitmap_Palette *&#9;&#9;Palette;</P>
<P>} geBitmap_Info;</P>

<P>/***********************************************************************************/&#9;&#9;</P>
<P>// Bitmap methods</P>

<P>// see a big comment at the end of this file</P>

<P>/************************************************************************/</P>

<P>GENESISAPI geBitmap *&#9;GENESISCC&#9;geBitmap_Create(int Width, int Height, int MipCount, gePixelFormat Format ); </P>
<P>GENESISAPI void&#9;&#9;&#9;GENESISCC&#9;geBitmap_CreateRef(geBitmap *Bmp);</P>

<P>GENESISAPI geBitmap *&#9;GENESISCC&#9;geBitmap_CreateFromInfo(const geBitmap_Info * pInfo);</P>

<P>GENESISAPI geBitmap *&#9;GENESISCC&#9;geBitmap_CreateFromFile( geVFile *F );</P>
<P>GENESISAPI geBitmap *&#9;GENESISCC&#9;geBitmap_CreateFromFileName(const geVFile *BaseFS,const char *Name);</P>
<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_WriteToFile( const geBitmap *Bmp, geVFile *F );</P>
<P>GENESISAPI geBoolean&#9;GENESISCC&#9;geBitmap_WriteToFileName(const geBitmap * Bmp,const geVFile *BaseFS,const char *Name);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// BaseFS is not really const if it is a virtual file;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//  it *is* const if it is a dos directory</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_Destroy(geBitmap **Bmp);</P>
<P>&#9;// returns whether Bmp was actually destroyed : not success/failure</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_GetInfo(const geBitmap *Bmp, geBitmap_Info *Info, geBitmap_Info *SecondaryInfo);</P>
<P>&#9;//LockForWrite returns data in Info's format</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_Blit(const&#9;geBitmap *Src, int SrcPositionX, int SrcPositionY,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap *Dst, int DstPositionX, int DstPositionY,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int SizeX, int SizeY );</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_BlitMip(const geBitmap * Src, int SrcMip, geBitmap * Dst, int DstMip );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// don't use this with Src == Dst, use UpdateMips instead !</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_BlitBitmap(const geBitmap * Src, geBitmap * Dst);</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_BlitBestMip(const geBitmap * Src, geBitmap * Dst);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// blits the largest mip from Src that fits in Dst</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_LockForRead(&#9;&#9;// a non-exclusive lock</P>
<P>&#9;const geBitmap *&#9;Bmp,</P>
<P>&#9;geBitmap **&#9;&#9;&#9;Target,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MinimumMip,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MaximumMip,</P>
<P>&#9;gePixelFormat &#9;&#9;Format,</P>
<P>&#9;geBoolean&#9;&#9;&#9;RespectColorKey,</P>
<P>&#9;uint32&#9;&#9;&#9;&#9;ColorKey);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// not really const, stores lock-count, but *data* is const</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// will do a format conversion!</P>

<P>GENESISAPI geBoolean&#9;GENESISCC&#9;geBitmap_LockForReadNative(</P>
<P>&#9;const geBitmap *&#9;Bmp,</P>
<P>&#9;geBitmap **&#9;&#9;&#9;Target,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MinimumMip,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MaximumMip);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// lock for read in a format that gaurantee no conversions</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// then do GetInfo on the locks to see what you have!</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_LockForWrite(&#9;// an exclusive lock</P>
<P>&#9;geBitmap *&#9;&#9;&#9;Bmp,</P>
<P>&#9;geBitmap **&#9;&#9;&#9;Target,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MinimumMip,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MaximumMip);</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_LockForWriteFormat(</P>
<P>&#9;geBitmap *&#9;&#9;&#9;Bmp,</P>
<P>&#9;geBitmap **&#9;&#9;&#9;Target,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MinimumMip,</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;MaximumMip,</P>
<P>&#9;gePixelFormat &#9;&#9;Format);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Format must be one of the two returned in GetInfo !!</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_UnLock(geBitmap *Bmp);&#9;// must be done on All locked mips</P>
<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_UnLockArray(geBitmap **Locks,int Size);</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_SetFormat(geBitmap *Bmp, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;gePixelFormat NewFormat, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean RespectColorKey, uint32 ColorKey,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geBitmap_Palette * Palette);</P>
<P>&#9;// _SetFormat may cause you to lose color information!</P>
<P>&#9;// SetFormat does a conversion!</P>
<P>&#9;// if NewFormat is palettized and Palette is NULL, we create a palette for the bitmap!</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_SetFormatMin(geBitmap *Bmp,gePixelFormat NewFormat);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// the Min version keeps colorkey &amp; palette from the old format</P>

<P>GENESISAPI geBoolean&#9;GENESISCC&#9;geBitmap_SetColorKey(geBitmap *Bmp, geBoolean HasColorKey, uint32 ColorKey, geBoolean Smart);</P>
<P>&#9;// SetColorKey discards old colorkey information!</P>
<P>&#9;//&#9;does not do a conversion (changes the colorkey in the current data</P>
<P>&#9;// if 'Smart' is on, we don't set HasColorKey to true unless it is actually used!</P>

<P>GENESISAPI geBoolean&#9;GENESISCC&#9;geBitmap_GetAverageColor(const geBitmap *Bmp,int *pR,int *pG,int *pB);</P>
<P>&#9;// tells you the average color; computes it and caches it out</P>

<P>GENESISAPI geBitmap_Palette * &#9;GENESISCC&#9;geBitmap_GetPalette(const geBitmap *Bmp);</P>
<P>GENESISAPI geBoolean&#9;&#9;&#9;GENESISCC&#9;geBitmap_SetPalette(geBitmap *Bmp, const geBitmap_Palette *Palette);</P>
<P>&#9;// _SetPal tries to _CreateRef your Palette, so no copy occurs &amp; palettes may be shared</P>
<P>&#9;// you may _Destroy() palette after using it to set (though its bits may not be freed)</P>
<P>&#9;//&#9;(hence Palette is *not* const)</P>
<P>&#9;// Warning : SetPalette on any mip changes the palette of ALL mips !</P>
<P>&#9;// see Palette note at _UnLock</P>
<P>&#9;// _SetPal destroys the bitmap's original palette and refs the new one, </P>
<P>&#9;//&#9;&#9;so if you setpal with the bitmap's palette, there is no net change in ref counts (good!)</P>

<P>GENESISAPI geBoolean&#9;GENESISCC&#9;geBitmap_HasAlpha(const geBitmap * Bmp);</P>
<P>&#9;// returns true if bitmap has *any* type of alpha</P>

<P>GENESISAPI geBitmap *&#9;GENESISCC&#9;geBitmap_GetAlpha(const geBitmap *Bmp);</P>
<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_SetAlpha(geBitmap *Bmp, const geBitmap *AlphaBmp);</P>
<P>&#9;// we Ref the AlphaBmp, so you may destroy it after calling Set()</P>
<P>&#9;// it may be NULL</P>
<P>&#9;// there's only one Alpha per bitmap (for the top Mip) right now</P>

<P>GENESISAPI geBoolean&#9;GENESISCC&#9;geBitmap_SetGammaCorrection(geBitmap *Bmp,geFloat Gamma,geBoolean Apply);</P>
<P>&#9;// this Gamma does not change the *original* (system/secondary) bits</P>
<P>&#9;//&#9;it only affects the appearance when drawn</P>
<P>&#9;// note : if you write to the gamma corrected bits, you must gamma correct manually if you</P>
<P>&#9;//&#9;wish to fit in smoothly with the previous data</P>
<P>&#9;// warning : if you use this function with many different gammas, performance will suffer!</P>
<P>&#9;//&#9;use one global gamma for all bitmaps!  try to let the engine manage gamma for you,</P>
<P>&#9;//&#9;via geEngine_SetGamma !</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_SetPreferredFormat(geBitmap *Bmp,gePixelFormat Format);</P>
<P>GENESISAPI gePixelFormat&#9;GENESISCC&#9;geBitmap_GetPreferredFormat(const geBitmap *Bmp);</P>

<P>GENESISAPI void *&#9;&#9;GENESISCC&#9;geBitmap_GetBits(geBitmap *Bmp);&#9;// works only on a Lock()</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_RefreshMips(geBitmap *Bmp);&#9;// rebuilds mips; *tries* to be smart &amp; not overwrite manually-fixed mips</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// RefreshMips does *not* build mips that don't exist</P>
<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_UpdateMips(geBitmap *Bmp,int SourceMip,int TargetMip);&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// will create the target if it doesn't exist;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// will overwrite manually-fixed mips!</P>
<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_SetMipCount(geBitmap *Bmp,int Count);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// creates or destroys to match the new count</P>

<P>GENESISAPI geBoolean &#9;GENESISCC&#9;geBitmap_ClearMips(geBitmap *Bmp);&#9;// Destroy all mips (except the first) !</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// use with care! this is not polite!</P>

<P>// Shortcuts</P>
<P>GENESISAPI int&#9;&#9;&#9;GENESISCC&#9;geBitmap_Width(const geBitmap *Bitmap);</P>
<P>GENESISAPI int&#9;&#9;&#9;GENESISCC&#9;geBitmap_Height(const geBitmap *Bitmap);</P>
<P>GENESISAPI uint32&#9;&#9;GENESISCC&#9;geBitmap_MipBytes(const geBitmap * Bitmap,int mip);</P>

<P>/**</P>
<P>*</P>
<P>* if Bitmap is a lock for read, functions that modify it return failure</P>
<P>* if Bitmap is a lock for write, functions that modify it attempt to</P>
<P>*&#9;modify the owner of the lock</P>
<P>*</P>
<P>* warning : if you lock multiple mips for write, and then modify one of the mips</P>
<P>*&#9;&#9;(such as via SetPalette) it may affect the owner and all sibling mips!</P>
<P>*&#9;&#9;doing different SetPalettes with different palettes on different locked mips </P>
<P>*&#9;&#9;has undefined behavior!</P>
<P>*</P>
<P>**/</P>

<P>#ifdef _DEBUG</P>
<P>GENESISAPI uint32&#9;&#9;GENESISCC&#9;geBitmap_Debug_GetCount(void);</P>

<P>&#9;// assert this is zero before you shutdown !</P>

<P>#endif</P>

<P>/***********************************************************************************/</P>

<P>typedef enum</P>
<P>{</P>
<P>&#9;GE_BITMAP_STREAMING_ERROR=0,</P>
<P>&#9;GE_BITMAP_STREAMING_NOT,</P>
<P>&#9;GE_BITMAP_STREAMING_STARTED,</P>
<P>&#9;GE_BITMAP_STREAMING_IDLE,</P>
<P>&#9;GE_BITMAP_STREAMING_CHANGED,</P>
<P>&#9;GE_BITMAP_STREAMING_DATADONE,</P>
<P>&#9;GE_BITMAP_STREAMING_DONE,</P>
<P>} geBitmap_StreamingStatus;</P>

<P>GENESISAPI geBitmap_StreamingStatus GENESISCC geBitmap_GetStreamingStatus(const geBitmap *Bmp);</P>

<P>&#9;&#9;/** on a file which is streaming, the sequence of returns looks like :</P>

<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_IDLE</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_CHANGED</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_IDLE</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_IDLE</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_CHANGED</P>
<P>&#9;&#9;&#9;...</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_DONE</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_NOT</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_NOT</P>
<P>&#9;&#9;&#9;GE_BITMAP_STREAMING_NOT</P>
<P>&#9;&#9;&#9;...</P>

<P>&#9;&#9;Status &gt;= GE_BITMAP_STREAMING_STARTED means streaming has started &amp; is in progress</P>

<P>&#9;&#9;the user should never see _STARTED or _DATADONE</P>

<P>&#9;&#9;***/</P>

<P>/***********************************************************************************/</P>

<P>// palette methods :</P>

<P>GENESISAPI geBitmap_Palette * &#9;GENESISCC&#9;geBitmap_Palette_Create(gePixelFormat Format,int Size);</P>

<P>GENESISAPI geBitmap_Palette * &#9;GENESISCC&#9;geBitmap_Palette_CreateCopy(const geBitmap_Palette *Palette);</P>

<P>GENESISAPI geBitmap_Palette *&#9;GENESISCC&#9;geBitmap_Palette_CreateFromFile(geVFile *F);</P>

<P>GENESISAPI geBitmap_Palette *&#9;GENESISCC&#9;geBitmap_Palette_CreateFromBitmap(geBitmap * Bmp,geBoolean Slow);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// does GetPalette, and if NULL, then</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// it create an optimal palette for a</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//&#9;non-palettized bitmap</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//&#9;(this is a create, you must destroy later!)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// put Slow == TRUE for higher quality &amp; slower</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_SortColors(geBitmap_Palette * P,geBoolean Slower);</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_CreateRef(geBitmap_Palette *Palette);</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_Destroy(geBitmap_Palette ** ppPalette);</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_WriteToFile(const geBitmap_Palette *Palette,geVFile *F);</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_SetFormat(geBitmap_Palette * Palette,gePixelFormat Format);</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_Copy(const geBitmap_Palette * Src,geBitmap_Palette * Target);</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_GetInfo(const&#9;geBitmap_Palette *P,geBitmap_Info *Into);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// get the info as if it were a bitmap; Into-&gt;Height == 1</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_Lock(geBitmap_Palette *Palette, void **pBits, gePixelFormat *pFormat,int *pSize);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// pFormat &amp; pSize are optional</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_UnLock(geBitmap_Palette *Palette);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// palette unlock does NOT notify the bitmap that the palette has changed.</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// call Bitmap_SetPalette() with the same palette pointer </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// &#9;to tell the bitmap that it must to some processing</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// (don't worry, it won't duplicate it or copy it onto itself)</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_GetData(const geBitmap_Palette *P,      void *Into,gePixelFormat Format,int Colors);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_SetData(      geBitmap_Palette *P,const void *From,gePixelFormat Format,int Colors);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// does Lock/UnLock for you</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// From and Into are arrays of Colors*gePixelFormat_BytesPerPel bytes</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_SetEntryColor(      geBitmap_Palette *P,int Color,int R,int G,int B,int A);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_GetEntryColor(const geBitmap_Palette *P,int Color,int *R,int *G,int *B,int *A);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Set/Get does Lock/Unlock for you ; these are slow! do not use these to work on all the colors!</P>

<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_SetEntry(      geBitmap_Palette *P,int Color,uint32 Pixel);</P>
<P>GENESISAPI geBoolean&#9;&#9;GENESISCC&#9;geBitmap_Palette_GetEntry(const geBitmap_Palette *P,int Color,uint32 *Pixel);</P>

<P>/***********************************************************************************/</P>

<P>/************************************************************************</P>

<P>A brief tutorial on the Bitmap system, by Charles Bloom, cbloom@eclipsegames.com</P>

<P>The Bitmap is a smart wrapper for complex functionality.  You give it hints to</P>
<P>the opaque Bitmap object, and it tries its best to follow those hints, but it</P>
<P>may not always do so.  The Bitmap is the owner of its bits; you must Lock the</P>
<P>bitmap to get permission to touch those bits, and UnLock to tell the bitmap</P>
<P>you are done.  The format may change between two Locks.  Bitmaps can also be</P>
<P>multiply owned, so you should account for the fact that others may touch your</P>
<P>bitmap between your uses.</P>

<P>The Bitmap contains one or two pixel-sets representing an image.  The "primary" is</P>
<P>a fast-blitting version of the image, and the "secondary" is a storage version</P>
<P>(eventually wavelet compressed) which can be used to rebuild the primary if it is</P>
<P>freed or damaged.  Both cary a generalized format.</P>

<P>Let's do an example.  I want to load a bitmap, set it up for drawing with the</P>
<P>genesis Engine, and then blit some interactive stuff into it.</P>

<P>************************************************************************/</P>

<P>#if 0</P>
<P>// {</P>
<P>//-----------------------------------------------------------------------------</P>

<P>void Init(geEngine * Engine);</P>
<P>void Shutdown(void);</P>
<P>void Draw(void);</P>
<P>void DrawPolite(void);</P>

<P>static geBitmap * myBM = NULL;</P>
<P>static geEngine * myEngine = NULL;</P>

<P>void Init(geEngine * Engine)</P>
<P>{</P>
<P>geBoolean success;</P>
<P>geBitmap_Info Info;</P>

<P>&#9;myEngine = Engine;&#9;// this is not looked well upon; for ease of demonstration only!</P>
<P>&#9;assert(Engine);</P>

<P>&#9;myBM = geBitmap_CreateFromFileName(NULL,"mybitmap.bmp");</P>

<P>&#9;// CreateFromFile can load windows BMP files, or custom GeBm files.</P>

<P>&#9;assert(myBM);</P>

<P>&#9;// get the main info; I don't care about the secondary, so leave it NULL</P>

<P>&#9;success = geBitmap_GetInfo(myBM,&amp;Info,NULL);</P>
<P>&#9;assert(success);</P>

<P>&#9;// make sure I loaded a bitmap in the format I understand !</P>

<P>&#9;if ( Info.Format == GE_PIXELFORMAT_8BIT_PAL )</P>
<P>&#9;{</P>
<P>&#9;&#9;// I want palette index 255 to act as transparency, so I must use SetColorKey</P>

<P>&#9;&#9;success = geBitmap_SetColorKey(myBM,GE_TRUE,255);</P>
<P>&#9;&#9;assert(success);</P>

<P>&#9;&#9;// just for fun, let's modify the palette:</P>
<P>&#9;&#9;if (1)</P>
<P>&#9;&#9;{</P>
<P>&#9;&#9;geBitmap_Palette * Pal;</P>

<P>&#9;&#9;&#9;// get the palette ; I don't care if its primary or secondary, so</P>
<P>&#9;&#9;&#9;/// I don't use the Info.Palette field</P>

<P>&#9;&#9;&#9;Pal = geBitmap_GetPalette(myBM);</P>
<P>&#9;&#9;&#9;assert(Pal);</P>

<P>&#9;&#9;&#9;// I'm only fiddling one entry, so don't bother with a full Lock() UnLock()</P>
<P>&#9;&#9;&#9;//  sequence on the palette</P>

<P>&#9;&#9;&#9;// make palette index zero bright red; we use alpha = 255 for opaque</P>

<P>&#9;&#9;&#9;success = geBitmap_Palette_SetEntryColor(Pal,0,255,0,0,255);</P>
<P>&#9;&#9;&#9;assert(success);</P>

<P>&#9;&#9;&#9;// tell the bitmap system you've changed the palette; this function</P>
<P>&#9;&#9;&#9;//  is smart enough to not do unecessary copies or whatever.</P>

<P>&#9;&#9;&#9;success = geBitmap_SetPalette(myBM,Pal);</P>
<P>&#9;&#9;&#9;assert(success);</P>
<P>&#9;&#9;}</P>

<P>&#9;}</P>
<P>&#9;else</P>
<P>&#9;{</P>
<P>&#9;&#9;// otherwise, treat black as transparent, in whatever format I have</P>

<P>&#9;&#9;success = geBitmap_SetColorKey(myBM,GE_TRUE,gePixelFormat_ComposePixel(Info.Format,0,0,0,0));</P>
<P>&#9;&#9;assert(success);</P>
<P>&#9;}&#9;</P>

<P>&#9;// note that I did NOT use SetFormat.  SetFormat may do a conversion, and since the original</P>
<P>&#9;//&#9;bitmap was created without colorkey, it would have been converted to a new format but</P>
<P>&#9;//&#9;kept its property of having no colorkey!</P>
<P>&#9;// (SetFormat will fiddle the bits and whatever way necessary to keep bitmaps as visually similar</P>
<P>&#9;//&#9;&#9;as possible)</P>

<P>&#9;// I want to fiddle the fast format in 565 later, so cue the bitmap to try to give me that format.</P>

<P>&#9;success = geBitmap_SetPreferredFormat(myBM,GE_PIXELFORMAT_16BIT_565_RGB);</P>
<P>&#9;assert(success);</P>

<P>&#9;// Add it to the engine so it can be used for drawing.</P>

<P>&#9;success = geEngine_AddBitmap(myEngine,myBM);</P>
<P>&#9;assert(success);</P>
<P>}</P>

<P>void Shutdown(void)</P>
<P>{</P>
<P>geBoolean WasDestroyed;</P>

<P>&#9;assert(myBM);</P>
<P>&#9;</P>
<P>&#9;// clean up</P>

<P>&#9;geEngine_RemoveBitmap(myEngine,myBM);</P>

<P>&#9;WasDestroyed = geBitmap_Destroy(&amp;myBM);</P>

<P>&#9;// someone else might have done _CreateRef on our bitmap,</P>
<P>&#9;//  so we can't be sure it's actually destroyed.</P>
<P>&#9;// this code is still ready to be run again with a new call to Init()</P>

<P>&#9;//assert(WasDestroyed);</P>

<P>&#9;myBM = NULL;</P>
<P>&#9;myEngine = NULL;</P>
<P>}</P>

<P>void Draw(void)</P>
<P>{</P>
<P>geBitmap * Lock;</P>
<P>geBoolean success;</P>
<P>geBitmap_Info Info;</P>
<P>uint16 *bits,*bptr;</P>
<P>int x,y;</P>

<P>&#9;// lets fiddle the bits.</P>
<P>&#9;// we need to lock the bitmap for write.</P>
<P>&#9;//&#9;LockForWrite is an exclusive lock, unlike LockForRead which is non-blocking</P>
<P>&#9;// request our favorite format, and only lock Mip 0 (the full size bitmap)</P>

<P>&#9;success = geBitmap_LockForWriteFormat(myBM,&amp;Lock,0,0,GE_PIXELFORMAT_16BIT_565_RGB);</P>
<P>&#9;if ( ! success )</P>
<P>&#9;{</P>
<P>&#9;&#9;// well, we tried to be nice; if we were very polite, we would do a LockForWrite</P>
<P>&#9;&#9;// here, and try to fiddle the bits in whatever format we got; However, we aren't</P>
<P>&#9;&#9;// that polite, so we just do a _SetFormat</P>
<P>&#9;&#9;//</P>
<P>&#9;&#9;// note that we are destroying the original bitmap by changing its format</P>
<P>&#9;&#9;// we should only do this if we are going to draw into the bitmap</P>

<P>&#9;&#9;success = geBitmap_SetFormat(myBM,GE_PIXELFORMAT_16BIT_565_RGB,GE_TRUE,0,NULL);</P>
<P>&#9;&#9;assert(success);</P>

<P>&#9;&#9;// now we should be able to get the bits we want, *but* they may not be the</P>
<P>&#9;&#9;// primary (fast) format; oh well, it's the best we can do...</P>
<P>&#9;&#9;// (if you must have the fastest bits, then use only _LockForWrite, never LockForWriteFormat,</P>
<P>&#9;&#9;// which might have to do a conversion)</P>

<P>&#9;&#9;success = geBitmap_LockForWriteFormat(myBM,&amp;Lock,0,0,GE_PIXELFORMAT_16BIT_565_RGB);</P>
<P>&#9;&#9;assert(success);</P>
<P>&#9;}</P>

<P>&#9;// now Lock is our bitmap in 565</P>
<P>&#9;// we do a GetInfo because the Lock's info could be different than</P>
<P>&#9;//&#9;the original bitmap's (particularly the Palette &amp; the Stride)</P>

<P>&#9;success = geBitmap_GetInfo(Lock,&amp;Info,NULL);</P>
<P>&#9;assert(success);</P>

<P>&#9;// you can only call _GetBits on a locked bitmap</P>

<P>&#9;bits = geBitmap_GetBits(Lock);</P>
<P>&#9;assert( bits );</P>

<P>&#9;bptr = bits;</P>
<P>&#9;for(y=0; y &lt; Info.Height; y++)</P>
<P>&#9;{</P>
<P>&#9;&#9;for(x=0; x &lt; Info.Width; x++)</P>
<P>&#9;&#9;{</P>
<P>&#9;&#9;uint16 R,G,B;</P>
<P>&#9;&#9;&#9;// make a silly 565 gradient</P>
<P>&#9;&#9;&#9;R = x &amp; 0x1F;</P>
<P>&#9;&#9;&#9;G = x &amp; 0x3F;</P>
<P>&#9;&#9;&#9;B = y &amp; 0x1F;</P>

<P>&#9;&#9;&#9;*bptr++ = (R&lt;&lt;11) + (G&lt;&lt;5) + B;</P>
<P>&#9;&#9;}</P>

<P>&#9;&#9;// note that bptr is a word pointer, and Stride is in pixels :</P>

<P>&#9;&#9;bptr += Info.Stride -  Info.Width;</P>
<P>&#9;}</P>
<P>&#9;bits = bptr = NULL;</P>

<P>&#9;// you call Unlock on all the mips you locked - not on the original bitmap!</P>

<P>&#9;success = geBitmap_UnLock(Lock);</P>
<P>&#9;assert(success);</P>

<P>&#9;// now, we only fiddled the full-size Mip, and there might be more,</P>
<P>&#9;//  so lets percolate the changes into the smaller mips:</P>

<P>&#9;success = geBitmap_RefreshMips(myBM);</P>
<P>&#9;assert(success);</P>

<P>&#9;// a null rect means use the whole bitmap;</P>
<P>&#9;// Engine_DrawBitmap blits a 2d decal to the framebuffer (fast)</P>

<P>&#9;success = geEngine_DrawBitmap(myEngine,myBM,NULL,0,0);</P>
<P>&#9;assert(success);</P>

<P>}</P>

<P>void DrawPolite(void)</P>
<P>{</P>
<P>geBitmap * Lock;</P>
<P>geBoolean success;</P>
<P>geBitmap_Info Info;</P>
<P>void *bits;</P>
<P>int x,y;</P>

<P>&#9;// this function does the same thing as Draw() , but is more polite</P>
<P>&#9;// lock in the fastest format (whatever it is)</P>
<P>&#9;// because we did SetPreferred, this should be 565_RGB, but might not be</P>

<P>&#9;success = geBitmap_LockForWrite(myBM,&amp;Lock,0,0);</P>
<P>&#9;assert(success);</P>

<P>&#9;success = geBitmap_GetInfo(Lock,&amp;Info,NULL);</P>
<P>&#9;assert(success);</P>

<P>&#9;bits = geBitmap_GetBits(Lock);</P>
<P>&#9;assert( bits );</P>

<P>&#9;if ( Info.Format == GE_PIXELFORMAT_16BIT_565_RGB )</P>
<P>&#9;{</P>
<P>&#9;uint16 *wptr;</P>

<P>&#9;&#9;// our favorite format</P>

<P>&#9;&#9;wptr = bits;</P>
<P>&#9;&#9;for(y=0; y &lt; Info.Height; y++)</P>
<P>&#9;&#9;{</P>
<P>&#9;&#9;&#9;for(x=0; x &lt; Info.Width; x++)</P>
<P>&#9;&#9;&#9;{</P>
<P>&#9;&#9;&#9;uint16 R,G,B;</P>
<P>&#9;&#9;&#9;&#9;// make a silly 565 gradient</P>
<P>&#9;&#9;&#9;&#9;R = x &amp; 0x1F;</P>
<P>&#9;&#9;&#9;&#9;G = x &amp; 0x3F;</P>
<P>&#9;&#9;&#9;&#9;B = y &amp; 0x1F;</P>

<P>&#9;&#9;&#9;&#9;*wptr++ = (R&lt;&lt;11) + (G&lt;&lt;5) + B;</P>
<P>&#9;&#9;&#9;}</P>
<P>&#9;&#9;&#9;wptr += Info.Stride -  Info.Width;</P>
<P>&#9;&#9;}</P>
<P>&#9;}</P>
<P>&#9;else</P>
<P>&#9;{</P>
<P>&#9;uint8 * bptr;</P>

<P>&#9;&#9;// oh well, do our best</P>
<P>&#9;&#9;// bitmaps must have had a good reason to not give us the format we preferred,</P>

<P>&#9;&#9;bptr = bits;</P>
<P>&#9;&#9;for(y=0; y &lt; Info.Height; y++)</P>
<P>&#9;&#9;{</P>
<P>&#9;&#9;&#9;for(x=0; x &lt; Info.Width; x++)</P>
<P>&#9;&#9;&#9;{</P>
<P>&#9;&#9;&#9;uint32 R,G,B;</P>

<P>&#9;&#9;&#9;&#9;// put a color in any format</P>

<P>&#9;&#9;&#9;&#9;R = (x &amp; 0x1F)&lt;&lt;3;</P>
<P>&#9;&#9;&#9;&#9;G = (x &amp; 0x3F)&lt;&lt;2;</P>
<P>&#9;&#9;&#9;&#9;B = (y &amp; 0x1F)&lt;&lt;3;</P>

<P>&#9;&#9;&#9;&#9;// we use alpha of 255 for opaque</P>

<P>&#9;&#9;&#9;&#9;gePixelFormat_PutColor(Info.Format,&amp;bptr,R,G,B,255);</P>
<P>&#9;&#9;&#9;}</P>

<P>&#9;&#9;&#9;bptr += (Info.Stride -  Info.Width) * gePixelFormat_BytesPerPel(Info.Format);</P>
<P>&#9;&#9;}</P>
<P>&#9;}</P>
<P>&#9;bits = NULL;</P>

<P>&#9;// same as before:</P>

<P>&#9;success = geBitmap_UnLock(Lock);</P>
<P>&#9;assert(success);</P>

<P>&#9;success = geBitmap_RefreshMips(myBM);</P>
<P>&#9;assert(success);</P>

<P>&#9;success = geEngine_DrawBitmap(myEngine,myBM,NULL,0,0);</P>
<P>&#9;assert(success);</P>

<P>}</P>

<P>// end tutorial on the Bitmap system</P>
<P>//-----------------------------------------------------------------------------</P>
<P>// }</P>

<P>/***********************************************************************************/</P>

<P>#endif</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069970">bitmap_blitdata.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>#ifndef BITMAP_BLITDATA_H</P>
<P>#define BITMAP_BLITDATA_H</P>

<P>#ifndef BITMAP_PRIVATE_H</P>
<P>Intentional Error : bitmap_blidata only allowed in bitmap internals!</P>
<P>#endif</P>
<P>/****************************************************************************************/</P>
<P>/*  Bitmap_BlitData.h                                                                   */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description:  The Bitmap_BlitData function                                          */</P>
<P>/*&#9;&#9;&#9;&#9;&#9;Does all format conversions&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>&nbsp;</P>
<P>extern geBoolean geBitmap_BlitData(</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geBitmap_Info * SrcInfo,const void *SrcData,const geBitmap *SrcBmp,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  geBitmap_Info * DstInfo,&#9;&#9;void *DstData,const geBitmap *DstBmp,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int SizeX,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int SizeY);</P>

<P>#endif //BITMAP_BLITDATA_H</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069971">bitmap_gamma.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>#ifndef BITMAP_GAMMA_H</P>
<P>#define BITMAP_GAMMA_H</P>

<P>#ifndef BITMAP_PRIVATE_H</P>
<P>Intentional Error : bitmap_blidata only allowed in bitmap internals!</P>
<P>#endif</P>

<P>/****************************************************************************************/</P>
<P>/*  Bitmap_Gamma.h                                                                      */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description:  The Bitmap_Gamma_Apply function                                       */</P>
<P>/*&#9;&#9;&#9;&#9;&#9;Fast Gamma correction routines for various pixel formats&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>&nbsp;</P>
<P>extern geBoolean geBitmap_Gamma_Apply(geBitmap * Bitmap,geBoolean Invert);</P>

<P>#endif //BITMAP_GAMMA_H</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069972">pixelformat.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>#ifndef&#9;PIXELFORMAT_H</P>
<P>#define&#9;PIXELFORMAT_H</P>

<P>/****************************************************************************************/</P>
<P>/*  PixelFormat.h                                                                       */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description:  The abstract Pixel primitives                                         */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#include "basetype.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef enum&#9;&#9;// all supported formats (including shifts)</P>
<P>{</P>
<P>&#9;GE_PIXELFORMAT_NO_DATA = 0,</P>
<P>&#9;GE_PIXELFORMAT_8BIT,&#9;&#9;&#9;&#9;// PAL</P>
<P>&#9;GE_PIXELFORMAT_8BIT_GRAY,&#9;&#9;// no palette (intensity from bit value)</P>
<P>&#9;GE_PIXELFORMAT_16BIT_555_RGB,</P>
<P>&#9;GE_PIXELFORMAT_16BIT_555_BGR,</P>
<P>&#9;GE_PIXELFORMAT_16BIT_565_RGB,&#9;// #5</P>
<P>&#9;GE_PIXELFORMAT_16BIT_565_BGR, </P>
<P>&#9;GE_PIXELFORMAT_16BIT_4444_ARGB, // #7</P>
<P>&#9;GE_PIXELFORMAT_16BIT_1555_ARGB, </P>
<P>&#9;GE_PIXELFORMAT_24BIT_RGB,&#9;&#9;// #9</P>
<P>&#9;GE_PIXELFORMAT_24BIT_BGR,</P>
<P>&#9;GE_PIXELFORMAT_24BIT_YUV,&#9;&#9;// * see note below</P>
<P>&#9;GE_PIXELFORMAT_32BIT_RGBX, </P>
<P>&#9;GE_PIXELFORMAT_32BIT_XRGB, </P>
<P>&#9;GE_PIXELFORMAT_32BIT_BGRX, </P>
<P>&#9;GE_PIXELFORMAT_32BIT_XBGR,</P>
<P>&#9;GE_PIXELFORMAT_32BIT_RGBA, </P>
<P>&#9;GE_PIXELFORMAT_32BIT_ARGB,&#9;&#9;// #17</P>
<P>&#9;GE_PIXELFORMAT_32BIT_BGRA, </P>
<P>&#9;GE_PIXELFORMAT_32BIT_ABGR,</P>
<P>&#9;</P>
<P>&#9;GE_PIXELFORMAT_WAVELET,&#9;&#9;&#9;// #20 , Wavelet Compression</P>

<P>&#9;GE_PIXELFORMAT_COUNT</P>
<P>} gePixelFormat;</P>
<P>&#9;</P>
<P>/******</P>

<P>there's something wacked out about these format names :</P>

<P>&#9;for 16 bit &amp; 32 bit , the _RGB or _BGR refers to their order</P>
<P>&#9;&#9;*in the word or dword* ; since we're on intel, this means</P>
<P>&#9;&#9;the bytes in the data file have the *opposite* order !!</P>
<P>&#9;&#9;(for example the 32 bit _ARGB is actually B,G,R,A in raw bytes)</P>
<P>&#9;for 24 bit , the _RGB or _BGR refers to their order in the</P>
<P>&#9;&#9;actual bytes, so that windows bitmaps actually have</P>
<P>&#9;&#9;_RGB order in a dword !!</P>

<P>* YUV : the pixelformat ops here are identical to those of 24bit_RGB ;</P>
<P>&#9;&#9;this is just a place-keeper to notify you that you should to a YUV_to_RGB conversion</P>

<P>*********/</P>

<P>#define GE_PIXELFORMAT_8BIT_PAL GE_PIXELFORMAT_8BIT</P>

<P>typedef uint32&#9;(*gePixelFormat_Composer   )(int R,int G,int B,int A);</P>
<P>typedef void&#9;(*gePixelFormat_Decomposer )(uint32 Pixel,int *R,int *G,int *B,int *A);</P>

<P>typedef void&#9;(*gePixelFormat_ColorGetter)(uint8 **ppData,int *R,int *G,int *B,int *A);</P>
<P>typedef void&#9;(*gePixelFormat_ColorPutter)(uint8 **ppData,int  R,int  G,int  B,int  A);</P>

<P>typedef uint32&#9;(*gePixelFormat_PixelGetter)(uint8 **ppData);</P>
<P>typedef void&#9;(*gePixelFormat_PixelPutter)(uint8 **ppData,uint32 Pixel);</P>

<P>typedef struct gePixelFormat_Operations</P>
<P>{</P>
<P>&#9;uint32&#9;RMask;</P>
<P>&#9;uint32&#9;GMask;</P>
<P>&#9;uint32&#9;BMask;</P>
<P>&#9;uint32&#9;AMask;</P>

<P>&#9;int&#9;&#9;RShift;</P>
<P>&#9;int&#9;&#9;GShift;</P>
<P>&#9;int&#9;&#9;BShift;</P>
<P>&#9;int&#9;&#9;AShift;</P>

<P>&#9;int&#9;&#9;RAdd;</P>
<P>&#9;int&#9;&#9;GAdd;</P>
<P>&#9;int&#9;&#9;BAdd;</P>
<P>&#9;int&#9;&#9;AAdd;</P>

<P>&#9;int&#9;&#9;&#9;BytesPerPel;</P>
<P>&#9;geBoolean&#9;HasPalette;</P>
<P>&#9;char *&#9;&#9;Description;</P>
<P>&#9;</P>
<P>&#9;gePixelFormat_Composer&#9;&#9;ComposePixel;</P>
<P>&#9;gePixelFormat_Decomposer&#9;DecomposePixel;</P>

<P>&#9;gePixelFormat_ColorGetter&#9;GetColor;</P>
<P>&#9;gePixelFormat_ColorPutter&#9;PutColor;</P>

<P>&#9;gePixelFormat_PixelGetter&#9;GetPixel;</P>
<P>&#9;gePixelFormat_PixelPutter&#9;PutPixel;</P>
<P>} gePixelFormat_Operations;</P>

<P>&#9;// the Masks double as boolean "HaveAlpha" .. etc..</P>

<P>GENESISAPI const gePixelFormat_Operations * GENESISCC gePixelFormat_GetOperations( gePixelFormat Format );</P>

<P>&#9;// quick accessors to _GetOps</P>
<P>GENESISAPI geBoolean&#9;GENESISCC gePixelFormat_IsValid(&#9;&#9;gePixelFormat Format);</P>
<P>GENESISAPI unsigned int GENESISCC gePixelFormat_BytesPerPel(&#9;gePixelFormat Format );</P>
<P>GENESISAPI geBoolean&#9;GENESISCC gePixelFormat_HasPalette(&#9;&#9;gePixelFormat Format );</P>
<P>GENESISAPI geBoolean&#9;GENESISCC gePixelFormat_HasAlpha(&#9;&#9;gePixelFormat Format );</P>
<P>GENESISAPI geBoolean&#9;GENESISCC gePixelFormat_HasGoodAlpha(&#9;gePixelFormat Format ); // more than 1 bit of alpha</P>
<P>GENESISAPI const char * GENESISCC gePixelFormat_Description(&#9;gePixelFormat Format );</P>
<P>GENESISAPI geBoolean&#9;GENESISCC gePixelFormat_IsRaw(&#9;&#9;&#9;gePixelFormat Format );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 'Raw' means pixels can be made with the Compose operations</P>

<P>GENESISAPI uint32&#9;&#9;GENESISCC gePixelFormat_ComposePixel(&#9;gePixelFormat Format,int R,int G,int B,int A);</P>
<P>GENESISAPI void&#9;&#9;&#9;GENESISCC gePixelFormat_DecomposePixel(&#9;gePixelFormat Format,uint32 Pixel,int *R,int *G,int *B,int *A);</P>
<P>&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// these four functions move ppData to the next pixel</P>

<P>GENESISAPI void&#9;&#9;&#9;GENESISCC gePixelFormat_GetColor(gePixelFormat Format,uint8 **ppData,int *R,int *G,int *B,int *A);</P>
<P>GENESISAPI void&#9;&#9;&#9;GENESISCC gePixelFormat_PutColor(gePixelFormat Format,uint8 **ppData,int R,int G,int B,int A);</P>

<P>GENESISAPI uint32&#9;&#9;GENESISCC gePixelFormat_GetPixel(gePixelFormat Format,uint8 **ppData);</P>
<P>GENESISAPI void&#9;&#9;&#9;GENESISCC gePixelFormat_PutPixel(gePixelFormat Format,uint8 **ppData,uint32 Pixel);</P>
<P>&#9;</P>
<P>GENESISAPI uint32&#9;&#9;GENESISCC gePixelFormat_ConvertPixel(gePixelFormat Format,uint32 Pixel,gePixelFormat ToFormat);</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<I><P><A NAME="_Toc454069973">OpenSource/Source/Bitmap/Compression Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>This subdirectory contains routines for compression of bitmap data.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069974">Palcreate.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>#ifndef GE_BRANDO_PALCREATE_H</P>
<P>#define GE_BRANDO_PALCREATE_H</P>

<P>#include "basetype.h"</P>
<P>#include "bitmap.h"</P>

<P>/****************************************************************************************/</P>
<P>/*  PalCreate                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description:  Palette Creation code                                                 */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>extern geBitmap_Palette * createPaletteGood(const geBitmap_Info * Info,const void * Bits);</P>
<P>extern geBitmap_Palette * createPaletteFast(const geBitmap_Info * Info,const void * Bits);</P>

<P>typedef geBitmap_Palette * (*paletteCreater) (const geBitmap_Info * Info,const void * Bits);</P>
<P>extern void setCreatePaletteFunc(paletteCreater func);</P>

<P>extern geBitmap_Palette * createPalette(const geBitmap_Info * Info,const void * Bits);</P>

<P>extern geBitmap_Palette * createPaletteFromBitmap(const geBitmap * Bitmap,geBoolean Optimize);</P>

<P>extern void PalCreate_Start(void);</P>
<P>extern void PalCreate_Stop(void);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069975">palettize.h</A></P>
</B></FONT><FONT FACE="Arial" SIZE=2><P>#ifndef GE_BRANDO_PALETTIZE_H</P>
<P>#define GE_BRANDO_PALETTIZE_H</P>

<P>/****************************************************************************************/</P>
<P>/*  Palettize                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description:  Palettize-ing code                                                    */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#include "basetype.h"</P>
<P>#include "bitmap.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>geBoolean palettizePlane(const&#9;geBitmap_Info * SrcInfo,const&#9;void * SrcBits,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap_Info * DstInfo,&#9;&#9;void * DstBits,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int SizeX,int SizeY);</P>

<P>// you can create a palette with routines in "palcreate.h"</P>

<P>/******* if you want to do your own palettizing : ******/</P>

<P>typedef struct palInfo palInfo;</P>

<P>extern palInfo *&#9;closestPalInit(uint8 * palette);</P>
<P>extern void&#9;&#9;&#9;closestPalFree(palInfo *info);</P>
<P>extern int&#9;&#9;&#9;closestPal(int R,int G,int B,palInfo *pi);</P>

<P>extern void Palettize_Start(void);</P>
<P>extern void Palettize_Stop(void);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069976">paloptimize.h</A></P>
</B></FONT><FONT FACE="Arial" SIZE=2><P>#ifndef GE_PALOPTIMIZE_H</P>
<P>#define GE_PALOPTIMIZE_H</P>

<P>/****************************************************************************************/</P>
<P>/*  PalOptimize                                                                         */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description:  Palette Perfecting code                                               */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#include "basetype.h"</P>
<P>#include "bitmap.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>extern void paletteOptimize(const geBitmap_Info * Info,const void * Bits,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;uint8 *palette,int palEntries,int maxSamples);</P>

<P>&#9;// use maxIterations == 0 or -1 for infinity</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069977">utility.h</A></P>
</B></FONT><FONT FACE="Arial" SIZE=2><P>#ifndef __COMPUTIL_UTILITY_H</P>
<P>#define __COMPUTIL_UTILITY_H</P>

<P>/****************************************************************************************/</P>
<P>/*  Utility.h&#9;&#9;&#9;                                                                */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description:  Macros&#9;&#9;&#9;&#9;                                                */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#include "basetype.h"</P>
<P>#include "ram.h"</P>
<P>#include "errorlog.h"</P>
<P>#include &lt;assert.h&gt;</P>
<P>#include &lt;stdlib.h&gt;</P>
<P>#include &lt;string.h&gt;&#9;// for memcpy,memset</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef unsigned int uint;</P>

<P>/****************************************/</P>

<P>#define BrandoError(str)&#9;geErrorLog_AddString(-1,str,NULL)</P>

<P>#ifndef NULL</P>
<P>#define NULL (0)</P>
<P>#endif</P>

<P>#define sizeofpointer sizeof(void *)</P>

<P>#define PaddedSize(a) (((a)+3) &amp; (~3))</P>

<P>#define IsOdd(a)  ( ((uint32)a)&amp;1 )</P>
<P>#define SignOf(a) (((a) &lt; 0) ? -1 : 1)</P>

<P>#ifndef max</P>
<P>#define max(a,b) ((a)&gt;(b)?(a):(b))</P>
<P>#endif</P>

<P>#ifndef min</P>
<P>#define min(a,b) ((a)&lt;(b)?(a):(b))</P>
<P>#endif</P>

<P>#define minmax(x,lo,hi) ( (x)&lt;(lo)?(lo):( (x)&gt;(hi)?(hi):(x)) )</P>
<P>#define putminmax(x,lo,hi) x = minmax(x,lo,hi)</P>
<P>#define putmin(x,lo) x = min(x,lo)</P>
<P>#define putmax(x,hi) x = max(x,hi)</P>
<P>#define max3(a,b,c) max(max(a,b),c)</P>
<P>#define max4(a,b,c,d) max(a,max3(b,c,d))</P>
<P>#define min3(a,b,c) min(min(a,b),c)</P>
<P>#define min4(a,b,c,d) min(a,min3(b,c,d))</P>

<P>#ifndef mabs</P>
<P>#define mabs(i) ((i) &lt; 0 ? -(i) : (i))</P>
<P>#endif</P>

<P>#define isinrange(x,lo,hi)&#9;( (x) &gt;= (lo) &amp;&amp; (x) &lt;= (hi) )</P>

<P>#define getuint32(bptr) ( ((((uint8 *)(bptr))[0])&lt;&lt;24) + (((uint8 *)(bptr))[1]&lt;&lt;16) + (((uint8 *)(bptr))[2]&lt;&lt;8) + (((uint8 *)(bptr))[3]) )</P>
<P>#define getuint16(bptr) ( (((uint8 *)(bptr))[0]&lt;&lt;8) + (((uint8 *)(bptr))[1]) )</P>

<P>/****************************************/</P>

<P>#ifndef strofval</P>
<P>#define strofval(x)&#9;(#x)</P>
<P>#endif</P>

<P>#ifndef new</P>
<P>#define new(type)&#9;&#9;geRam_AllocateClear(sizeof(type))</P>
<P>#endif</P>

<P>#ifndef destroy</P>
<P>#define destroy(mem)&#9;do { if ( mem ) { geRam_Free(mem); (mem) = NULL; } } while(0)</P>
<P>#endif</P>

<P>#ifndef newarray</P>
<P>#define newarray(type,num)&#9;geRam_AllocateClear((num)*sizeof(type))</P>
<P>#endif</P>

<P>#ifndef memclear</P>
<P>#define memclear(mem,size)&#9;memset(mem,0,size);</P>
<P>#endif</P>

<P>/****************************************/</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif // __COMPUTIL_UTILITY_H</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069978">yuv.h</A></P>
</B></FONT><FONT FACE="Arial" SIZE=2><P>#ifndef GE_BRANDO_YUV_H</P>
<P>#define GE_BRANDO_YUV_H</P>

<P>/****************************************************************************************/</P>
<P>/*  Yuv                                                                                 */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description:  YUV &lt;-&gt; RGB code                                                      */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#include "basetype.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>extern void RGBb_to_YUVb(const uint8 *RGB,uint8 *YUV);</P>
<P>extern void YUVb_to_RGBb(const uint8 *YUV,uint8 *RGB);</P>
<P>extern void RGBb_to_YUVb_line(const uint8 *RGB,uint8 *YUV,int array);</P>
<P>extern void YUVb_to_RGBb_line(const uint8 *YUV,uint8 *RGB,int array);</P>

<P>extern void RGBb_to_YUVi(const uint8 *RGB,int *Y,int *U,int *V);</P>
<P>extern void YUVi_to_RGBb(int y,int u,int v,uint8 *RGB);</P>
<P>extern void RGBi_to_YUVi(int R,int G,int B,int *Y,int *U,int *V);</P>
<P>extern void YUVi_to_RGBi(int y,int u,int v,int *R,int *G,int *B);</P>

<P>extern void YUVi_to_RGBi_line(int *line1,int *line2,int *line3,int len);</P>
<P>extern void YUVi_to_BGRb_line(int *line1,int *line2,int *line3,uint8 * bline,int len);</P>

<P>/**************************************************************/</P>

<P>#define YUV_SHIFT &#9;14</P>
<P>#define YUV_HALF&#9;(1&lt;&lt;(YUV_SHIFT-1))</P>
<P>#define YUV_ONE&#9;&#9;(1&lt;&lt;YUV_SHIFT)</P>
<P>#define Y_R   ((int)( 0.29900 * YUV_ONE ))</P>
<P>#define Y_G   ((int)( 0.58700 * YUV_ONE ))</P>
<P>#define Y_B   ((int)( 0.11400 * YUV_ONE ))</P>
<P>#define U_R   ((int)(-0.16874 * YUV_ONE ))</P>
<P>#define U_G   ((int)(-0.33126 * YUV_ONE ))</P>
<P>#define U_B   ((int)( 0.50000 * YUV_ONE ))</P>
<P>#define V_R   ((int)(-0.50000 * YUV_ONE ))&#9;// ** important sign change of 'V' from jpeg default</P>
<P>#define V_G   ((int)( 0.41869 * YUV_ONE ))</P>
<P>#define V_B   ((int)( 0.08131 * YUV_ONE ))</P>
<P>#define R_Y   (    &#9;&#9;&#9;&#9;YUV_ONE )       </P>
<P>#define R_U   (0)</P>
<P>#define R_V   ((int)(-1.40200 * YUV_ONE ))</P>
<P>#define G_Y   (    &#9;&#9;&#9;&#9;YUV_ONE )       </P>
<P>#define G_U   ((int)(-0.34414 * YUV_ONE ))</P>
<P>#define G_V   ((int)( 0.71414 * YUV_ONE ))</P>
<P>#define B_Y   (     &#9;&#9;&#9;YUV_ONE )       </P>
<P>#define B_U   ((int)( 1.77200 * YUV_ONE ))</P>
<P>#define B_V   (0)       </P>

<P>#define Y_RGB(R,G,B) (( Y_R * (R) + Y_G * (G) + Y_B * (B) + YUV_HALF ) &gt;&gt; YUV_SHIFT)</P>
<P>#define U_RGB(R,G,B) (( U_R * (R) + U_G * (G) + U_B * (B) + YUV_HALF ) &gt;&gt; YUV_SHIFT)</P>
<P>#define V_RGB(R,G,B) (( V_R * (R) + V_G * (G) + V_B * (B) + YUV_HALF ) &gt;&gt; YUV_SHIFT)</P>
<P>#define R_YUV(Y,U,V) (( R_Y * (Y) + R_U * (U) + R_V * (V) + YUV_HALF ) &gt;&gt; YUV_SHIFT)</P>
<P>#define G_YUV(Y,U,V) (( G_Y * (Y) + G_U * (U) + G_V * (V) + YUV_HALF ) &gt;&gt; YUV_SHIFT)</P>
<P>#define B_YUV(Y,U,V) (( B_Y * (Y) + B_U * (U) + B_V * (V) + YUV_HALF ) &gt;&gt; YUV_SHIFT)</P>

<P>#define RGB_to_YUV_macro(R,G,B,Y,U,V) \\</P>
<P>do { Y = Y_RGB(R,G,B); U = U_RGB(R,G,B) + 127; V = V_RGB(R,G,B) + 127; } while(0)</P>

<P>#define YUV_to_RGB_macro(Y,U,V,R,G,B) \\</P>
<P>do {&#9;R = R_YUV(Y,(U)-127,(V)-127); G = G_YUV(Y,(U)-127,(V)-127); B = B_YUV(Y,(U)-127,(V)-127); \\</P>
<P>&#9;&#9;R = minmax(R,0,255); G = minmax(G,0,255); B = minmax(B,0,255); } while(0)</P>

<P>/**************************************************************/</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069979">OpenSource/Source/Engine Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>This subdirectory contains the main engine routines.  It's subdirectories contain the individual drivers.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069980">Bitmaplist.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  BitmapList.h                                                                        */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description: Maintains a pool of bitmap pointers.                                   */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef BITMAPLIST_H</P>
<P>#define BITMAPLIST_H</P>

<P>#include "GeTypes.h"</P>
<P>#include "DCommon.h"</P>
<P>#include "Bitmap.h"</P>

<P>typedef struct BitmapList&#9;&#9;BitmapList;</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>BitmapList *BitmapList_Create(void);</P>
<P>geBoolean BitmapList_Destroy(BitmapList *pList);</P>

<P>geBoolean BitmapList_SetGamma(BitmapList *pList, geFloat Gamma);</P>

<P>geBoolean BitmapList_AttachAll(BitmapList *pList, DRV_Driver *Drivera, geFloat Gamma);</P>
<P>geBoolean BitmapList_DetachAll(BitmapList *pList);</P>

<P>&#9;// _Add &amp; _Remove do NOT return Ok/NOk&#9;</P>
<P>geBoolean BitmapList_Add(BitmapList *pList, geBitmap *Bitmap);&#9;// returns Was It New ?</P>
<P>geBoolean BitmapList_Remove(BitmapList *pList,geBitmap *Bitmap);// returns Was It Removed ?</P>
<P>&#9;// _Add &amp; _Remove also do not do any Attach or Detach</P>

<P>geBoolean BitmapList_Has(BitmapList *pList, geBitmap *Bitmap);</P>

<P>#ifndef NDEBUG</P>
<P>int&#9;&#9;&#9;BitmapList_CountMembers(BitmapList *pList);</P>
<P>int&#9;&#9;&#9;BitmapList_CountMembersAttached(BitmapList *pList);</P>
<P>#endif</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069981">engine.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Engine.h                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom/John Pollard                                                  */</P>
<P>/*  Description: Maintains the driver interface, as well as the bitmaps attached&#9;&#9;*/</P>
<P>/*&#9;&#9;&#9;&#9;&#9;to the driver.&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*/</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_ENGINE_H</P>
<P>#define GE_ENGINE_H</P>

<P>#include "Genesis.h"</P>
<P>#include "System.h"</P>
<P>#include "world.h"</P>
<P>#include "bitmap.h"</P>
<P>#include "BitmapList.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//-------------------------------------------------</P>
<P>// fake out windows include</P>
<P>//-------------------------------------------------</P>
<P>#ifndef WINVER // if you want windows, you must include it first!</P>
<P>#ifdef STRICT</P>
<P>typedef struct HINSTANCE__ * HINSTANCE;</P>
<P>#else // STRICT</P>
<P>typedef void * HINSTANCE;</P>
<P>#endif // STRICT</P>
<P>#endif</P>

<P>//-------------------------------------------------</P>
<P>// Engine Functions</P>
<P>//-------------------------------------------------</P>

<P>//-------- engine world list funcs</P>
<P>GENESISAPI geBoolean geEngine_AddWorld(geEngine *Engine, geWorld *World);</P>
<P>GENESISAPI geBoolean geEngine_RemoveWorld(geEngine *Engine, geWorld *World);</P>
<P>geBoolean geEngine_RemoveAllWorlds(geEngine *Engine);</P>
<P>geBoolean geEngine_HasWorld(const geEngine *Engine, const geWorld *World);</P>
<P>void geEngine_SetAllWorldChangedFlag(geEngine *Engine, geBoolean Flag);</P>

<P>//-------- engine attach/detach thandle funcs</P>

<P>// call updategamma when drivers change</P>
<P>GENESISAPI geBoolean geEngine_SetGamma(geEngine *Engine, float Gamma);</P>
<P>GENESISAPI geBoolean geEngine_GetGamma(geEngine *Engine, float *Gamma);</P>
<P>void geEngine_UpdateGamma(geEngine *Engine);</P>

<P>geBoolean geEngine_BitmapListInit(geEngine *Engine);</P>
<P>geBoolean geEngine_BitmapListShutdown(geEngine *Engine);</P>
<P>geBoolean geEngine_DetachAllWorlds(geEngine *Engine);</P>
<P>geBoolean geEngine_CreateWorldLightmapTHandles(geEngine *Engine, geWorld *World);</P>
<P>geBoolean geEngine_DestroyWorldLightmapTHandles(geEngine *Engine, geWorld *World);</P>
<P>geBoolean geEngine_AttachAllWorlds(geEngine *Engine);</P>
<P>geBoolean geEngine_AttachAll(geEngine *Engine);</P>
<P>geBoolean geEngine_DetachAll(geEngine *Engine);</P>

<P>//-------- the splash screen</P>
<P>geBoolean geEngine_DoSplashScreen(geEngine *Engine, geDriver_Mode *DriverMode);</P>

<P>//-------- engine fonts</P>
<P>geBoolean geEngine_InitFonts(geEngine *Engine);</P>
<P>geBoolean geEngine_ShutdownFonts(geEngine *Engine);</P>

<P>//-------- engine drivers</P>
<P>HINSTANCE geEngine_LoadLibrary( const char * lpLibFileName, const char *DriverDirectory);</P>
<P>geBoolean geEngine_ResetDriver(geEngine *Engine);</P>
<P>GENESISAPI geDriver_System *geEngine_GetDriverSystem(geEngine *Engine);</P>

<P>GENESISAPI geBoolean geEngine_SetDriverAndMode(&#9;geEngine *Engine, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geDriver *Driver, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geDriver_Mode *DriverMode);</P>

<P>//-------- drawing with the engine (Decals &amp; Misc Polys)</P>

<P>GENESISAPI geBoolean GENESISCC geEngine_DrawBitmap(const geEngine *Engine,</P>
<P>&#9;const geBitmap *Bitmap,</P>
<P>&#9;const geRect * Source, uint32 x, uint32 y);</P>

<P>GENESISAPI void GENESISCC geEngine_RenderPoly(const geEngine *Engine, const GE_TLVertex *Points, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;int NumPoints, const geBitmap *Texture, uint32 Flags);</P>

<P>GENESISAPI void GENESISCC geEngine_RenderPolyArray(const geEngine *Engine, const GE_TLVertex ** pPoints, int * pNumPoints, int NumPolys, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geBitmap *Texture, uint32 Flags);</P>

<P>//-------- temporary pre-geBitmap hacks</P>
<P>geBoolean Engine_UploadBitmap(geEngine *Engine, DRV_Bitmap *Bitmap, DRV_Bitmap *ABitmap, geFloat Gamma);</P>
<P>geBoolean Engine_SetupPixelFormats(geEngine *Engine);</P>
<P>geRDriver_THandle * Engine_CreateTHandle(geEngine *Engine,int Width,int Height,int Mips, int EngineTexType);</P>
<P>void Engine_DestroyTHandle(geEngine *Engine,geRDriver_THandle * THandle);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif // GE_ENGINE_H</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069982">system.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  System.h                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Friend of engine.c.  Takes care of some of the driver work.            */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_SYSTEM_H</P>
<P>#define GE_SYSTEM_H</P>

<P>//#define OLD_FONT</P>

<P>#include "ErrorLog.h"</P>
<P>#include "Genesis.h"</P>
<P>#include &lt;windows.h&gt;</P>
<P>#include "dcommon.h"</P>
<P>#include "Camera.h"</P>
<P>#include "PtrTypes.h"</P>

<P>#define&#9;&#9;VectorToSUB(a, b) ( *(((float*)&amp;a) + b) )</P>

<P>#define&#9;&#9;MAX_SUB_DRIVERS&#9;&#9;&#9;&#9;12</P>
<P>#define&#9;&#9;MAX_DRIVER_MODES&#9;&#9;&#9;32</P>
<P>#define&#9;&#9;DRV_STR_SIZE&#9;&#9;&#9;&#9;512</P>
<P>#define&#9;&#9;DRV_MODE_STR_SIZE&#9;&#9;&#9;512</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef enum</P>
<P>{</P>
<P>&#9;FrameState_None = 0,</P>
<P>&#9;FrameState_Begin,</P>
<P>} geEngine_FrameState;</P>

<P>//=====================================================================================</P>
<P>//&#9;Structure defines</P>
<P>//=====================================================================================</P>

<P>#define MAX_CLIENT_STRING_LEN&#9;80</P>
<P>#define MAX_CLIENT_STRINGS&#9;&#9;20</P>

<P>typedef struct </P>
<P>{</P>
<P>&#9;int32&#9;&#9;&#9;x,y;</P>
<P>&#9;char&#9;&#9;&#9;String[MAX_CLIENT_STRING_LEN];</P>
<P>}&#9;Sys_String;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;geBitmap&#9;&#9;*FontBitmap;</P>

<P>&#9;uint32&#9;&#9;&#9;FontLUT1[256];</P>
<P>&#9;Sys_String&#9;&#9;ClientStrings[MAX_CLIENT_STRINGS];</P>
<P>&#9;int32&#9;&#9;&#9;NumStrings;</P>
<P>} Sys_FontInfo;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;int32&#9;&#9;Freq;</P>
<P>} Sys_CPUInfo;</P>

<P>typedef struct geDriver_Mode</P>
<P>{</P>
<P>&#9;int32&#9;&#9;&#9;Id;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Driver assigned mode id</P>
<P>&#9;char&#9;&#9;&#9;Name[DRV_MODE_STR_SIZE];&#9;&#9;// Driver assigned mode name</P>
<P>&#9;int32&#9;&#9;&#9;Width;&#9;&#9;&#9;&#9;&#9;&#9;// Mode width</P>
<P>&#9;int32&#9;&#9;&#9;Height;&#9;&#9;&#9;&#9;&#9;&#9;// Mode height</P>
<P>} geDriver_Mode;</P>

<P>typedef struct geDriver</P>
<P>{</P>
<P>&#9;int32&#9;&#9;&#9;Id;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Driver assigned Id</P>
<P>&#9;char&#9;&#9;&#9;Name[DRV_STR_SIZE];&#9;&#9;&#9;// Driver assigned name</P>
<P>&#9;char&#9;&#9;&#9;FileName[256];&#9;&#9;&#9;&#9;// FileName of driver</P>

<P>&#9;geDriver_Mode&#9;Modes[MAX_DRIVER_MODES];&#9;// Modes for this driver</P>
<P>&#9;int32&#9;&#9;&#9;NumModes;&#9;&#9;&#9;&#9;&#9;// Num modes for this driver</P>

<P>} geDriver;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;// Info the enuming fills in</P>
<P>&#9;geDriver&#9;&#9;SubDrivers[MAX_SUB_DRIVERS];</P>
<P>&#9;int32&#9;&#9;&#9;NumSubDrivers;</P>
<P>&#9;char&#9;&#9;&#9;*CurFileName;</P>

<P>&#9;//&#9;Data for current driver</P>
<P>&#9;geBoolean&#9;&#9;Active;&#9;&#9;&#9;&#9;// GE_TRUE if a driver and mode has been initialized</P>
<P>&#9;</P>
<P>&#9;HINSTANCE&#9;&#9;DriverHandle;&#9;&#9;// CurrentDriver Handle (for DLL)</P>
<P>&#9;</P>
<P>&#9;geDriver&#9;&#9;*CurDriver;&#9;&#9;&#9;// Current driver</P>
<P>&#9;geDriver_Mode&#9;*CurMode;&#9;&#9;&#9;// Current mode</P>
<P>&#9;DRV_Driver&#9;&#9;*RDriver;&#9;&#9;&#9;// Current driver function hook</P>
<P>} Sys_DriverInfo;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;int32&#9;&#9;&#9;TraversedPolys;&#9;&#9;// Total Polys traversed</P>
<P>&#9;int32&#9;&#9;&#9;SentPolys;&#9;&#9;&#9;// Total Polys sent to driver</P>
<P>&#9;int32&#9;&#9;&#9;RenderedPolys;&#9;&#9;// Total Rendered polys reported by driver</P>

<P>&#9;int32&#9;&#9;&#9;NumModels;</P>
<P>&#9;int32&#9;&#9;&#9;NumMirrors;</P>
<P>#ifdef&#9;MESHES</P>
<P>&#9;int32&#9;&#9;&#9;NumMeshes;</P>
<P>#endif</P>
<P>&#9;int32&#9;&#9;&#9;NumActors;</P>
<P>&#9;int32&#9;&#9;&#9;NumDLights;</P>
<P>&#9;int32&#9;&#9;&#9;NumFog;</P>
<P>&#9;int32&#9;&#9;&#9;LMap1;&#9;&#9;&#9;&#9;// Lmaps gone through first pass (reg light)</P>
<P>&#9;int32&#9;&#9;&#9;LMap2;&#9;&#9;&#9;&#9;// LMaps gone through 2nd pass (fog)</P>
<P>} Sys_DebugInfo;</P>

<P>//{} Hack:</P>

<P>#define ENGINE_PF_WORLD&#9;&#9;&#9;(0)</P>
<P>#define ENGINE_PF_LIGHTMAP&#9;&#9;(1)</P>
<P>#define ENGINE_PF_USER&#9;&#9;&#9;(2)</P>
<P>#define ENGINE_PF_USER_ALPHA&#9;(3)</P>
<P>#define ENGINE_PF_DECAL&#9;&#9;&#9;(4)</P>
<P>#define ENGINE_PF_PALETTE&#9;&#9;(5)</P>
<P>#define ENGINE_PF_ALPHA_CHANNEL&#9;(6)</P>
<P>#define ENGINE_PF_COUNT&#9;&#9;&#9;(7)</P>

<P>typedef struct BitmapList BitmapList;</P>

<P>#define ENGINE_MAX_WORLDS&#9;&#9;8</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;geWorld&#9;&#9;*World;</P>
<P>&#9;int32&#9;&#9;RefCount;</P>

<P>} geEngine_WorldList;</P>

<P>// System globals initialized by module it belongs to...</P>
<P>typedef struct geEngine</P>
<P>{</P>
<P>&#9;//&#9;System info</P>
<P>&#9;Sys_DriverInfo&#9;&#9;DriverInfo;&#9;&#9;&#9;// Info about current driver (this should be enumed)</P>
<P>&#9;Sys_CPUInfo&#9;&#9;&#9;CPUInfo;&#9;&#9;&#9;// Info about the Cpu</P>
<P>&#9;Sys_DebugInfo&#9;&#9;DebugInfo;</P>

<P>&#9;LARGE_INTEGER&#9;&#9;CurrentTic;</P>

<P>&#9;Sys_FontInfo&#9;&#9;FontInfo;</P>

<P>&#9;User_Info&#9;&#9;&#9;*UserInfo;&#9;&#9;&#9;// Client loaded resources, etc...</P>

<P>&#9;HWND&#9;&#9;&#9;&#9;hWnd;</P>
<P>&#9;char&#9;&#9;&#9;&#9;AppName[200];</P>

<P>&#9;//&#9;Global LUT's</P>
<P>&#9;int16&#9;&#9;&#9;&#9;WaveTable[20];&#9;&#9;// Global Wave table (for wavy effects, pumping, etc)</P>
<P>&#9;int16&#9;&#9;&#9;&#9;WaveDir[20];</P>

<P>&#9;// Global info that modules need to render world</P>
<P>&#9;//geWorld&#9;&#9;&#9;&#9;*World;&#9;&#9;&#9;&#9;// The global World</P>
<P>&#9;geEngine_WorldList&#9;WorldList[ENGINE_MAX_WORLDS];&#9;&#9;// Current list of worlds renderable by the engine</P>

<P>&#9;int32&#9;&#9;&#9;&#9;NumWorlds;&#9;&#9;&#9;&#9;&#9;&#9;// Number of active worlds in world list</P>
<P>&#9;geWorld&#9;&#9;&#9;&#9;*Worlds[ENGINE_MAX_WORLDS];&#9;&#9;// Linear array of worlds contained in WorldList</P>
<P>&#9;</P>
<P>&#9;// Light module info</P>
<P>&#9;uint8&#9;&#9;&#9;&#9;StyleLUT1[64][256];&#9;// Style intensity table (StyleLUT1[Intensity][Number]);</P>

<P>&#9;geBoolean&#9;&#9;&#9;Changed;&#9;&#9;&#9;// == GE_TRUE if needs to be updated with Driver</P>

<P>&#9;geBoolean&#9;&#9;&#9;DisplayFrameRateCounter; // Whether or not to display the FPS string</P>

<P>&#9;char&#9;&#9;&#9;&#9;*DriverDirectory;&#9;// Path to load driver DLLs from</P>

<P>&#9;BitmapList&#9;&#9;&#9;*AttachedBitmaps;</P>

<P>&#9;geBoolean&#9;&#9;&#9;HasPixelFormat[ENGINE_PF_COUNT];</P>
<P>&#9;geRDriver_PixelFormat PixelFormats[ENGINE_PF_COUNT];</P>

<P>&#9;float&#9;&#9;&#9;&#9;CurrentGamma;</P>
<P>&#9;float&#9;&#9;&#9;&#9;BitmapGamma;</P>

<P>&#9;geEngine_FrameState&#9;FrameState;</P>

<P>} geEngine;</P>

<P>//=====================================================================================</P>
<P>//&#9;Function prototypes</P>
<P>//=====================================================================================</P>

<P>//Engine</P>
<P>geEngine *Sys_EngineCreate(HWND hWnd, const char *AppName, const char *DriverDirectory, uint32 Version);</P>

<P>geBoolean&#9;Sys_ShutdownDriver(geEngine *Engine);</P>

<P>void&#9;&#9;Sys_EngineFree(geEngine *Engine);</P>

<P>#ifdef&#9;MESHES</P>
<P>Mesh_RenderQ *Sys_WorldAddMesh(geWorld *World, Mesh_MeshDef *MeshDef, int32 Flags);</P>
<P>Mesh_MeshDef *Sys_WorldCreateMesh(geWorld *World, const char *BitmapPath, const char *FileName);</P>
<P>void Sys_WorldFreeMesh(geWorld *World, Mesh_MeshDef *MeshDef);</P>
<P>#endif</P>

<P>// Misc system</P>
<P>geBoolean Sys_GetCPUFreq(Sys_CPUInfo *Info);</P>
<P>geBoolean Sys_EnginePrint(geEngine *Engine, int32 x, int32 y, char *String);</P>
<P>geBoolean&#9;Sys_EngineResetDecorators(geEngine *Engine);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069983">OpenSource/Source/Engine/DCommon Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>This subdirectory contains the common driver header file. Its subdirectories contain the individual drivers.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069984">Dcommon.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  DCommon.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Header file for all driver modules.                                    */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef DCOMMON_H</P>
<P>#define DCOMMON_H</P>

<P>//#include &lt;Windows.h&gt;&#9;// {} CB commented out windows</P>
<P>// If you include Windows it MUST be before dcommon!</P>

<P>// FIXME:  What should we do with these?</P>
<P>#include "XForm3d.h"</P>
<P>#include "Vec3d.h"</P>
<P>#include "PixelFormat.h"</P>
<P>#include "geTypes.h"&#9;&#9;// This is a no no</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#pragma pack(push)</P>
<P>#pragma pack(8)</P>

<P>#ifndef WINVER</P>
<P>#ifdef STRICT</P>
<P>typedef struct HWND__ * HWND;</P>
<P>typedef struct HBITMAP__ * HBITMAP;</P>
<P>#else // STRICT</P>
<P>typedef void * HWND;</P>
<P>typedef void * HBITMAP;</P>
<P>#endif // STRICT</P>

<P>#ifndef VOID</P>
<P>#define VOID void</P>
<P>typedef char CHAR;</P>
<P>typedef short SHORT;</P>
<P>typedef long LONG;</P>
<P>#endif</P>

<P>#ifndef BASETYPES</P>
<P>#define BASETYPES</P>
<P>typedef unsigned long ULONG;</P>
<P>typedef ULONG *PULONG;</P>
<P>typedef unsigned short USHORT;</P>
<P>typedef USHORT *PUSHORT;</P>
<P>typedef unsigned char UCHAR;</P>
<P>typedef UCHAR *PUCHAR;</P>
<P>typedef char *PSZ;</P>
<P>#endif  /* !BASETYPES */</P>

<P>typedef unsigned long       DWORD;</P>
<P>typedef int                 geBoolean;</P>
<P>typedef unsigned char       BYTE;</P>
<P>typedef unsigned short      WORD;</P>
<P>typedef float               FLOAT;</P>

<P>typedef struct tagRECT</P>
<P>{</P>
<P>    LONG    left;</P>
<P>    LONG    top;</P>
<P>    LONG    right;</P>
<P>    LONG    bottom;</P>
<P>} RECT;</P>

<P>#endif // WINVER</P>

<P>#define&#9;DRIVERCC _fastcall</P>

<P>#ifndef __cplusplus</P>
<P>&#9;#define DllImport&#9;__declspec( dllimport )</P>
<P>&#9;#define DllExport&#9;__declspec( dllexport )</P>
<P>#else</P>
<P>&#9;#define DllImport&#9;extern "C" __declspec( dllimport )</P>
<P>&#9;#define DllExport&#9;extern "C" __declspec( dllexport )</P>
<P>#endif</P>

<P>#define DRV_VERSION_MAJOR&#9;&#9;100&#9;&#9;&#9;// Genesis 1.0</P>
<P>#define DRV_VERSION_MINOR&#9;&#9;2</P>
<P>#define DRV_VMAJS&#9;&#9;&#9;&#9;"100"</P>
<P>#define DRV_VMINS&#9;&#9;&#9;&#9;"2"</P>

<P>#ifndef US_TYPEDEFS</P>
<P>#define US_TYPEDEFS</P>

<P>&#9;typedef uint8&#9;U8;</P>
<P>&#9;typedef uint16&#9;U16;</P>
<P>&#9;typedef uint32&#9;U32;</P>
<P>&#9;typedef char&#9;C8;</P>
<P>&#9;typedef int8&#9;S8;</P>
<P>&#9;typedef int16&#9;S16;</P>
<P>&#9;typedef int32&#9;S32;</P>
<P>#endif</P>

<P>//===</P>
<P>typedef struct geRDriver_THandle&#9;geRDriver_THandle;</P>

<P>// DriverFormat flags</P>
<P>#define RDRIVER_PF_2D_SHIFT&#9;&#9;&#9;&#9;&#9;(0)&#9;&#9;&#9;// Supports being used as a 2d decal surface</P>
<P>#define RDRIVER_PF_3D_SHIFT&#9;&#9;&#9;&#9;&#9;(1)&#9;&#9;&#9;// Supports being used as a 3d poly surface</P>
<P>#define RDRIVER_PF_LIGHTMAP_SHIFT&#9;&#9;&#9;(2)&#9;&#9;&#9;// Surface is a lightmap surface</P>
<P>#define RDRIVER_PF_PALETTE_SHIFT&#9;&#9;&#9;(3)&#9;&#9;&#9;// Surface is a palette</P>
<P>#define RDRIVER_PF_ALPHA_SHIFT&#9;&#9;&#9;&#9;(4)&#9;&#9;&#9;// Surface is an alpha map</P>
<P>#define RDRIVER_PF_OPTIONAL_SHIFT&#9;&#9;&#9;(16)</P>
<P>#define RDRIVER_PF_HAS_ALPHA_SHIFT&#9;&#9;&#9;(RDRIVER_PF_OPTIONAL_SHIFT + 0)&#9;&#9;// Surface can take an alpha map</P>
<P>#define RDRIVER_PF_CAN_DO_COLORKEY_SHIFT&#9;(RDRIVER_PF_OPTIONAL_SHIFT + 1)&#9;&#9;// Surface supports colorkeying</P>
<P>#define RDRIVER_PF_COMBINE_LIGHTMAP_SHIFT&#9;(RDRIVER_PF_OPTIONAL_SHIFT + 2)&#9;&#9;&#9;// Supports being rendered with a lightmap (3d will be set as well)</P>

<P>#define RDRIVER_PF_2D&#9;&#9;&#9;&#9;&#9;(1&lt;&lt;RDRIVER_PF_2D_SHIFT)&#9;&#9;&#9;&#9;</P>
<P>#define RDRIVER_PF_3D&#9;&#9;&#9;&#9;&#9;(1&lt;&lt;RDRIVER_PF_3D_SHIFT)&#9;&#9;&#9;&#9;</P>
<P>#define RDRIVER_PF_LIGHTMAP&#9;&#9;&#9;&#9;(1&lt;&lt;RDRIVER_PF_LIGHTMAP_SHIFT)&#9;&#9;&#9;</P>
<P>#define RDRIVER_PF_COMBINE_LIGHTMAP&#9;&#9;(1&lt;&lt;RDRIVER_PF_COMBINE_LIGHTMAP_SHIFT)&#9;</P>
<P>#define RDRIVER_PF_PALETTE&#9;&#9;&#9;&#9;(1&lt;&lt;RDRIVER_PF_PALETTE_SHIFT)&#9;&#9;&#9;</P>
<P>#define RDRIVER_PF_ALPHA&#9;&#9;&#9;&#9;(1&lt;&lt;RDRIVER_PF_ALPHA_SHIFT)&#9;&#9;&#9;</P>
<P>#define RDRIVER_PF_CAN_DO_COLORKEY&#9;&#9;(1&lt;&lt;RDRIVER_PF_CAN_DO_COLORKEY_SHIFT)</P>
<P>#define RDRIVER_PF_HAS_ALPHA&#9;&#9;&#9;(1&lt;&lt;RDRIVER_PF_HAS_ALPHA_SHIFT)&#9;&#9;</P>
<P>#define RDRIVER_PF_MAJOR_MASK&#9;&#9;&#9;((1&lt;&lt;RDRIVER_PF_OPTIONAL_SHIFT)-1)</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;gePixelFormat&#9;PixelFormat;</P>
<P>&#9;uint32&#9;&#9;&#9;Flags;&#9;&#9;&#9;&#9;</P>
<P>} geRDriver_PixelFormat;</P>

<P>#define RDRIVER_THANDLE_HAS_COLORKEY&#9;(1&lt;&lt;0)&#9;&#9;// The thandle is using color keying</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;Width;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;Height;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;Stride;</P>
<P>&#9;uint32&#9;&#9;&#9;&#9;&#9;ColorKey;</P>
<P>&#9;uint32&#9;&#9;&#9;&#9;&#9;Flags;</P>
<P>&#9;geRDriver_PixelFormat&#9;PixelFormat;</P>

<P>} geRDriver_THandleInfo;</P>

<P>//===</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;S32&#9;LMapCount[16][4];&#9;&#9;&#9;&#9;// LMap size / MipLevel</P>
<P>} DRV_Debug;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;int32&#9;&#9;CacheFull;</P>
<P>&#9;int32&#9;&#9;CacheRemoved;</P>
<P>&#9;int32&#9;&#9;CacheFlushes;</P>
<P>&#9;int32&#9;&#9;TexMisses;</P>
<P>&#9;int32&#9;&#9;LMapMisses;</P>
<P>} DRV_CacheInfo;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;HWND&#9;&#9;hWnd;</P>
<P>&#9;</P>
<P>&#9;U8&#9;&#9;&#9;*Buffer;</P>

<P>&#9;S32&#9;&#9;&#9;Width;</P>
<P>&#9;S32&#9;&#9;&#9;Height;</P>

<P>&#9;S32&#9;&#9;&#9;PixelPitch;</P>
<P>&#9;S32&#9;&#9;&#9;BytesPerPixel;</P>

<P>&#9;S32&#9;&#9;&#9;R_shift;</P>
<P>&#9;S32&#9;&#9;&#9;G_shift;</P>
<P>&#9;S32&#9;&#9;&#9;B_shift;</P>

<P>&#9;U32&#9;&#9;&#9;R_mask;</P>
<P>&#9;U32&#9;&#9;&#9;G_mask;</P>
<P>&#9;U32&#9;&#9;&#9;B_mask;</P>

<P>&#9;S32&#9;&#9;&#9;R_width;</P>
<P>&#9;S32&#9;&#9;&#9;G_width;</P>
<P>&#9;S32&#9;&#9;&#9;B_width;</P>
<P>} DRV_Window;</P>

<P>typedef struct </P>
<P>{</P>
<P>    U8 r, g, b;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// RGB components for RGB lightmaps</P>
<P>} DRV_RGB;</P>

<P>//===========================================================================================</P>
<P>// FIXME:  Get palette stuff, and bitmap out of dcommon</P>
<P>#define&#9;DRV_PALETTE_ENTRIES&#9;256</P>
<P>typedef&#9;DRV_RGB&#9;DRV_Palette[DRV_PALETTE_ENTRIES];</P>

<P>// Bitmap hook into the drivers (engine uses these explicitly as is)</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;char&#9;Name[32];&#9;&#9;&#9;&#9;&#9;&#9;// Duh, name of bitmap...</P>
<P>&#9;U32&#9;&#9;Flags;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Flags</P>
<P>&#9;S32&#9;&#9;Width;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Width of bitmap</P>
<P>&#9;S32&#9;&#9;Height;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Height of bitmap</P>
<P>&#9;U8&#9;&#9;MipLevels;</P>
<P>&#9;U8&#9;&#9;*BitPtr[4];&#9;&#9;&#9;&#9;&#9;&#9;// Pointer to location of bits (up to 4 miplevels)</P>
<P>&#9;DRV_RGB *Palette;</P>

<P>&#9;// Driver sets these in register functions</P>
<P>&#9;//S32&#9;&#9;Id;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Bitmap handle for hardware...</P>
<P>&#9;geRDriver_THandle&#9;*THandle;</P>
<P>} DRV_Bitmap;</P>
<P>//===========================================================================================</P>

<P>#define LMAP_TYPE_LIGHT&#9;&#9;&#9;0</P>
<P>#define LMAP_TYPE_FOG&#9;&#9;&#9;1</P>

<P>// Lightmap hook into the drivers (Engine uses these exlicitly as is...)</P>
<P>// Lightmap info</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;S16&#9;&#9;&#9;&#9;&#9;Width, Height;&#9;&#9;&#9;&#9;// lightmap width/height / 16 +1</P>
<P>    S32&#9;&#9;&#9;&#9;&#9;MinU, MinV;&#9;&#9;&#9;&#9;&#9;// Min U,V values</P>
<P>    DRV_RGB&#9;&#9;&#9;&#9;*RGBLight[2];&#9;&#9;&#9;&#9;// Pointer to RGB light map data</P>

<P>&#9;S32&#9;&#9;&#9;&#9;&#9;Face;&#9;&#9;&#9;&#9;&#9;&#9;// Face that this map belongs too</P>
<P>&#9;geRDriver_THandle&#9;*THandle;</P>
<P>} DRV_LInfo;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;float&#9;&#9;ShiftU;&#9;&#9;&#9;&#9;&#9;&#9;// How much to shift right before draw</P>
<P>&#9;float&#9;&#9;ShiftV;</P>

<P>&#9;float&#9;&#9;DrawScaleU;&#9;&#9;&#9;&#9;&#9;&#9;// How much to scale right before draw</P>
<P>&#9;float&#9;&#9;DrawScaleV;</P>
<P>} DRV_TexInfo;</P>
<P>    </P>
<P>// Render Flags for ALL render functions</P>
<P>#define DRV_RENDER_ALPHA&#9;&#9;(1&lt;&lt;0)&#9;// Render function should expect alpha set in vertices</P>
<P>#define DRV_RENDER_FLUSH&#9;&#9;(1&lt;&lt;1)&#9;// Render function should gaurentee that this render happens NOW</P>
<P>#define DRV_RENDER_NO_ZMASK&#9;&#9;(1&lt;&lt;2)&#9;// No zbuffering should be performed</P>
<P>#define DRV_RENDER_NO_ZWRITE&#9;(1&lt;&lt;3)&#9;// No z writing will be performed</P>
<P>#define DRV_RENDER_CLAMP_UV&#9;&#9;(1&lt;&lt;4)&#9;// Clamp UV in both directions</P>

<P>//</P>
<P>//  PolyMode flags&#9;(A method to override how polys are drawn for debugging purposes...)</P>
<P>//</P>
<P>// Put these in the poly flags!!!  They are currently not used right now...</P>
<P>#define DRV_POLYMODE_NORMAL&#9;&#9;1&#9;&#9;&#9;// Draw as is</P>
<P>#define DRV_POLYMODE_GOURAUD&#9;2&#9;&#9;&#9;// Gouraud only</P>
<P>#define DRV_POLYMODE_LINES&#9;&#9;3&#9;&#9;&#9;// Outlines only</P>

<P>&nbsp;</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;float&#9;x,y,z;&#9;&#9;&#9;&#9;&#9;&#9;// float 3d z value</P>
<P>&#9;float&#9;u,v;&#9;&#9;&#9;&#9;&#9;&#9;// float texture coords</P>
<P>&#9;float&#9;r,g,b,a;&#9;&#9;&#9;&#9;&#9;// Color of point, and Alpha</P>
<P>} DRV_TLVertex;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;char&#9;&#9;&#9;&#9;AppName[512];</P>
<P>&#9;S32&#9;&#9;&#9;&#9;&#9;Driver;</P>
<P>&#9;char&#9;&#9;&#9;&#9;DriverName[512];</P>
<P>&#9;S32&#9;&#9;&#9;&#9;&#9;Mode;</P>
<P>&#9;char&#9;&#9;&#9;&#9;ModeName[512];</P>
<P>&#9;S32&#9;&#9;&#9;&#9;&#9;Width;</P>
<P>&#9;S32&#9;&#9;&#9;&#9;&#9;Height;</P>
<P>&#9;HWND&#9;&#9;&#9;&#9;hWnd;</P>
<P>} DRV_DriverHook;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;// Texture info</P>
<P>&#9;geVec3d&#9;&#9;VecU;</P>
<P>&#9;geVec3d&#9;&#9;VecV;</P>
<P>&#9;int32&#9;&#9;TexMinsX;</P>
<P>&#9;int32&#9;&#9;TexMinsY;</P>
<P>&#9;int32&#9;&#9;TexWidth;</P>
<P>&#9;int32&#9;&#9;TexHeight;</P>
<P>&#9;float&#9;&#9;TexShiftX;</P>
<P>&#9;float&#9;&#9;TexShiftY;</P>

<P>&#9;// Camera info</P>
<P>&#9;geXForm3d&#9;CXForm;</P>
<P>&#9;geVec3d&#9;&#9;CPov;</P>

<P>&#9;float&#9;&#9;XCenter;</P>
<P>&#9;float&#9;&#9;YCenter;</P>

<P>&#9;float&#9;&#9;XScale;</P>
<P>&#9;float&#9;&#9;YScale;</P>
<P>&#9;float&#9;&#9;XScaleInv;&#9;&#9;&#9;// 1 / XScale</P>
<P>&#9;float&#9;&#9;YScaleInv;&#9;&#9;&#9;// 1 / YScale;</P>
<P>&#9;float&#9;&#9;ZScale;&#9;&#9;&#9;&#9;// camera z scale</P>

<P>&nbsp;</P>
<P>&#9;geVec3d&#9;&#9;PlaneNormal;&#9;&#9;// Face normal</P>
<P>&#9;float&#9;&#9;PlaneDist;</P>
<P>&#9;geVec3d&#9;&#9;RPlaneNormal;&#9;&#9;// Rotated Face normal</P>
<P>&#9;geVec3d&#9;&#9;Pov;</P>
<P>} GInfo;</P>

<P>// What the driver can support as far as texture mapping is concerned</P>
<P>#define DRV_SUPPORT_ALPHA&#9;&#9;&#9;&#9;&#9;(1&lt;&lt;0)&#9;&#9;// Driver can do alpha blending</P>
<P>#define DRV_SUPPORT_COLORKEY&#9;&#9;&#9;&#9;(1&lt;&lt;1)&#9;&#9;// Driver can do pixel masking</P>
<P>#define DRV_SUPPORT_GAMMA&#9;&#9;&#9;&#9;&#9;(1&lt;&lt;2)&#9;&#9;// Gamma function works with the driver</P>

<P>// A hint to the engine as far as what to turn on and off...</P>
<P>#define DRV_PREFERENCE_NO_MIRRORS&#9;&#9;&#9;(1&lt;&lt;0)&#9;&#9;// Engine should NOT render mirrors</P>
<P>#define DRV_PREFERENCE_SORT_WORLD_FB&#9;&#9;(1&lt;&lt;1)&#9;&#9;// Sort world Front to Back</P>
<P>#define DRV_PREFERENCE_SORT_WORLD_BF&#9;&#9;(1&lt;&lt;2)&#9;&#9;// Sort world Back to Front</P>
<P>#define DRV_PREFERENCE_DRAW_WALPHA_IN_BSP&#9;(1&lt;&lt;3)&#9;&#9;// Draw world alphas in BSP sort</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;U32&#9;&#9;&#9;CanSupportFlags;</P>
<P>&#9;U32&#9;&#9;&#9;PreferenceFlags;</P>
<P>&#9;U32&#9;&#9;&#9;Reserved1;</P>
<P>&#9;U32&#9;&#9;&#9;Reserved2;</P>
<P>} DRV_EngineSettings;</P>

<P>// Enumeration defines</P>
<P>typedef geBoolean DRV_ENUM_MODES_CB( S32 Mode, char *ModeName, S32 Width, S32 Height, void *Context);</P>
<P>typedef geBoolean DRV_ENUM_DRV_CB( S32 Driver, char *DriverName, void *Context);</P>

<P>typedef geBoolean DRIVERCC DRV_ENUM_DRIVER(DRV_ENUM_DRV_CB *Cb, void *Context); </P>
<P>typedef geBoolean DRIVERCC DRV_ENUM_MODES(S32 Driver, char *DriverName, DRV_ENUM_MODES_CB *Cb, void *Context); </P>

<P>typedef geBoolean DRV_ENUM_PFORMAT_CB(geRDriver_PixelFormat *Format, void *Context);</P>
<P>typedef geBoolean DRIVERCC DRV_ENUM_PFORMAT(DRV_ENUM_PFORMAT_CB *Cb, void *Context); </P>

<P>// Create/Destroy/Etc Driver functions</P>
<P>typedef geBoolean DRIVERCC DRV_INIT(DRV_DriverHook *Hook);</P>
<P>typedef geBoolean DRIVERCC DRV_SHUTDOWN(void);</P>
<P>typedef geBoolean DRIVERCC DRV_RESET(void);</P>
<P>typedef geBoolean DRIVERCC DRV_UPDATE_WINDOW(void);</P>
<P>typedef geBoolean DRIVERCC DRV_SET_ACTIVE(geBoolean active);</P>

<P>// Texture surface functions</P>
<P>typedef geRDriver_THandle *DRIVERCC CREATE_TEXTURE(int32 Width, int32 Height, int32 NumMipLevels, const geRDriver_PixelFormat *PixelFormat);</P>
<P>typedef geBoolean DRIVERCC DESTROY_TEXTURE(geRDriver_THandle *THandle);</P>

<P>typedef geBoolean DRIVERCC LOCK_THANDLE(geRDriver_THandle *THandle, int32 MipLevel, void **Data);</P>
<P>typedef geBoolean DRIVERCC UNLOCK_THANDLE(geRDriver_THandle *THandle, int32 MipLevel);</P>

<P>typedef geBoolean DRIVERCC SET_PALETTE(geRDriver_THandle *THandle, geRDriver_THandle *PalHandle);</P>
<P>typedef geRDriver_THandle *DRIVERCC GET_PALETTE(geRDriver_THandle *THandle);</P>

<P>typedef geBoolean DRIVERCC SET_ALPHA(geRDriver_THandle *THandle, geRDriver_THandle *PalHandle);</P>
<P>typedef geRDriver_THandle *DRIVERCC GET_ALPHA(geRDriver_THandle *THandle);</P>

<P>typedef geBoolean DRIVERCC THANDLE_GET_INFO(geRDriver_THandle *THandle, int32 MipLevel, geRDriver_THandleInfo *Info);</P>

<P>// Scene management functions</P>
<P>typedef geBoolean DRIVERCC BEGIN_SCENE(geBoolean Clear, geBoolean ClearZ, RECT *WorldRect);</P>
<P>typedef geBoolean DRIVERCC END_SCENE(void);</P>
<P>typedef geBoolean DRIVERCC BEGIN_WORLD(void);</P>
<P>typedef geBoolean DRIVERCC END_WORLD(void);</P>
<P>typedef geBoolean DRIVERCC BEGIN_MESHES(void);</P>
<P>typedef geBoolean DRIVERCC END_MESHES(void);</P>
<P>typedef geBoolean DRIVERCC BEGIN_MODELS(void);</P>
<P>typedef geBoolean DRIVERCC END_MODELS(void);</P>

<P>// Render functions</P>
<P>typedef geBoolean DRIVERCC RENDER_G_POLY(DRV_TLVertex *Pnts, S32 NumPoints, U32 Flags);</P>
<P>typedef geBoolean DRIVERCC RENDER_W_POLY(DRV_TLVertex *Pnts, S32 NumPoints, geRDriver_THandle *THandle, DRV_TexInfo *TexInfo, DRV_LInfo *LInfo, U32 Flags);</P>
<P>typedef geBoolean DRIVERCC RENDER_MT_POLY(DRV_TLVertex *Pnts, S32 NumPoints, geRDriver_THandle *THandle, U32 Flags);</P>

<P>typedef geBoolean DRIVERCC DRAW_DECAL(geRDriver_THandle *THandle, RECT *SRect, int32 x, int32 y);</P>

<P>typedef geBoolean DRIVERCC SCREEN_SHOT(const char *Name);</P>

<P>typedef geBoolean DRIVERCC SET_GAMMA(float Gamma);</P>
<P>typedef geBoolean DRIVERCC GET_GAMMA(float *Gamma);</P>

<P>typedef void SETUP_LIGHTMAP_CB(DRV_LInfo *LInfo, geBoolean *Dynamic);</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;char&#9;&#9;&#9;&#9;*Name;</P>
<P>&#9;S32&#9;&#9;&#9;&#9;&#9;VersionMajor;</P>
<P>&#9;S32&#9;&#9;&#9;&#9;&#9;VersionMinor;</P>

<P>&#9;// Error handling hooks set by driver</P>
<P>&#9;S32&#9;&#9;&#9;&#9;&#9;LastError;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Last error driver made</P>
<P>&#9;char&#9;&#9;&#9;&#9;*LastErrorStr;&#9;&#9;&#9;&#9;&#9;&#9;// NULL terminated error string</P>
<P>&#9;</P>
<P>&#9;// Enum Modes/Drivers</P>
<P>&#9;DRV_ENUM_DRIVER&#9;&#9;*EnumSubDrivers;</P>
<P>&#9;DRV_ENUM_MODES&#9;&#9;*EnumModes;</P>
<P>&#9;</P>
<P>&#9;DRV_ENUM_PFORMAT&#9;*EnumPixelFormats;</P>

<P>&#9;// Init/DeInit functions</P>
<P>&#9;DRV_INIT&#9;&#9;&#9;&#9;&#9;*Init;</P>
<P>&#9;DRV_SHUTDOWN&#9;&#9;&#9;&#9;*Shutdown;</P>
<P>&#9;DRV_RESET&#9;&#9;&#9;&#9;&#9;*Reset;</P>
<P>&#9;DRV_UPDATE_WINDOW&#9;&#9;&#9;*UpdateWindow;</P>
<P>&#9;DRV_SET_ACTIVE&#9;&#9;&#9;&#9;*SetActive;</P>
<P>&#9;</P>
<P>&#9;// Create/Destroy texture functions</P>
<P>&#9;CREATE_TEXTURE&#9;&#9;*THandle_Create;</P>
<P>&#9;DESTROY_TEXTURE&#9;&#9;*THandle_Destroy;</P>

<P>&#9;// Texture manipulation functions</P>
<P>&#9;LOCK_THANDLE&#9;&#9;*THandle_Lock;</P>
<P>&#9;UNLOCK_THANDLE&#9;&#9;*THandle_UnLock;</P>

<P>&#9;// Palette access functions</P>
<P>&#9;SET_PALETTE&#9;&#9;&#9;*THandle_SetPalette;</P>
<P>&#9;GET_PALETTE&#9;&#9;&#9;*THandle_GetPalette;</P>

<P>&#9;// Palette access functions</P>
<P>&#9;SET_ALPHA&#9;&#9;&#9;*THandle_SetAlpha;</P>
<P>&#9;GET_ALPHA  &#9;&#9;&#9;*THandle_GetAlpha;</P>

<P>&#9;THANDLE_GET_INFO&#9;*THandle_GetInfo;</P>

<P>&#9;// Scene management functions</P>
<P>&#9;BEGIN_SCENE&#9;&#9;&#9;*BeginScene;</P>
<P>&#9;END_SCENE&#9;&#9;&#9;*EndScene;</P>
<P>&#9;BEGIN_WORLD&#9;&#9;&#9;*BeginWorld;</P>
<P>&#9;END_WORLD&#9;&#9;&#9;*EndWorld;</P>
<P>&#9;BEGIN_MESHES&#9;&#9;*BeginMeshes;</P>
<P>&#9;END_MESHES&#9;&#9;&#9;*EndMeshes;</P>
<P>&#9;BEGIN_MODELS&#9;&#9;*BeginModels;</P>
<P>&#9;END_MODELS&#9;&#9;&#9;*EndModels;</P>
<P>&#9;</P>
<P>&#9;// Render functions</P>
<P>&#9;RENDER_G_POLY&#9;&#9;*RenderGouraudPoly;</P>
<P>&#9;RENDER_W_POLY&#9;&#9;*RenderWorldPoly;</P>
<P>&#9;RENDER_MT_POLY&#9;&#9;*RenderMiscTexturePoly;</P>

<P>&#9;//Decal functions</P>
<P>&#9;DRAW_DECAL&#9;&#9;&#9;*DrawDecal;</P>

<P>&#9;S32&#9;&#9;&#9;&#9;&#9;NumWorldPixels;</P>
<P>&#9;S32&#9;&#9;&#9;&#9;&#9;NumWorldSpans;</P>
<P>&#9;S32&#9;&#9;&#9;&#9;&#9;NumRenderedPolys;</P>
<P>&#9;DRV_CacheInfo&#9;&#9;*CacheInfo;</P>

<P>&#9;SCREEN_SHOT&#9;&#9;&#9;*ScreenShot;</P>

<P>&#9;SET_GAMMA&#9;&#9;&#9;*SetGamma;</P>
<P>&#9;GET_GAMMA&#9;&#9;&#9;*GetGamma;</P>
<P>&#9;</P>
<P>&#9;// Driver preferences</P>
<P>&#9;DRV_EngineSettings&#9;*EngineSettings;</P>

<P>&#9;// The engine supplies these for the drivers misc use</P>
<P>&#9;SETUP_LIGHTMAP_CB&#9;*SetupLightmap;</P>

<P>&#9;// Temp hack global</P>
<P>&#9;GInfo&#9;&#9;&#9;&#9;*GlobalInfo;</P>
<P>} DRV_Driver;</P>

<P>typedef geBoolean DRV_Hook(DRV_Driver **Hook);</P>

<P>//</P>
<P>//&#9;Error defines set by the driver.  These will be in the LastError member of DRV_Driver</P>
<P>//&#9;structure.  LastErrorStr will contain a NULL terminated detail error string set by the driver</P>
<P>//</P>
<P>#define DRV_ERROR_NONE&#9;&#9;&#9;&#9;&#9;0&#9;// No error has occured</P>
<P>#define DRV_ERROR_INVALID_PARMS&#9;&#9;&#9;1&#9;// invalid parameters passed</P>
<P>#define DRV_ERROR_NULL_WINDOW&#9;&#9;&#9;2&#9;// Null window supplied</P>
<P>#define DRV_ERROR_INIT_ERROR&#9;&#9;&#9;3&#9;// Error intitializing</P>
<P>#define DRV_ERROR_INVALID_REGISTER_MODE&#9;4&#9;// Invalid register mode</P>
<P>#define DRV_ERROR_NO_MEMORY&#9;&#9;&#9;&#9;5&#9;// Not enough ram</P>
<P>#define DRV_ERROR_MAX_TEXTURES&#9;&#9;&#9;6&#9;// Max texture capacity has been exceeded...</P>
<P>#define DRV_ERROR_GENERIC&#9;&#9;&#9;&#9;7&#9;// Generic error&#9; </P>
<P>#define DRV_ERROR_UNDEFINED&#9;&#9;&#9;&#9;8&#9;// An undefined error has occured</P>
<P>#define DRV_ERROR_INVALID_WINDOW_MODE&#9;9&#9;// Requested window/full not supported</P>

<P>typedef enum</P>
<P>{</P>
<P>&#9;RENDER_NONE,</P>
<P>&#9;RENDER_WORLD,</P>
<P>&#9;RENDER_MESHES,</P>
<P>&#9;RENDER_MODELS</P>
<P>} DRV_RENDER_MODE;</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#pragma pack(pop)</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069985">OpenSource/Source/Engine/D3DDrv Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>This subdirectory contains the routines for the DirectX Direct 3D driver.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069986">D3derr.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  D3D_Err.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: D3D Error code conversions                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef D3D_ERR_H</P>
<P>#define D3D_ERR_H</P>

<P>#include &lt;Windows.h&gt;</P>
<P>#include &lt;DDraw.h&gt;</P>
<P>#include &lt;D3D.h&gt;</P>

<P>//================================================================================</P>
<P>//&#9;Global functions</P>
<P>//================================================================================</P>
<P>char *D3DErrorToString(HRESULT error);</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069987">D3d_fx.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  D3D_Fx.h                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: D3D renderstate wrapper                                                */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef D3D_FX_H</P>
<P>#define D3D_FX_H</P>

<P>#include &lt;Windows.h&gt;</P>
<P>#include &lt;DDraw.h&gt;</P>
<P>#include &lt;D3D.h&gt;</P>

<P>#include "D3D_Main.h"</P>
<P>#include "DCommon.h"</P>

<P>void D3DSetTexHandle(D3DTEXTUREHANDLE TexHandle);</P>
<P>void D3DSetTexture(int32 Stage, LPDIRECT3DTEXTURE2 Texture);</P>
<P>void D3DTexturedPolyOld(void *Pnts, int32 NumPoints);</P>
<P>void D3DTexturedPoly(void *Pnts, int32 NumPoints);</P>

<P>void D3DBilinearFilter(D3DTEXTUREFILTER Min, D3DTEXTUREFILTER Mag);</P>
<P>void D3DBlendEnable(BOOL Enable);</P>

<P>void D3DBlendFunc (D3DBLEND SFunc, D3DBLEND DFunc);</P>

<P>void D3DZWriteEnable (BOOL Enable);</P>
<P>void D3DZFunc (D3DCMPFUNC Func);</P>
<P>void D3DZEnable(BOOL Enable);</P>

<P>void D3DTexWrap(DWORD Stage, BOOL Wrap);</P>

<P>void D3DPolygonMode (D3DFILLMODE Mode);</P>

<P>void D3DViewport (int32 x, int32 y, int32 width, int32 height);</P>
<P>void D3DDepthRange (float zNear, float zFar);</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069988">D3d_main.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  D3D_Main.h                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: DD/D3D wrapper                                                         */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef D3D_MAIN_H</P>
<P>#define D3D_MAIN_H</P>

<P>#include &lt;Windows.h&gt;</P>
<P>#include &lt;DDraw.h&gt;</P>
<P>#include &lt;D3D.h&gt;</P>

<P>#define INITGUID</P>

<P>#include "DCommon.h"</P>

<P>#define MAX_APP_MODES&#9;&#9;&#9;&#9;&#9;50</P>
<P>#define DDMAIN_MAX_D3D_DRIVERS&#9;&#9;&#9;10</P>
<P>#define DDMAIN_MAX_TEXTURE_FORMATS&#9;&#9;128</P>
<P>#define DDMAIN_MAX_SURFACE_FORMATS&#9;&#9;128</P>

<P>#define D3DMAIN_LOG_FILENAME&#9;&#9;&#9;"D3DDrv.Log"</P>

<P>//================================================================================</P>
<P>//&#9;Structure defs</P>
<P>//================================================================================</P>

<P>typedef struct</P>
<P>{</P>
<P>    char&#9;&#9;&#9;&#9;Name[64];&#9;&#9;&#9;&#9;// short name of the driver </P>
<P>    char&#9;&#9;&#9;&#9;About[128];&#9;&#9;&#9;&#9;// short string about the driver </P>
<P>    D3DDEVICEDESC&#9;&#9;Desc;&#9;&#9;&#9;&#9;&#9;// D3DDEVICEDESC for complete information </P>
<P>    GUID&#9;&#9;&#9;&#9;Guid;&#9;&#9;&#9;&#9;&#9;// it's GUID </P>
<P>    BOOL&#9;&#9;&#9;&#9;IsHardware;&#9;&#9;&#9;&#9;// does this driver represent a hardware device? </P>
<P>    BOOL&#9;&#9;&#9;&#9;DoesTextures;&#9;&#9;&#9;// does this driver do texture mapping? </P>
<P>    BOOL&#9;&#9;&#9;&#9;DoesZBuffer;&#9;&#9;&#9;// can this driver use a z-buffer? </P>
<P>    BOOL&#9;&#9;&#9;&#9;CanDoWindow;&#9;&#9;&#9;// can it render to Window's display depth? </P>
<P>&#9;BOOL&#9;&#9;&#9;&#9;DoesTransparency;</P>
<P>&#9;BOOL&#9;&#9;&#9;&#9;DoesAlpha;</P>
<P>&#9;BOOL&#9;&#9;&#9;&#9;DoesClamping;</P>
<P>&#9;BOOL&#9;&#9;&#9;&#9;DoesSrcBlending;</P>
<P>&#9;BOOL&#9;&#9;&#9;&#9;DoesDestBlending;</P>

<P>    WORD&#9;&#9;&#9;&#9;MaxTextureBlendStages;</P>
<P>    WORD&#9;&#9;&#9;&#9;MaxSimultaneousTextures;&#9;</P>
<P>&#9;</P>
<P>&#9;BOOL&#9;&#9;&#9;&#9;CanUse;&#9;&#9;&#9;&#9;&#9;// We can use this driver</P>
<P>} DDMain_D3DDriver;</P>

<P>typedef struct </P>
<P>{</P>
<P>    int32&#9;&#9;&#9;&#9;Width;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// width</P>
<P>    int32&#9;&#9;&#9;&#9;Height;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// height</P>
<P>    int32&#9;&#9;&#9;&#9;Bpp;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// bits per pixel </P>
<P>    BOOL&#9;&#9;&#9;&#9;ThisDriverCanDo;&#9;&#9;&#9;&#9;// == TRUE if d3d driver can render into</P>
<P>} App_Mode;</P>

<P>typedef struct</P>
<P>{</P>
<P>    DDSURFACEDESC2&#9;&#9;ddsd;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// DDSURFACEDESC for complete information </P>
<P>    BOOL&#9;&#9;&#9;&#9;HasOneBitAlpha;&#9;</P>
<P>    BOOL&#9;&#9;&#9;&#9;HasFourBitAlpha;</P>
<P>} DDMain_SurfFormat;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;uint32&#9;&#9;&#9;&#9;R[256];</P>
<P>&#9;uint32&#9;&#9;&#9;&#9;G[256];</P>
<P>&#9;uint32&#9;&#9;&#9;&#9;B[256];</P>
<P>&#9;uint32&#9;&#9;&#9;&#9;A[256];</P>
<P>} RGB_LUT;</P>

<P>// App_Info, used for everything global. </P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;// Window info</P>
<P>&#9;HWND&#9;&#9;&#9;&#9;hWnd;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Handle to parent Window</P>

<P>&#9;DDSURFACEDESC2&#9;&#9;ddsd;</P>

<P>&#9;// Mode that we were in before initializing</P>
<P>&#9;int32&#9;&#9;&#9;&#9;OldWidth;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Old screen width</P>
<P>&#9;int32&#9;&#9;&#9;&#9;OldHeight;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;OldBpp;</P>

<P>&#9;int32&#9;&#9;&#9;&#9;CurrentWidth;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;CurrentHeight;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;CurrentBpp;</P>

<P>&#9;int32&#9;&#9;&#9;&#9;OldWindowWidth;&#9;&#9;&#9;&#9;&#9;&#9;// Old client width</P>
<P>&#9;int32&#9;&#9;&#9;&#9;OldWindowHeight;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;WindowXOffset;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;WindowYOffset;</P>

<P>&#9;RECT&#9;&#9;&#9;&#9;OldWindowRect;</P>
<P>&#9;ULONG&#9;&#9;&#9;&#9;OldGWL_STYLE;</P>

<P>&#9;geBoolean&#9;&#9;&#9;ModeSet;</P>

<P>&#9;char&#9;&#9;&#9;&#9;DDName[2048];&#9;&#9;// Have no idea how big to make this.  Anyone?</P>

<P>&#9;LPDIRECTDRAW4&#9;&#9;lpDD;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// The current initialized DD object</P>
<P>    LPDIRECT3D3&#9;&#9;    lpD3D;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// The current initialized D3D object</P>

<P>    LPDIRECTDRAWSURFACE4&#9;lpFrontBuffer;&#9;&#9;&#9;&#9;&#9;&#9;// front buffer surface </P>
<P>    LPDIRECTDRAWSURFACE4&#9;lpBackBuffer;&#9;&#9;&#9;&#9;&#9;&#9;// back buffer surface </P>
<P>    LPDIRECTDRAWSURFACE4&#9;lpZBuffer;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// z-buffer surface </P>
<P>&#9;LPDIRECTDRAWCLIPPER lpClipper;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Clipper in windowed case</P>
<P>    BOOL&#9;&#9;&#9;&#9;BackBufferInVideo;&#9;&#9;&#9;&#9;&#9;// back buf in video mem? </P>
<P>    BOOL&#9;&#9;&#9;&#9;ZBufferInVideo;&#9;&#9;&#9;&#9;&#9;&#9;// is Z-buf in video mem? </P>
<P>    LPDIRECT3DDEVICE3&#9;lpD3DDevice;&#9;&#9;&#9;&#9;&#9;&#9;// D3D device </P>
<P>    LPDIRECT3DVIEWPORT3&#9;lpD3DViewport;&#9;&#9;&#9;&#9;&#9;&#9;// D3D viewport</P>

<P>&#9;// 2d surface format (for blt'ing to the display)</P>
<P>&#9;DDSURFACEDESC2&#9;&#9;ddSurfFormat;&#9;&#9;&#9;&#9;&#9;&#9;// 555 or 565 surface desc</P>

<P>&#9;// Texture formats (for the D3D device)</P>
<P>&#9;DDSURFACEDESC2&#9;&#9;ddTexFormat;&#9;&#9;&#9;&#9;&#9;&#9;// 555 or 565 surface desc</P>
<P>&#9;DDSURFACEDESC2&#9;&#9;ddFourBitAlphaSurfFormat;&#9;&#9;&#9;// 4444 surface desc</P>
<P>&#9;DDSURFACEDESC2&#9;&#9;ddOneBitAlphaSurfFormat;&#9;&#9;&#9;// 1555 surface desc</P>

<P>&#9;RGB_LUT&#9;&#9;&#9;&#9;Lut1;</P>
<P>&#9;RGB_LUT&#9;&#9;&#9;&#9;Lut2;</P>
<P>&#9;RGB_LUT&#9;&#9;&#9;&#9;Lut3;</P>

<P>&#9;BOOL&#9;&#9;&#9;&#9;IsPrimary;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// </P>
<P>&#9;BOOL&#9;&#9;&#9;&#9;FullScreen;</P>
<P>&#9;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;NumModes;</P>
<P>&#9;App_Mode&#9;&#9;&#9;Modes[MAX_APP_MODES];</P>

<P>&#9;int32&#9;&#9;&#9;&#9;NumDrivers;</P>
<P>&#9;DDMain_D3DDriver&#9;Drivers[DDMAIN_MAX_D3D_DRIVERS];</P>
<P>&#9;int32&#9;&#9;&#9;&#9;CurrentDriver;</P>

<P>&#9;// Surface formats</P>
<P>&#9;int32&#9;&#9;&#9;&#9;NumSurfFormats;&#9;&#9;&#9;&#9;&#9;&#9;// Num 2D texture formats avail (from DD4 object)</P>
<P>    DDMain_SurfFormat&#9;SurfFormats[DDMAIN_MAX_SURFACE_FORMATS];</P>

<P>    // Texture formats</P>
<P>&#9;int32&#9;&#9;&#9;&#9;NumTextureFormats;&#9;&#9;&#9;&#9;&#9;// Num 3D texture formats avail (from device)</P>
<P>    DDMain_SurfFormat&#9;TextureFormats[DDMAIN_MAX_TEXTURE_FORMATS];</P>

<P>&#9;BOOL&#9;&#9;&#9;&#9;LogToFile;</P>
<P>&#9;BOOL&#9;&#9;&#9;&#9;FoundGoodDevice;</P>
<P>&#9;BOOL&#9;&#9;&#9;&#9;CanDoWindow;</P>
<P>&#9;</P>
<P>&#9;BOOL&#9;&#9;&#9;&#9;RenderingIsOK;</P>

<P>&#9;DWORD&#9;&#9;&#9;&#9;VidMemFree;</P>

<P>&#9;float&#9;&#9;&#9;&#9;Gamma;</P>
<P>&#9;BOOL&#9;&#9;&#9;&#9;GammaChanged;</P>

<P>&#9;geBoolean&#9;&#9;&#9;CanDoMultiTexture;</P>

<P>&#9;// DD / D3D Flags</P>
<P>&#9;uint32&#9;&#9;&#9;&#9;Flags;</P>
<P>} App_Info;</P>

<P>// DD enum strcuture.  Used when enuming dd</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;LPDIRECTDRAW4&#9;lpDD;</P>
<P>&#9;char&#9;&#9;&#9;DriverName[256];</P>
<P>&#9;BOOL&#9;&#9;&#9;FoundDD;</P>
<P>} DD_Enum;</P>

<P>//================================================================================</P>
<P>//&#9;Globals</P>
<P>//================================================================================</P>
<P>extern App_Info&#9;AppInfo;&#9;&#9;&#9;&#9;// Our global structure that knows all... (once initialized)</P>

<P>//================================================================================</P>
<P>//&#9;Global functions</P>
<P>//================================================================================</P>
<P>BOOL&#9;&#9;&#9;&#9;D3DMain_InitD3D(HWND hWnd, const char *DriverName, int32 Width, int32 Height);</P>
<P>BOOL&#9;&#9;&#9;&#9;D3DMain_ShutdownD3D(void);</P>
<P>geBoolean&#9;&#9;&#9;D3DMain_Reset(void);</P>
<P>void&#9;&#9;&#9;&#9;D3DMain_Log(LPSTR Str, ... );</P>
<P>BOOL&#9;&#9;&#9;&#9;D3DMain_RestoreAllSurfaces(void);</P>

<P>BOOL&#9;&#9;&#9;&#9;Main_EnumTextureFormats(void);</P>
<P>BOOL&#9;&#9;&#9;&#9;D3DMain_EnumDisplayModes(void);</P>
<P>BOOL&#9;&#9;&#9;&#9;Main_ClearBackBuffer(BOOL Clear, BOOL ClearZ);</P>
<P>BOOL&#9;&#9;&#9;&#9;Main_ShowBackBuffer(void);</P>

<P>LPDIRECTDRAWSURFACE4 Main_CreateSurface(LPDIRECTDRAW4 lpDD, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DWORD dwWidth, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DWORD dwHeight, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;LPDDSURFACEDESC2 lpFormat, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DWORD MemoryFlag);</P>

<P>LPDIRECTDRAWSURFACE4 Main_LoadSurface(&#9;LPDIRECTDRAW4 lpDD, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;WORD dwFormat, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DWORD dwWidth, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DWORD dwHeight, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const void *pixels, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const char *pal, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;LPDDSURFACEDESC2 lpFormat, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DWORD MemoryFlag);</P>

<P>LPDIRECTDRAWSURFACE4 Main_LoadSurface2(&#9;LPDIRECTDRAW4 lpDD, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DWORD dwWidth, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DWORD dwHeight, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const USHORT *Source, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;LPDDSURFACEDESC2 lpFormat, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DWORD MemoryFlag);</P>

<P>BOOL&#9;&#9;&#9;&#9;Main_UpdateSurface(&#9;LPDIRECTDRAWSURFACE4 lpDDS,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;WORD dwFormat, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DWORD dwWidth, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DWORD dwHeight, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const void *pixels, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const char *pal);</P>

<P>BOOL&#9;&#9;&#9;&#9;Main_UpdateSurface2(LPDIRECTDRAWSURFACE4 lpDDS,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DWORD dwWidth, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DWORD dwHeight, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const USHORT *Source);</P>

<P>BOOL&#9;&#9;&#9;&#9;D3DMain_GetSurfaceFormats(void);</P>

<P>BOOL&#9;&#9;&#9;&#9;Main_CheckDD(void);</P>
<P>BOOL&#9;&#9;&#9;&#9;D3DMain_GetTextureMemory(void);</P>
<P>void&#9;&#9;&#9;&#9;Main_BuildRGBGammaTables(float Gamma);</P>

<P>BOOL&#9;&#9;&#9;&#9;D3DMain_GetClientWindowOffset(HWND hWnd);</P>
<P>geBoolean DRIVERCC&#9;D3DMain_UpdateWindow(void);</P>
<P>geBoolean DRIVERCC&#9;D3DMain_SetActive(geBoolean wParam);</P>

<P>BOOL DRIVERCC EnumSubDrivers(DRV_ENUM_DRV_CB *Cb, void *Context);</P>
<P>BOOL DRIVERCC EnumModes(int32 Driver, char *DriverName, DRV_ENUM_MODES_CB *Cb, void *Context);</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069989">D3dcache.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  D3DCache.h                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: D3D cache manager                                                      */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef D3DCache_H</P>
<P>#define D3DCache_H</P>

<P>#include &lt;Windows.h&gt;</P>
<P>#include &lt;DDraw.h&gt;</P>
<P>#include &lt;D3D.H&gt;</P>

<P>#include "BaseType.h"</P>
<P>#include "DDMemMgr.h"&#9;&#9;&#9;</P>

<P>#define&#9;D3DCACHE_MAX_NAME&#9;&#9;&#9;256</P>

<P>typedef struct D3DCache&#9;&#9;&#9;&#9;D3DCache;</P>
<P>typedef struct D3DCache_Type&#9;&#9;D3DCache_Type;</P>
<P>typedef struct D3DCache_Slot&#9;&#9;D3DCache_Slot;</P>

<P>D3DCache&#9;*D3DCache_Create(const char *Name, LPDIRECTDRAW4 lpDD, DDMemMgr_Partition *Partition, geBoolean UseStages);</P>
<P>void&#9;&#9;D3DCache_Destroy(D3DCache *Cache);</P>
<P>geBoolean&#9;D3DCache_IsValid(D3DCache *Cache);</P>
<P>geBoolean&#9;D3DCache_EvictAllSurfaces(D3DCache *Cache);</P>
<P>D3DCache_Type *D3DCache_FindCacheType(D3DCache *Cache, int32 Width, int32 Height, int32 NumMipLevels, int32 Stage, const DDSURFACEDESC2 *ddsd);</P>
<P>D3DCache_Type *D3DCache_InsertCacheType(D3DCache *Cache, int32 Width, int32 Height, int32 NumMipLevels, int32 Stage, const DDSURFACEDESC2 *ddsd);</P>
<P>D3DCache_Type *D3DCache_TypeCreate(D3DCache *Cache, int32 Width, int32 Height, int32 NumMipLevels, int32 Stage, const DDSURFACEDESC2 *ddsd);</P>
<P>void&#9;&#9;D3DCache_TypeDestroy(D3DCache_Type *CacheType);</P>
<P>geBoolean&#9;D3DCache_TypeIsValid(D3DCache_Type *Type);</P>
<P>geBoolean&#9;D3DCache_FreeAllSlots(D3DCache *Cache);</P>
<P>geBoolean&#9;D3DCache_AdjustSlots(D3DCache *Cache, const int32 *MaxTable, geBoolean UsePartition);</P>
<P>geBoolean&#9;D3DCache_SlotIsValid(D3DCache_Slot *Slot);</P>
<P>int32&#9;&#9;D3DCache_SetupSlot(D3DCache *Cache, D3DCache_Slot *Slot, int32 Width, int32 Height, const DDSURFACEDESC2 *SurfDesc, geBoolean UseStage, int32 Stage);</P>
<P>D3DCache_Slot *D3DCache_TypeFindSlot(D3DCache_Type *CacheType);</P>
<P>void&#9;&#9;D3DCache_SlotSetUserData(D3DCache_Slot *Slot, void *UserData);</P>
<P>void&#9;&#9;*D3DCache_SlotGetUserData(D3DCache_Slot *Slot);</P>
<P>void&#9;&#9;D3DCache_SlotSetLRU(D3DCache_Slot *Slot, uint32 LRU);</P>
<P>uint32&#9;&#9;D3DCache_SlotGetLRU(D3DCache_Slot *Slot);</P>
<P>LPDIRECT3DTEXTURE2 D3DCache_SlotGetTexture(D3DCache_Slot *Slot);</P>
<P>LPDIRECTDRAWSURFACE4 D3DCache_SlotGetSurface(D3DCache_Slot *Slot);</P>

<P>uint32 Log2(uint32 P2);</P>
<P>int32 SnapToPower2(int32 Width);</P>
<P>int32 GetLog(int32 Width, int32 Height);</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069990">D3ddrv.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  D3DDrv.h                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: D3D driver                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef D3DDRV_H</P>
<P>#define D3DDRV_H</P>

<P>#include "DCommon.h"</P>

<P>extern DRV_Window&#9;&#9;&#9;ClientWindow;</P>
<P>extern DRV_Driver&#9;&#9;&#9;D3DDRV;</P>

<P>void DRIVERCC ErrorBox(char *Str);</P>
<P>BOOL DRIVERCC DrvShutdown(void);</P>
<P>void SetLastDrvError(int32 Error, char *ErrorStr);</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069991">DDMemMgr.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  DDMemMgr.h                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Mini D3D memory manager                                                */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef DDMEMMGR_H</P>
<P>#define DDMEMMGR_H</P>

<P>#include &lt;Windows.h&gt;</P>
<P>#include &lt;Assert.h&gt;</P>

<P>#include "BaseType.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct&#9;DDMemMgr&#9;&#9;&#9;&#9;DDMemMgr;</P>
<P>typedef struct&#9;DDMemMgr_Partition&#9;&#9;DDMemMgr_Partition;</P>

<P>DDMemMgr&#9;*DDMemMgr_Create(uint32 Size);</P>
<P>void&#9;&#9;DDMemMgr_Destroy(DDMemMgr *MemMgr);</P>
<P>void&#9;&#9;DDMemMgr_Reset(DDMemMgr *MemMgr);</P>
<P>uint32&#9;&#9;DDMemMgr_GetFreeMem(DDMemMgr *MemMgr);</P>
<P>DDMemMgr_Partition *DDMemMgr_PartitionCreate(DDMemMgr *MemMgr, uint32 Size);</P>
<P>void&#9;&#9;DDMemMgr_PartitionDestroy(DDMemMgr_Partition *Partition);</P>
<P>void&#9;&#9;DDMemMgr_PartitionReset(DDMemMgr_Partition *Partition);</P>
<P>uint32&#9;&#9;DDMemMgr_PartitionGetTotalMem(DDMemMgr_Partition *Partition);</P>
<P>uint32&#9;&#9;DDMemMgr_PartitionGetFreeMem(DDMemMgr_Partition *Partition);</P>
<P>geBoolean&#9;DDMemMgr_PartitionAllocMem(DDMemMgr_Partition *Partition, uint32 Size);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069992">Gspan.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  GSpan.h                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Front to back span code                                                */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GSPAN</P>
<P>#define GSPAN</P>

<P>#include &lt;Windows.h&gt;</P>

<P>#define MAX_SPAN_LINES&#9;&#9;&#9;1024</P>
<P>#define MAX_SPANS&#9;&#9;&#9;&#9;35000</P>

<P>typedef struct </P>
<P>{</P>
<P>&#9;int32&#9;x1;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Starting x on screen</P>
<P>&#9;int32&#9;x2;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Ending x on screen</P>
<P>} SPAN;</P>

<P>typedef struct _SList</P>
<P>{</P>
<P>    int32&#9;Min, Max;</P>
<P>    uint8&#9;Used;</P>
<P>    uint32&#9;Flags;</P>
<P>    _SList&#9;*Last;</P>
<P>    _SList&#9;*Next;</P>
<P>} SLIST;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;SLIST *First;</P>
<P>&#9;SLIST *Current;</P>
<P>} SPAN_MINMAX;</P>

<P>extern&#9;SPAN&#9;SpanLines[MAX_SPAN_LINES];</P>

<P>extern&#9;SPAN_MINMAX&#9;SMinMax[MAX_SPAN_LINES];&#9;&#9;&#9;// Linked list of spans for each scanline...</P>
<P>extern&#9;SLIST&#9;ScanHash[MAX_SPANS];&#9;&#9;&#9;&#9;&#9;// hash table for SList</P>

<P>extern&#9;int32&#9;&#9;NumWorldPixels;</P>
<P>extern&#9;int32&#9;&#9;NumSpans;</P>
<P>extern&#9;int32&#9;&#9;NumSpanPixels[MAX_SPAN_LINES];</P>
<P>extern&#9;int32&#9;&#9;PolysRendered;</P>

<P>void&#9;DRIVERCC EdgeOutNoUV (int32 x1, int32 y1, int32 x2, int32 y2);</P>
<P>void&#9;DRIVERCC AddSpanNoUV(int32 x1, int32 x2, int32 y);</P>
<P>void&#9;ResetSList(void);</P>
<P>SLIST&#9;*NewSList(void);</P>
<P>void&#9;ResetSpans(int32 Rows);</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069993">Pcache.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  PCache.h                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: D3D poly cache                                                         */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef PCACHE_H</P>
<P>#define PCACHE_H</P>

<P>extern DRV_CacheInfo&#9;&#9;&#9;&#9;&#9;&#9;CacheInfo;</P>

<P>BOOL PCache_InsertWorldPoly(DRV_TLVertex *Verts, int32 NumVerts, geRDriver_THandle *THandle, DRV_TexInfo *TexInfo, DRV_LInfo *LInfo, uint32 Flags);</P>
<P>BOOL PCache_FlushWorldPolys(void);</P>

<P>BOOL PCache_FlushMiscPolys(void);</P>
<P>BOOL PCache_InsertMiscPoly(DRV_TLVertex *Verts, int32 NumVerts, geRDriver_THandle *THandle, uint32 Flags);</P>

<P>BOOL PCache_Reset(void);</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069994">Render.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Render.h                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Code to render polys under D3D                                         */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef RENDER_H</P>
<P>#define RENDER_H</P>

<P>#include &lt;Windows.h&gt;</P>

<P>#include "DCommon.h"</P>

<P>geBoolean DRIVERCC RenderGouraudPoly(DRV_TLVertex *Pnts, int32 NumPoints, uint32 Flags);</P>
<P>geBoolean DRIVERCC RenderWorldPoly(DRV_TLVertex *Pnts, int32 NumPoints, geRDriver_THandle *THandle, DRV_TexInfo *TexInfo, DRV_LInfo *LInfo, uint32 Flags);</P>
<P>geBoolean DRIVERCC RenderMiscTexturePoly(DRV_TLVertex *Pnts, int32 NumPoints, geRDriver_THandle *THandle, uint32 Flags);</P>
<P>geBoolean DRIVERCC DrawDecal(geRDriver_THandle *THandle, RECT *SRect, int32 x, int32 y);</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069995">Scene.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Scene.h                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Begin/EndScene code, etc                                               */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef SCENE_H</P>
<P>#define SCENE_H</P>

<P>#include &lt;Windows.H&gt;</P>

<P>#include "DCommon.h"</P>

<P>#define RENDER_NONE&#9;&#9;&#9;&#9;0</P>
<P>#define RENDER_WORLD&#9;&#9;&#9;1</P>
<P>#define RENDER_MESHES&#9;&#9;&#9;2</P>
<P>#define RENDER_MODELS&#9;&#9;&#9;3</P>

<P>extern int32 RenderMode;</P>

<P>BOOL DRIVERCC BeginScene(BOOL Clear, BOOL ClearZ, RECT *WorldRect);</P>
<P>BOOL DRIVERCC EndScene(void);</P>
<P>BOOL DRIVERCC BeginWorld(void);</P>
<P>BOOL DRIVERCC EndWorld(void);</P>
<P>BOOL DRIVERCC BeginMeshes(void);</P>
<P>BOOL DRIVERCC EndMeshes(void);</P>
<P>BOOL DRIVERCC BeginModels(void);</P>
<P>BOOL DRIVERCC EndModels(void);</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069996">Thandle.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  THandle.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: THandle manager for D3DDrv                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef THANDLE_H</P>
<P>#define THANDLE_H</P>

<P>#include &lt;Windows.h&gt;</P>

<P>#include "BaseType.h"</P>
<P>#include "DCommon.h"</P>
<P>#include "D3DCache.h"</P>

<P>#include "TPage.h"</P>

<P>//============================================================================================</P>
<P>//============================================================================================</P>
<P>#define THANDLE_MAX_MIP_LEVELS&#9;&#9;255</P>
<P>//#define&#9;MAX_LMAP_LOG_SIZE&#9;&#9;&#9;8&#9;&#9;&#9;// Max lightmap size in pixels will be 128x128</P>
<P>//#define&#9;MAX_LMAP_LOG_SIZE&#9;&#9;&#9;7&#9;&#9;&#9;// Max lightmap size in pixels will be 64x64</P>
<P>#define&#9;MAX_LMAP_LOG_SIZE&#9;&#9;&#9;6&#9;&#9;&#9;// Max lightmap size in pixels will be 32x32</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;LPDIRECTDRAWSURFACE4&#9;Surface;&#9;&#9;&#9;// The DD surface</P>
<P>&#9;D3DCache_Type&#9;&#9;&#9;*CacheType;</P>
<P>&#9;D3DCache_Slot&#9;&#9;&#9;*Slot;</P>
<P>&#9;</P>
<P>&#9;LPDIRECT3DTEXTURE2&#9;&#9;Texture;&#9;&#9;&#9;// The texture interface to the surface</P>

<P>&#9;uint8&#9;&#9;&#9;&#9;&#9;Flags;</P>
<P>} THandle_MipData;</P>

<P>// THandle flags</P>
<P>#define THANDLE_LOCKED&#9;&#9;&#9;&#9;&#9;(1&lt;&lt;0)</P>
<P>#define THANDLE_UPDATE&#9;&#9;&#9;&#9;&#9;(1&lt;&lt;1)</P>

<P>typedef struct geRDriver_THandle</P>
<P>{</P>
<P>&#9;uint8&#9;&#9;&#9;&#9;&#9;Active;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;Width;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;Height;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;Stride;</P>
<P>&#9;uint8&#9;&#9;&#9;&#9;&#9;NumMipLevels;</P>
<P>&#9;uint8&#9;&#9;&#9;&#9;&#9;Log;</P>

<P>&#9;THandle_MipData&#9;&#9;&#9;*MipData;&#9;&#9;&#9;&#9;// A mipdata per miplevel</P>

<P>&#9;geRDriver_PixelFormat&#9;PixelFormat;</P>

<P>#ifdef USE_TPAGES</P>
<P>&#9;TPage_Block&#9;&#9;&#9;&#9;*Block;</P>
<P>#endif</P>

<P>} geRDriver_THandle;</P>

<P>extern geRDriver_THandle&#9;TextureHandles[];</P>

<P>extern D3DCache&#9;&#9;&#9;&#9;*TextureCache;</P>
<P>extern D3DCache&#9;&#9;&#9;&#9;*LMapCache;</P>

<P>extern TPage_Mgr&#9;&#9;&#9;*TPageMgr;</P>

<P>extern THandle_MipData&#9;&#9;SystemToVideo[];</P>

<P>extern CacheNeedsUpdate;</P>

<P>//============================================================================================</P>
<P>//============================================================================================</P>
<P>void FreeAllCaches(void);</P>
<P>geRDriver_THandle *FindTextureHandle(void);</P>
<P>geBoolean FreeAllTextureHandles(void);</P>
<P>geBoolean THandle_Startup(void);</P>
<P>void THandle_Shutdown(void);</P>
<P>geRDriver_THandle *Create3DTHandle(geRDriver_THandle *THandle, int32 Width, int32 Height, int32 NumMipLevels, const geRDriver_PixelFormat *PixelFormat);</P>
<P>geRDriver_THandle *CreateLightmapTHandle(geRDriver_THandle *THandle, int32 Width, int32 Height, int32 NumMipLevels, const geRDriver_PixelFormat *PixelFormat);</P>
<P>geRDriver_THandle *Create2DTHandle(geRDriver_THandle *THandle, int32 Width, int32 Height, int32 NumMipLevels, const geRDriver_PixelFormat *PixelFormat);</P>
<P>geRDriver_THandle *DRIVERCC THandle_Create(int32 Width, int32 Height, int32 NumMipLevels, const geRDriver_PixelFormat *PixelFormat);</P>
<P>geBoolean DRIVERCC THandle_Destroy(geRDriver_THandle *THandle);</P>
<P>geBoolean DRIVERCC THandle_Lock(geRDriver_THandle *THandle, int32 MipLevel, void **Bits);</P>
<P>geBoolean DRIVERCC THandle_UnLock(geRDriver_THandle *THandle, int32 MipLevel);</P>
<P>geBoolean DRIVERCC THandle_GetInfo(geRDriver_THandle *THandle, int32 MipLevel, geRDriver_THandleInfo *Info);</P>
<P>geBoolean CreateSystemToVideoSurfaces(void);</P>
<P>void DestroySystemToVideoSurfaces(void);</P>
<P>geBoolean THandle_CreateSurfaces(THandle_MipData *MipData, int32 Width, int32 Height, DDSURFACEDESC2 *SurfDesc, geBoolean ColorKey, int32 Stage);</P>
<P>void THandle_DestroySurfaces(THandle_MipData *MipData);</P>
<P>geBoolean THandle_CheckCache(void);</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069997">Tpage.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  TPage.h                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: D3D cache manager using pages                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef TPAGE_H</P>
<P>#define TPAGE_H</P>

<P>#include &lt;Windows.h&gt;</P>

<P>#include &lt;DDraw.h&gt;</P>
<P>#include &lt;D3D.H&gt;</P>

<P>typedef struct TPage_Mgr&#9;TPage_Mgr;</P>
<P>typedef&#9;struct TPage&#9;&#9;TPage;</P>
<P>typedef struct TPage_Block&#9;TPage_Block;</P>

<P>//</P>
<P>// TPage_Mgr</P>
<P>//</P>
<P>TPage_Mgr&#9;&#9;*TPage_MgrCreate(LPDIRECTDRAW4 lpDD, const DDSURFACEDESC2 *SurfaceDesc, int32 NumPages);</P>
<P>void&#9;&#9;&#9;TPage_MgrDestroy(TPage_Mgr **TPageMgr);</P>
<P>geBoolean&#9;&#9;TPage_MgrHasTPage(TPage_Mgr *Mgr, TPage *Page);</P>
<P>geBoolean&#9;&#9;TPage_MgrAttachTPage(TPage_Mgr *Mgr, TPage *TPage);</P>
<P>void&#9;&#9;&#9;TPage_MgrDetachTPage(TPage_Mgr *Mgr, TPage *TPage);</P>
<P>TPage_Block&#9;&#9;*TPage_MgrFindOptimalBlock(TPage_Mgr *Mgr, uint32 LRU);</P>

<P>//</P>
<P>// TPage</P>
<P>//</P>
<P>TPage&#9;&#9;&#9;*TPage_Create(LPDIRECTDRAW4 lpDD, const DDSURFACEDESC2 *SurfDesc);</P>
<P>void&#9;&#9;&#9;TPage_CreateRef(TPage *Page);</P>
<P>void&#9;&#9;&#9;TPage_Destroy(TPage **Page1);</P>
<P>geBoolean&#9;&#9;TPage_HasBlock(TPage *TPage, TPage_Block *Block);</P>
<P>geBoolean&#9;&#9;TPage_AttachBlock(TPage *Page, TPage_Block *Block);</P>
<P>void&#9;&#9;&#9;TPage_DetachBlock(TPage *TPage, TPage_Block *Block);</P>
<P>geBoolean&#9;&#9;TPage_CreateSurfaces(TPage *Page, LPDIRECTDRAW4 lpDD, const DDSURFACEDESC2 *SurfDesc);</P>
<P>void&#9;&#9;&#9;TPage_DestroySurfaces(TPage *Page);</P>

<P>//</P>
<P>//TPage_Block</P>
<P>//</P>
<P>TPage_Block&#9;&#9;*TPage_BlockCreate(LPDIRECTDRAWSURFACE4 Surface, LPDIRECT3DTEXTURE2 Texture, const RECT *Rect);</P>
<P>geBoolean&#9;&#9;TPage_BlockCreateRef(TPage_Block *Block);</P>
<P>void&#9;&#9;&#9;TPage_BlockDestroy(TPage_Block **Block);</P>
<P>LPDIRECT3DTEXTURE2&#9;&#9;TPage_BlockGetTexture(TPage_Block *Block);</P>
<P>LPDIRECTDRAWSURFACE4&#9;TPage_BlockGetSurface(TPage_Block *Block);</P>
<P>const RECT&#9;&#9;*TPage_BlockGetRect(TPage_Block *Block);</P>
<P>void&#9;&#9;&#9;TPage_BlockSetLRU(TPage_Block *Block, uint32 LRU);</P>
<P>void&#9;&#9;&#9;TPage_BlockSetUserData(TPage_Block *Block, void *UserData);</P>
<P>void&#9;&#9;&#9;*TPage_BlockGetUserData(TPage_Block *Block);</P>

<P>#endif&#9;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454069998">OpenSource/Source/Engine/Drivers/GlideDrv Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>This subdirectory contains the Glide driver routines.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454069999">GCache.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  GCache.h                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Texture cache manager for glide                                        */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GCACHE_H</P>
<P>#define GCACHE_H</P>

<P>#include &lt;Windows.h&gt;</P>
<P>#include "Glide.h"</P>

<P>#include "BaseType.h"</P>
<P>#include "GMemMGr.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define GCACHE_MAX_NAME&#9;&#9;&#9;256</P>

<P>typedef struct GCache&#9;&#9;&#9;GCache;</P>
<P>typedef struct GCache_Type&#9;&#9;GCache_Type;</P>
<P>typedef struct GCache_Slot&#9;&#9;GCache_Slot;</P>

<P>&nbsp;</P>
<P>GCache&#9;&#9;*GCache_Create(const char *Name, GMemMgr *MemMgr);</P>
<P>void&#9;&#9;GCache_Destroy(GCache *Cache);</P>
<P>geBoolean&#9;GCache_Reset(GCache *Cache);</P>
<P>GCache_Type *GCache_FindCacheTypeByInfo(GCache *Cache, const GrTexInfo *Info);</P>
<P>GCache_Type *GCache_InsertCacheTypeByInfo(GCache *Cache, int32 Width, int32 Height, int32 NumMipLevels, const GrTexInfo *Info);</P>
<P>geBoolean&#9;GCache_UpdateSlot(GCache *Cache, GCache_Slot *Slot, GrTexInfo *Info);</P>
<P>geBoolean&#9;GCache_SetTexture(GCache *Cache, GCache_Slot *Slot);</P>
<P>GCache_Type *GCache_TypeCreate(GCache *Cache, int32 Width, int32 Height, int32 NumMipLevels, const GrTexInfo *Info);</P>
<P>void&#9;&#9;GCache_TypeDestroy(GCache_Type *CacheType);</P>
<P>geBoolean&#9;GCache_FreeAllSlots(GCache *Cache);</P>
<P>geBoolean&#9;GCache_AdjustSlots(GCache *Cache);</P>
<P>uint32&#9;&#9;GCache_SlotGetMemAddress(GCache_Slot *Slot);</P>
<P>uint32&#9;&#9;GCache_SlotGetMemAddress(GCache_Slot *Slot);</P>
<P>geBoolean&#9;GCache_SlotIsValid(GCache_Slot *Slot);</P>
<P>GCache_Slot&#9;*GCache_TypeFindSlot(GCache_Type *CacheType);</P>
<P>void&#9;&#9;GCache_SlotSetUserData(GCache_Slot *Slot, void *UserData);</P>
<P>void&#9;&#9;*GCache_SlotGetUserData(GCache_Slot *Slot);</P>
<P>GrTexInfo&#9;*GCache_SlotGetInfo(GCache_Slot *Slot);</P>
<P>void&#9;&#9;GCache_SlotSetLRU(GCache_Slot *Slot, uint32 LRU);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070000">Glidedrv.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  GlideDrv.h                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Distributes work to other modules.  This is the main GlideDrv file.    */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GLIDEDRV_H</P>
<P>#define GLIDEDRV_H</P>

<P>#include "BaseType.h"</P>

<P>#include "DCommon.h"</P>

<P>extern&#9;&#9;DRV_Driver GLIDEDRV;</P>

<P>void SetLastDrvError(int32 Error, char *ErrorStr);</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070001">Gmain.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  GMain.h                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Glide initialization code, etc                                         */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GMAIN_H</P>
<P>#define GMAIN_H</P>

<P>#include &lt;Windows.h&gt;</P>

<P>#include "GTHandle.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define GMAIN_MAX_TMU_SUPPORT&#9;&#9;&#9;&#9;&#9;&#9;8</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;uint32&#9;&#9;MainRam;</P>
<P>&#9;int32&#9;&#9;NumTMU;</P>
<P>&#9;uint32&#9;&#9;TmuRam[GMAIN_MAX_TMU_SUPPORT];</P>
<P>} GMain_BoardInfo;</P>

<P>extern GrChipID_t&#9;&#9;&#9;TMU[3];&#9;&#9;&#9;&#9;&#9;// TMU number table</P>

<P>extern DRV_Window&#9;&#9;&#9;ClientWindow;</P>
<P>extern GrHwConfiguration&#9;GlideHwConfig;</P>
<P>extern GMain_BoardInfo&#9;&#9;g_BoardInfo;&#9;&#9;&#9;// Global board info for current hardware</P>

<P>//============================================================================================</P>
<P>//============================================================================================</P>

<P>geBoolean GMain_Startup(DRV_DriverHook *Hook);</P>
<P>void GMain_Shutdown(void);</P>
<P>geBoolean GMain_GetBoardInfo(GMain_BoardInfo *Info);</P>
<P>geBoolean GMain_InitGlideRegisters(void);</P>
<P>geBoolean GMain_ResetAll(void);</P>
<P>geBoolean DRIVERCC GMain_ScreenShot(const char *Name);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070002">GMemMgr.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  GMemMgr.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Mini memory manager for glide                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GMEMMGR_H</P>
<P>#define GMEMMGR_H</P>

<P>#include &lt;Windows.h&gt;</P>
<P>#include "Glide.h"</P>
<P>#include "BaseType.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct GMemMgr&#9;&#9;&#9;GMemMgr;</P>

<P>GMemMgr&#9;&#9;*GMemMgr_Create(GrChipID_t Tmu, uint32 MinAddress, uint32 MaxAddress);</P>
<P>void&#9;&#9;GMemMgr_Destroy(GMemMgr *MemMgr);</P>
<P>uint32&#9;&#9;GMemMgr_GetTotalMemory(GMemMgr *MemMgr);</P>
<P>uint32&#9;&#9;GMemMgr_GetFreeMemory(GMemMgr *MemMgr);</P>
<P>geBoolean&#9;GMemMgr_AllocMem(GMemMgr *MemMgr, uint32 Size, uint32 *Address);</P>
<P>GrChipID_t&#9;GMemMgr_GetTmu(GMemMgr *MemMgr);</P>
<P>void&#9;&#9;GMemMgr_Reset(GMemMgr *MemMgr);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070003">GSpan.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  GSpan.h                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Front to back span code                                                */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GSPAN</P>
<P>#define GSPAN</P>

<P>#include &lt;Windows.h&gt;</P>

<P>#include "DCommon.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define MAX_SPAN_LINES&#9;&#9;&#9;1024</P>
<P>#define MAX_SPANS&#9;&#9;&#9;&#9;35000</P>

<P>typedef struct </P>
<P>{</P>
<P>&#9;int32&#9;x1;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Starting x on screen</P>
<P>&#9;int32&#9;x2;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Ending x on screen</P>
<P>} SPAN;</P>

<P>typedef struct SLIST</P>
<P>{</P>
<P>    uint8&#9;&#9;&#9;Used;</P>
<P>    int32&#9;&#9;&#9;Min, Max;</P>
<P>    uint32&#9;&#9;&#9;Flags;</P>
<P>    struct&#9;SLIST&#9;*Last;</P>
<P>    struct&#9;SLIST&#9;*Next;</P>
<P>} SLIST;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;SLIST *First;</P>
<P>&#9;SLIST *Current;</P>
<P>} SPAN_MINMAX;</P>

<P>extern&#9;SPAN&#9;SpanLines[MAX_SPAN_LINES];</P>

<P>extern&#9;SPAN_MINMAX&#9;SMinMax[MAX_SPAN_LINES];&#9;&#9;&#9;// Linked list of spans for each scanline...</P>
<P>extern&#9;SLIST&#9;ScanHash[MAX_SPANS];&#9;&#9;&#9;&#9;&#9;// hash table for SList</P>

<P>extern&#9;int32&#9;NumWorldPixels;</P>
<P>extern&#9;int32&#9;NumSpans;</P>
<P>extern&#9;int32&#9;NumSpanPixels[MAX_SPAN_LINES];</P>
<P>extern&#9;int32&#9;PolysRendered;</P>

<P>void&#9;DRIVERCC EdgeOutNoUV (int32 x1, int32 y1, int32 x2, int32 y2);</P>
<P>void&#9;DRIVERCC AddSpanNoUV(int32 x1, int32 x2, int32 y);</P>

<P>void&#9;ResetSList(void);</P>
<P>SLIST&#9;*NewSList(void);</P>
<P>void&#9;ResetSpans(int32 Rows);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070004">GThandle.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  GTHandle.h                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: THandle manager for glide                                              */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef THANDLE_H</P>
<P>#define THANDLE_H</P>

<P>#include &lt;Windows.h&gt;</P>

<P>#include "DCommon.h"</P>
<P>#include "BaseType.h"</P>
<P>#include "GCache.h"</P>
<P>#include "Glide.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define&#9;MAX_TEXTURE_HANDLES&#9;&#9;20000</P>

<P>// THandle flags</P>
<P>#define THANDLE_UPDATE&#9;&#9;(1&lt;&lt;0)&#9;&#9;// Force a thandle to be uploaded to the card</P>
<P>#define THANDLE_LOCKED&#9;&#9;(1&lt;&lt;1)&#9;&#9;// THandle is currently locked (invalid for rendering etc)</P>

<P>#define THANDLE_PALETTE_FORMAT&#9;(GE_PIXELFORMAT_32BIT_XRGB)</P>

<P>//============================================================================================</P>
<P>//============================================================================================</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;RefCount;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;Width;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;Height;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;LogSize;</P>
<P>&#9;uint8&#9;&#9;&#9;&#9;&#9;NumMipLevels;</P>
<P>&#9;geRDriver_PixelFormat&#9;PixelFormat;</P>

<P>&#9;uint8&#9;&#9;&#9;&#9;&#9;Log;</P>
<P>&#9;float&#9;&#9;&#9;&#9;&#9;OneOverLogSize_255;</P>
<P>} THandle_Info;</P>

<P>typedef struct geRDriver_THandle</P>
<P>{</P>
<P>&#9;uint8&#9;&#9;&#9;&#9;&#9;Active;</P>
<P>&#9;struct geRDriver_THandle&#9;*PalHandle;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;Width;&#9;&#9;&#9;&#9;// Original width/height</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;Height;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;LogSize;&#9;&#9;&#9;// Square width/height in cache</P>
<P>&#9;uint8&#9;&#9;&#9;&#9;&#9;NumMipLevels;</P>
<P>&#9;float&#9;&#9;&#9;&#9;&#9;OneOverLogSize_255;</P>
<P>&#9;uint8&#9;&#9;&#9;&#9;&#9;Log;</P>
<P>&#9;geRDriver_PixelFormat&#9;PixelFormat;</P>
<P>&#9;//GrTexInfo&#9;&#9;&#9;&#9;Info;</P>
<P>&#9;//uint16&#9;&#9;&#9;&#9;InfoIndex;&#9;&#9;&#9;// Use this ASAP!!!</P>

<P>&#9;void&#9;&#9;&#9;&#9;&#9;*Data;&#9;&#9;&#9;&#9;// Actual data bits of LogSize*LogSize</P>

<P>&#9;GCache_Type&#9;&#9;&#9;&#9;*CacheType;</P>
<P>&#9;GCache_Slot&#9;&#9;&#9;&#9;*Slot;&#9;&#9;&#9;&#9;// Current slot this handle is being textured with</P>

<P>&#9;uint8&#9;&#9;&#9;&#9;&#9;Flags;&#9;&#9;&#9;</P>
<P>} geRDriver_THandle;</P>

<P>extern geRDriver_THandle&#9;TextureHandles[MAX_TEXTURE_HANDLES];</P>

<P>// Memory managers</P>
<P>extern GMemMgr&#9;&#9;&#9;&#9;*MemMgr[2];</P>

<P>// Texture caches</P>
<P>extern GCache&#9;&#9;&#9;&#9;*TextureCache;&#9;&#9;&#9;// Texture cache</P>
<P>extern GCache&#9;&#9;&#9;&#9;*LMapCache;&#9;&#9;&#9;&#9;// Lightmap texture cache</P>

<P>extern geRDriver_THandle&#9;TextureHandles[MAX_TEXTURE_HANDLES];&#9;&#9;// Contain Texture/Decal/Lightmap handles</P>

<P>extern geBoolean&#9;&#9;&#9;TexturesChanged;</P>
<P>extern geBoolean&#9;&#9;&#9;LMapsChanged;</P>

<P>//============================================================================================</P>
<P>//============================================================================================</P>
<P>geBoolean GTHandle_Startup(void);</P>
<P>void GTHandle_Shutdown(void);</P>
<P>void GTHandle_FreeAllCaches(void);</P>
<P>geRDriver_THandle *GTHandle_FindTextureHandle();</P>
<P>void GTHandle_FreeTextureHandle(geRDriver_THandle *THandle);</P>
<P>void GTHandle_FreeAllTextureHandles(void);</P>
<P>geBoolean GTHandle_SetupInfo(GrTexInfo *Info, int32 Width, int32 Height, int32 NumMipLevels, GrTextureFormat_t Format, int32 *Size);</P>
<P>geBoolean GlideFormatFromGenesisFormat(gePixelFormat Format, GrTextureFormat_t *Out);</P>
<P>geRDriver_THandle *Create3DTexture(int32 Width, int32 Height, int32 NumMipLevels, const geRDriver_PixelFormat *PixelFormat);</P>
<P>geRDriver_THandle *CreateLightmapTexture(int32 Width, int32 Height, int32 NumMipLevels, const geRDriver_PixelFormat *PixelFormat);</P>
<P>geRDriver_THandle *Create2DTexture(int32 Width, int32 Height, int32 NumMipLevels, const geRDriver_PixelFormat *PixelFormat);</P>
<P>geRDriver_THandle *DRIVERCC GTHandle_Create(int32 Width, int32 Height, int32 NumMipLevels, const geRDriver_PixelFormat *PixelFormat);</P>
<P>geBoolean DRIVERCC GTHandle_Destroy(geRDriver_THandle *THandle);</P>
<P>geBoolean DRIVERCC GTHandle_Lock(geRDriver_THandle *THandle, int32 MipLevel, void **Data);</P>
<P>geBoolean DRIVERCC GTHandle_UnLock(geRDriver_THandle *THandle, int32 MipLevel);</P>
<P>geBoolean DRIVERCC GThandle_SetPal(geRDriver_THandle *THandle, geRDriver_THandle *PalHandle);</P>
<P>geRDriver_THandle *DRIVERCC GThandle_GetPal(geRDriver_THandle *THandle);</P>
<P>geBoolean DRIVERCC GTHandle_GetInfo(geRDriver_THandle *THandle, int32 MipLevel, geRDriver_THandleInfo *Info);</P>
<P>geBoolean GTHandle_CheckTextures(void);</P>
<P>geBoolean GetLod(S32 Width, GrLOD_t *Lod);</P>
<P>geBoolean GetAspectRatio(int32 Width, int32 Height, GrAspectRatio_t *Aspect);</P>
<P>uint32 GetLog(uint32 P2);</P>
<P>int32 SnapToPower2(int32 Width);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070005">Render.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Render.h                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Code to render polys in glide                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef RENDER_H</P>
<P>#define RENDER_H</P>

<P>#include &lt;Windows.h&gt;</P>

<P>#include "BaseType.h"</P>
<P>#include "Glide.h"</P>
<P>#include "DCommon.h"</P>
<P>#include "GCAche.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>enum </P>
<P>{  </P>
<P>&#9;RENDER_UNKNOWN_MODE,</P>
<P>&#9;RENDER_MISC_TEX_POLY_MODE, </P>
<P>&#9;RENDER_MISC_GOURAD_POLY_MODE, </P>
<P>&#9;RENDER_LINES_POLY_MODE, </P>
<P>&#9;RENDER_WORLD_TRANSPARENT_POLY_MODE,</P>
<P>&#9;RENDER_WORLD_POLY_MODE,</P>
<P>&#9;RENDER_LIGHTMAP_POLY_MODE,</P>
<P>&#9;RENDER_LIGHTMAP_FOG_POLY_MODE,</P>
<P>&#9;RENDER_DECAL_MODE,</P>
<P>};</P>

<P>extern uint32&#9;&#9;&#9;&#9;PolyMode;</P>
<P>extern DRV_CacheInfo&#9;&#9;CacheInfo;</P>

<P>void TextureSource(GrChipID_t Tmu, FxU32 startAddress, FxU32 evenOdd, GrTexInfo  *info );</P>
<P>void Render_SetHardwareMode(int32 NewMode, uint32 NewFlags);</P>
<P>geBoolean DRIVERCC Render_GouraudPoly(DRV_TLVertex *Pnts, int32 NumPoints, uint32 Flags);</P>
<P>geBoolean DRIVERCC Render_LinesPoly(DRV_TLVertex *Pnts, int32 NumPoints);</P>
<P>geBoolean DRIVERCC Render_WorldPoly(DRV_TLVertex *Pnts, int32 NumPoints, geRDriver_THandle *THandle, DRV_TexInfo *TexInfo, DRV_LInfo *LInfo, uint32 Flags);</P>
<P>void RenderLightmapPoly(GrVertex *vrtx, int32 NumPoints, DRV_LInfo *LInfo, geBoolean Dynamic, uint32 Flags);</P>
<P>void DownloadLightmap(DRV_LInfo *LInfo, int32 Wh, GCache_Slot *Slot, int32 LMapNum);</P>
<P>geBoolean DRIVERCC Render_MiscTexturePoly(DRV_TLVertex *Pnts, int32 NumPoints, geRDriver_THandle *THandle, uint32 Flags);</P>
<P>void SetupTexture(geRDriver_THandle *THandle);</P>
<P>GCache_Slot *SetupLMapTexture(geRDriver_THandle *THandle, DRV_LInfo *LInfo, geBoolean Dynamic, int32 LMapNum);</P>
<P>geBoolean DRIVERCC Render_DrawDecal(geRDriver_THandle *THandle, RECT *SRect, int32 x, int32 y);</P>
<P>geBoolean DRIVERCC BeginScene(geBoolean Clear, geBoolean ClearZ, RECT *WorldRect);</P>
<P>geBoolean DRIVERCC EndScene(void);</P>
<P>geBoolean DRIVERCC BeginWorld(void);</P>
<P>geBoolean DRIVERCC EndWorld(void);</P>
<P>geBoolean DRIVERCC BeginMeshes(void);</P>
<P>geBoolean DRIVERCC EndMeshes(void);</P>
<P>geBoolean DRIVERCC BeginModels(void);</P>
<P>geBoolean DRIVERCC EndModels(void);</P>

<P>//============================================================================================</P>
<P>//============================================================================================</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454070006">OpenSource/Source/Engine/Drivers/SoftDrv Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>This subdirectory contains the current software video driver routines.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070007">3dnowspan.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  3dnowspan.h                                                                         */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:       Ken Baird                                                             */</P>
<P>/*  Description:  Headers for 3dnow assembly calls                                      */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>typedef struct EdgeAsmTag EdgeAsm;</P>
<P>typedef struct EdgeAsmFPUTag EdgeAsmFPU;</P>

<P>//3dnow based non world faces</P>
<P>//DRV_RENDER_NO_ZMASK</P>
<P>extern void DrawScanLineGouraudNoZBufferZWrite_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>extern void DrawScanLineGouraudNoZBufferZWriteTrans_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//solid color</P>
<P>extern void DrawScanLineGouraudNoZBufferZWriteSolid_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>

<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_NO_ZWRITE</P>
<P>extern void DrawScanLineGouraudNoZ_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>extern void DrawScanLineGouraudNoZTrans_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//solid color</P>
<P>extern void DrawScanLineGouraudNoZSolid_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>

<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_NO_ZWRITE | DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudNoZAlphaTex_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudNoZBufferZWriteAlphaTex_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudZBufferNoZWriteAlphaTex_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudZBufferAlphaTex_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>

<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_NO_ZWRITE | DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudNoZAlphaARGB_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudNoZBufferZWriteAlphaARGB_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudZBufferNoZWriteAlphaARGB_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudZBufferAlphaARGB_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>

<P>//!(DRV_RENDER_NO_ZMASK | DRV_RENDER_NO_ZWRITE)</P>
<P>extern void DrawScanLineGouraudZBuffer_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>extern void DrawScanLineGouraudZBufferTrans_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//solid color</P>
<P>extern void DrawScanLineGouraudZBufferSolid_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>

<P>//DRV_RENDER_NO_ZWRITE</P>
<P>extern void DrawScanLineGouraudZBufferNoZWrite_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>extern void DrawScanLineGouraudZBufferNoZWriteTrans_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//solid color</P>
<P>extern void DrawScanLineGouraudZBufferNoZWriteSolid_Asm3DNow(EdgeAsm *pLeft, EdgeAsm *pRight);</P>

<P>&nbsp;</P>
<P>//world perspective correct faces</P>
<P>extern&#9;void DrawSpan32_AsmLit3DNow(int32 x1, int32 x2, int32 y);</P>
<P>extern&#9;void DrawSpan32_AsmLitZWrite3DNow(int32 x1, int32 x2, int32 y);</P>
<P>extern&#9;void DrawSpan32_AsmLitZBuffer3DNow(int32 x1, int32 x2, int32 y);</P>
<P>extern&#9;void DrawSpan32_AsmGouraud3DNow(int32 x1, int32 x2, int32 y, float r1, float g1, float b1, float r2, float g2, float b2);</P>
<P>extern&#9;void DrawSpan32_AsmGouraudZWrite3DNow(int32 x1, int32 x2, int32 y, float r1, float g1, float b1, float r2, float g2, float b2);</P>
<P>extern&#9;void DrawSpan32_AsmGouraudZBuffer3DNow(int32 x1, int32 x2, int32 y, float r1, float g1, float b1, float r2, float g2, float b2);</P>
<P>extern&#9;void DrawSpan32_AsmGouraudZBufferAlphaARGB3DNow(int32 x1, int32 x2, int32 y, float r1, float g1, float b1, float r2, float g2, float b2);</P>
<P>extern&#9;void DrawSpan32_AsmGouraudZBufferVertexAlpha3DNow(int32 x1, int32 x2, int32 y, float r1, float g1, float b1, float r2, float g2, float b2);</P>

<P>typedef struct&#9;EdgeAsmWorldTag&#9;EdgeAsmWorld;</P>

<P>extern&#9;void Femms3DNow(void);</P>
<P>extern&#9;void StepWorld3DNow(EdgeAsmWorld *edge);</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070008">dmodes.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  dmodes.h                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:       Ken Baird                                                             */</P>
<P>/*  Description:  Directdraw related stuff                                              */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#include "basetype.h"</P>

<P>extern&#9;void&#9;&#9;&#9;&#9;&#9;GetDDrawPixelFormat(DRV_Window *cwnd);</P>
<P>extern&#9;LPDIRECTDRAWSURFACE4&#9;DDrawLoadSurface(U32 dwWidth, U32 dwHeight, const void *pixels, const char *pal);</P>
<P>extern&#9;geBoolean&#9;&#9;&#9;&#9;LockDDrawBackBuffer(DRV_Window *cwnd, RECT *wrect);</P>
<P>extern&#9;geBoolean&#9;&#9;&#9;&#9;UnlockDDrawBackBuffer(DRV_Window *cwnd, RECT *wrect);</P>
<P>extern&#9;geBoolean&#9;&#9;&#9;&#9;RefreshDDraw(DRV_Window *cwnd, VidModeList *cmode, RECT *src, RECT *dst);</P>
<P>extern&#9;void&#9;&#9;&#9;&#9;&#9;ClearBackBuffer(DRV_Window *cwnd);</P>
<P>extern  geBoolean&#9;&#9;&#9;&#9;DDrawBlitDecal(LPDIRECTDRAWSURFACE4 lpDDSDecal, RECT *SRect, S32 x, S32 y);</P>
<P>extern  geBoolean&#9;&#9;&#9;&#9;DDrawBlitDecalDelayed(LPDIRECTDRAWSURFACE4 lpDDSDecal, RECT *SRect, S32 x, S32 y);</P>
<P>extern  geBoolean&#9;&#9;&#9;&#9;DDrawBlitDecalToFront(LPDIRECTDRAWSURFACE4 lpDDSDecal, RECT *SRect, S32 x, S32 y);</P>
<P>extern&#9;geBoolean&#9;DRIVERCC&#9;DrvSetActive(geBoolean wParam);</P>
<P>extern&#9;void&#9;&#9;&#9;&#9;&#9;SetDDrawWindow(HWND hwnd);</P>
<P>extern&#9;geBoolean&#9;&#9;&#9;&#9;SetDDrawMode(U32 top, VidEnumInfo *vinfo);</P>
<P>extern&#9;geBoolean&#9;&#9;&#9;&#9;DoDDrawInit(HWND hwnd, VidEnumInfo *vinfo);</P>
<P>extern&#9;geBoolean&#9;&#9;&#9;&#9;DoModeEnumeration(VidEnumInfo *vinfo);</P>
<P>extern&#9;geBoolean&#9;&#9;&#9;&#9;DoEnumeration(VidEnumInfo *vinfo);</P>
<P>extern&#9;void&#9;&#9;&#9;&#9;&#9;GetDDrawPixelFormat(DRV_Window *cwnd);</P>
<P>extern&#9;void&#9;&#9;&#9;&#9;&#9;FreeDDraw(VidEnumInfo *vinfo);</P>

<P>extern&#9;geBoolean&#9;&#9;&#9;&#9;bWindowed, bActive, bBackLocked;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070009">drawspan.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  drawspan.h                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:       Ken Baird                                                             */</P>
<P>/*  Description:  header for span draw code                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#include "softdrv.h"</P>
<P>#include "basetype.h"</P>

<P>typedef struct EdgeAsmFPUTag EdgeAsmFPU;</P>

<P>extern&#9;uint16&#9;*TDest, *pZBufferPtr, *Dest;</P>
<P>extern&#9;__int64&#9;Red, Green;</P>
<P>extern&#9;float&#9;Real65536;</P>
<P>extern&#9;double&#9;Bucket, Bucket2, Bucket3, Magic, RedMask, RedMask2;</P>
<P>extern&#9;uint32&#9;UMask, VShift, VMask, TempPix, Blue;</P>
<P>static&#9;uint32&#9;VStep, UStep, ZStep, u16, v16, z16, Z32;</P>

<P>extern&#9;float&#9;const&#9;Two, MiniRedMask, GreenMask;</P>
<P>extern&#9;float&#9;const&#9;MiniRedMask2, GreenMask2, BlueMask;</P>
<P>extern&#9;geFloat&#9;&#9;&#9;FloatTemp, FTemp0, FTemp1, FTemp2;</P>
<P>extern&#9;geFloat&#9;&#9;&#9;FTemp3, FTemp4, FTemp5, FTemp6, FTemp7, FTemp8;</P>

<P>extern&#9;int32&#9;GHMaskShifted, GHMaskShifted16, GWMaskShifted, GWMask, widTemp;</P>
<P>extern&#9;uint8&#9;*GBitPtrHalf;</P>
<P>extern&#9;double&#9;MipMagic;</P>
<P>extern&#9;double&#9;MipMagic2;</P>

<P>extern uint32&#9;NumASpans, RemainingCount;</P>
<P>extern double&#9;DeltaU, DeltaV, DeltaW;</P>
<P>extern uint32&#9;UFixed, VFixed, WLeft;</P>
<P>extern uint8&#9;*pTex;</P>

<P>extern&#9;int32&#9;R1, B1, G1, R2, G2, B2;</P>
<P>extern&#9;int32&#9;RR1, RR2, GG1, GG2, BB1, BB2;</P>
<P>extern&#9;int32&#9;StepR, StepG, StepB;</P>
<P>extern&#9;int32&#9;UDist, VDist;</P>
<P>extern&#9;int32&#9;U1, V1, CKeyTest;</P>
<P>extern&#9;float&#9;GLMapMulU;&#9;//lightscale</P>
<P>extern&#9;float&#9;GLMapMulV;&#9;//lightscale</P>
<P>extern&#9;int32&#9;ZDelta, ZVal;</P>
<P>extern&#9;float&#9;ZBufferPrec;</P>
<P>extern&#9;__int64&#9;RedDelta, GreenDelta, BlueDelta;</P>

<P>&nbsp;</P>
<P>//555</P>
<P>#define&#9;REDMASK2&#9;0x7c007c00;</P>
<P>#define&#9;GREENMASK2&#9;0x03e003e0;</P>
<P>#define&#9;BLUEMASK2&#9;0x001f001f;</P>

<P>//565</P>
<P>#define&#9;REDMASK&#9;&#9;0xf800f800;</P>
<P>#define&#9;GREENMASK&#9;0x07e007e0;</P>
<P>#define&#9;BLUEMASK&#9;0x001f001f;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070010">Register.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  register.h                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:       John Pollard, Ken Baird                                               */</P>
<P>/*  Description:  Texture Handle code header file                                       */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef REGISTER_H</P>
<P>#define REGISTER_H</P>

<P>#include &lt;Windows.h&gt;</P>

<P>#include "ddraw.h"</P>

<P>#include "DCommon.h"</P>

<P>#define&#9;MAX_TEXTURE_HANDLES&#9;&#9;15000</P>

<P>// THandle flags</P>
<P>#define THANDLE_UPDATE&#9;&#9;(1&lt;&lt;0)&#9;&#9;// Force a thandle to be uploaded to the card</P>
<P>#define&#9;THANDLE_TRANS&#9;&#9;(1&lt;&lt;2)&#9;&#9;// Texture has transparency</P>
<P>#define THANDLE_LOCKED&#9;&#9;(1&lt;&lt;3)&#9;&#9;// THandle is currently locked (invalid for rendering etc)</P>

<P>typedef struct geRDriver_THandle</P>
<P>{</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;&#9;Active, Width, Height, MipLevels;</P>
<P>&#9;geRDriver_PixelFormat&#9;PixelFormat;</P>
<P>&#9;uint16&#9;&#9;&#9;&#9;&#9;&#9;*BitPtr[16];//8 or 16</P>
<P>&#9;geRDriver_THandle&#9;&#9;*PalHandle;</P>
<P>&#9;geRDriver_THandle&#9;&#9;*AlphaHandle;</P>

<P>&#9;uint32&#9;&#9;&#9;&#9;&#9;&#9;Flags;</P>
<P>} geRDriver_THandle;</P>

<P>extern&#9;geRDriver_THandle&#9;TextureHandles[MAX_TEXTURE_HANDLES];</P>

<P>geBoolean&#9;&#9;&#9;DRIVERCC&#9;DrvResetAll(void);</P>
<P>geRDriver_THandle&#9;*DRIVERCC&#9;CreateTexture(int32 Width, int32 Height, int32 NumMipLevels, const geRDriver_PixelFormat *PixelFormat);</P>
<P>geBoolean&#9;&#9;&#9;DRIVERCC&#9;DestroyTexture(geRDriver_THandle *THandle);</P>

<P>geBoolean&#9;&#9;&#9;DRIVERCC&#9;LockTextureHandle(geRDriver_THandle *THandle, int32 MipLevel, void **Data);</P>
<P>geBoolean&#9;&#9;&#9;DRIVERCC&#9;UnLockTextureHandle(geRDriver_THandle *THandle, int32 MipLevel);</P>
<P>geBoolean&#9;&#9;&#9;DRIVERCC&#9;THandle_GetInfo(geRDriver_THandle *THandle, int32 MipLevel, geRDriver_THandleInfo *Info);</P>

<P>geBoolean&#9;&#9;&#9;DRIVERCC&#9;SetPalette(geRDriver_THandle *THandle, geRDriver_THandle *PalHandle);</P>
<P>geRDriver_THandle&#9;*DRIVERCC&#9;GetPalette(geRDriver_THandle *THandle);</P>
<P>geBoolean&#9;&#9;&#9;DRIVERCC&#9;SetAlpha(geRDriver_THandle *THandle, geRDriver_THandle *PalHandle);</P>
<P>geRDriver_THandle&#9;*DRIVERCC&#9;GetAlpha(geRDriver_THandle *THandle);</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070011">Render.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  render.h                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:       John Pollard, Ken Baird                                               */</P>
<P>/*  Description:  header for render.c                                                   */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef RENDER_H</P>
<P>#define RENDER_H</P>

<P>#include &lt;Windows.h&gt;</P>

<P>#include "DCommon.h"</P>
<P>#include "Span.h"</P>
<P>#include "Register.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef int32&#9;&#9;&#9;Fixed16;</P>

<P>#define&#9;&#9;&#9;&#9;&#9;ZBUFFER_PREC&#9;(65536.0f * 65536.0f)</P>
<P>//#define&#9;&#9;&#9;&#9;ZBUFFER_PREC&#9;(32768.0f * 65536.0f)</P>

<P>extern int32&#9;&#9;&#9;&#9;SpanMode;</P>
<P>extern int32&#9;&#9;&#9;&#9;PolyMode;</P>
<P>extern BOOL&#9;&#9;&#9;&#9;PolyIsTrans;</P>

<P>extern BOOL&#9;&#9;&#9;&#9;PolyVisible;</P>
<P>extern int32&#9;&#9;&#9;&#9;ActuallVisible;</P>
<P>extern int32&#9;&#9;&#9;&#9;NumPixels;</P>

<P>extern int32&#9;&#9;&#9;&#9;SMIN, SMAX;</P>

<P>extern uint8&#9;&#9;&#9;&#9;GMipLevel;&#9;&#9;&#9;&#9;// Miplevel passed by the latest rendering routine</P>
<P>extern int32&#9;&#9;&#9;GMipLevel4, GMipLevel20, GMipLevel4_8;</P>
<P>extern int32&#9;&#9;&#9;&#9;GLMapAdd;</P>
<P>extern DRV_LInfo&#9;&#9;*GLInfo;</P>
<P>extern DRV_Bitmap&#9;&#9;*GBitmap;</P>
<P>extern geRDriver_THandle&#9;*GTexture;</P>
<P>extern uint16&#9;&#9;&#9;&#9;*pScrPtr16bpp;</P>

<P>extern int32&#9;&#9;&#9;GLightWidth;</P>
<P>extern uint8&#9;&#9;&#9;*GLightData;</P>

<P>extern int32&#9;&#9;&#9;DeltaX, Remaining, N_Runs, PixelCount;</P>
<P>extern uint16&#9;&#9;&#9;*Source, *Dest;</P>
<P>extern int32&#9;&#9;&#9;U2, V2, StepU, StepV;</P>
<P>extern float&#9;&#9;&#9;UDivZ, VDivZ, Zi, Z, Dx, Dy, PixelEnd;</P>
<P>extern int32&#9;&#9;&#9;TxWhole, TyWhole, TxFract, TyFract;</P>
<P>extern float&#9;&#9;&#9;UDivZnStepX, VDivZnStepX, ZinStepX;</P>
<P>extern int32&#9;&#9;&#9;Junk[2];</P>

<P>extern float&#9;&#9;&#9;Real16 ;&#9;</P>
<P>extern float&#9;&#9;&#9;Real65536;</P>

<P>extern int32&#9;&#9;&#9;U, V;</P>

<P>extern int32&#9;&#9;&#9;&#9;GW, GWMask;</P>
<P>extern int32&#9;&#9;&#9;&#9;GH, GHMask;</P>
<P>extern uint8&#9;&#9;&#9;&#9;*GBitPtr;</P>
<P>extern uint16&#9;&#9;&#9;&#9;*GBitPtr16;</P>

<P>// 16bit zbuffer</P>
<P>extern uint16&#9;&#9;&#9;&#9;*ZBuffer;</P>

<P>extern float&#9;&#9;&#9;UDivZStepX;</P>
<P>extern float&#9;&#9;&#9;UDivZStepY;</P>
<P>extern float&#9;&#9;&#9;VDivZStepX;</P>
<P>extern float&#9;&#9;&#9;VDivZStepY;</P>

<P>extern float&#9;&#9;&#9;UDivZOrigin;</P>
<P>extern float&#9;&#9;&#9;VDivZOrigin;</P>
<P>extern float&#9;&#9;&#9;UDivZ16StepX, VDivZ16StepX, Zi16StepX;</P>
<P>extern float&#9;&#9;&#9;UDivZ32StepX, VDivZ32StepX, Zi32StepX;</P>

<P>extern float&#9;&#9;&#9;ZiStepX;</P>
<P>extern float&#9;&#9;&#9;ZiStepY;</P>
<P>extern float&#9;&#9;&#9;ZiOrigin;</P>

<P>extern Fixed16&#9;&#9;&#9;UAdjust;</P>
<P>extern Fixed16&#9;&#9;&#9;VAdjust;</P>
<P>extern Fixed16&#9;&#9;&#9;UAdjustL;</P>
<P>extern Fixed16&#9;&#9;&#9;VAdjustL;</P>
<P>extern Fixed16&#9;&#9;&#9;UAdjust1;</P>
<P>extern Fixed16&#9;&#9;&#9;VAdjust1;</P>
<P>extern Fixed16&#9;&#9;&#9;UAdjust2;</P>
<P>extern Fixed16&#9;&#9;&#9;VAdjust2;</P>

<P>extern Fixed16&#9;&#9;&#9;MaxU;</P>
<P>extern Fixed16&#9;&#9;&#9;MaxV;</P>

<P>#define ZBUFFER_SHIFT&#9;&#9;&#9;&#9;21</P>
<P>#define ZBUFFER_RIGHT_SHIFT&#9;&#9;&#9;10</P>

<P>// 16bit zbuffer</P>
<P>extern uint16&#9;&#9;&#9;*ZBuffer;</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>BOOL RenderInit(DRV_Window *Window);</P>
<P>BOOL RenderShutdown(void);</P>
<P>void ClearZBuffer(DRV_Window *Window);</P>

<P>// Render funtions</P>
<P>BOOL DRIVERCC RenderGouraudPoly(DRV_TLVertex *Pnts, int32 NumPoints, uint32 Flags);</P>
<P>BOOL DRIVERCC RenderWorldPoly(DRV_TLVertex *Pnts, int32 NumPoints, geRDriver_THandle *THandle, DRV_TexInfo *TexInfo, DRV_LInfo *LInfo, uint32 Flags);</P>
<P>BOOL DRIVERCC RenderMiscTexturePoly(DRV_TLVertex *Pnts, int32 NumPoints, geRDriver_THandle *THandle, uint32 Flags);</P>
<P>BOOL DRIVERCC DrawDecal(geRDriver_THandle *THandle, RECT *SRect, int32 x, int32 y);</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070012">sal.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  sal.h                                                                               */</P>
<P>/*                                                                                      */</P>
<P>/*  Description:  GDI dib handling code                                                 */</P>
<P>/*                                                                                      */</P>
<P>/*                Code fragments contributed by John Miles                              */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#ifndef SAL_VERSION</P>

<P>#define SAL_VERSION      "1.00"</P>
<P>#define SAL_VERSION_DATE "23-May-96"</P>

<P>#endif</P>

<P>#ifndef SAL_H</P>
<P>#define SAL_H</P>

<P>#ifdef WIN32</P>
<P>  #define IS_WIN32 1</P>
<P>#endif</P>

<P>#ifdef _WIN32</P>
<P>  #define IS_WIN32 1</P>
<P>#endif</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//</P>
<P>// If compiling SAL library, use __declspec(dllexport) for both </P>
<P>// declarations and definitions</P>
<P>//</P>
<P>// If compiling SAL application, use __declspec(dllimport) for</P>
<P>// declarations -- definitions don't matter</P>
<P>//</P>
<P>// (DOS, other system definitions to be added later)</P>
<P>//</P>
<P>/*</P>
<P>#ifdef IS_WIN32</P>

<P>  #define SALEXPORT WINAPI</P>

<P>  #ifdef BUILD_SAL</P>
<P>    #define DXDEC __declspec(dllexport)</P>
<P>    #define DXDEF __declspec(dllexport)</P>
<P>  #else</P>
<P>    #define DXDEC __declspec(dllimport)</P>
<P>  #endif</P>

<P>#else</P>

<P>  #define SALEXPORT</P>
<P>  #define WINAPI</P>

<P>#endif</P>
<P>*/</P>

<P>#define SALEXPORT WINAPI</P>
<P>#define DXDEC </P>
<P>#define DXDEF </P>

<P>//</P>
<P>// Misc. constant definitions  </P>
<P>//</P>

<P>//</P>
<P>// General type definitions for portability</P>
<P>// </P>

<P>#ifndef US_TYPEDEFS</P>
<P>#define US_TYPEDEFS</P>

<P>  typedef unsigned char   U8 ;</P>
<P>  typedef unsigned short  U16;</P>
<P>  typedef unsigned long   U32;</P>
<P>  typedef          char   C8 ;</P>
<P>  typedef signed   char   S8 ;</P>
<P>  typedef signed   short  S16;</P>
<P>  typedef signed   long   S32;</P>

<P>#endif</P>

<P>#ifndef YES</P>
<P>#define YES 1</P>
<P>#endif</P>

<P>#ifndef NO</P>
<P>#define NO  0</P>
<P>#endif</P>

<P>#ifndef TRUE</P>
<P>#define TRUE 1</P>
<P>#endif</P>

<P>#ifndef FALSE</P>
<P>#define FALSE  0</P>
<P>#endif</P>

<P>#define SAL_FULLSCREEN     0               // Set fullscreen DDraw mode</P>
<P>#define SAL_WINDOW         1               // Set DIB windowed mode</P>
<P>#define SAL_TRY_FULLSCREEN 2               // Try fullscreen, fall back to DIB</P>

<P>#define SAL_FRONT_SURFACE 0</P>
<P>#define SAL_BACK_SURFACE  1</P>

<P>//</P>
<P>// Preference names and default values</P>
<P>//</P>

<P>#define SAL_ALLOW_FRONT_LOCK         0     // Disregard request for front surface lock</P>
<P>#define DEFAULT_AFL                  NO</P>
<P>                                     </P>
<P>#define SAL_BUFFER_IF_NO_LFB         1     // Use system RAM page buffer if no LFB available</P>
<P>#define DEFAULT_BINL                 YES   </P>
<P>                                     </P>
<P>#define SAL_DOS_MONO_DEBUG           2     // Set up monochrome TTY debug monitor for DOS</P>
<P>#define DEFAULT_DMD                  YES</P>

<P>#define SAL_MAX_VIDEO_PAGES          3     // Allocate up to 3 video pages if possible</P>
<P>#define DEFAULT_MVP                  3     </P>

<P>#define SAL_ALLOW_WINDOW_RESIZE      4     // Allow window to be resized</P>
<P>#define DEFAULT_AWR                  YES</P>

<P>#define SAL_PREVENT_ALT_MENU_POPUP   5     // Do not allow ALT to pause app</P>
<P>#define DEFAULT_PAMP                 YES</P>

<P>#define SAL_ALWAYS_ON_TOP            6     // App has normal window Z order</P>
<P>#define DEFAULT_SAOT                 NO</P>

<P>#define SAL_MAXIMIZE_TO_FULLSCREEN   7     // Maximize button switches to FS</P>
<P>#define DEFAULT_MTF                  YES   </P>

<P>#define N_SAL_PREFS                  8     // # of preference types</P>

<P>//</P>
<P>// Structures</P>
<P>//</P>

<P>typedef struct</P>
<P>{</P>
<P>   U32 r;</P>
<P>   U32 g;</P>
<P>   U32 b;</P>
<P>   S32 alpha;</P>
<P>}</P>
<P>SAL_RGB32;</P>

<P>typedef struct</P>
<P>{</P>
<P>   S32 x0;</P>
<P>   S32 y0;</P>
<P>   S32 x1;</P>
<P>   S32 y1;</P>
<P>}</P>
<P>SAL_REGION;</P>

<P>typedef struct</P>
<P>{</P>
<P>   S32 x;</P>
<P>   S32 y;</P>
<P>   S32 width;</P>
<P>   S32 height;</P>
<P>}</P>
<P>SAL_WINAREA;</P>

<P>//</P>
<P>// Function pointer types</P>
<P>//</P>

<P>typedef void (SALEXPORT * SALFOCUSCB) (S32 status);</P>
<P>typedef void (SALEXPORT * SALEXITCB) (void);</P>

<P>//</P>
<P>// Miscellaneous/support services (not system-specific)</P>
<P>//</P>

<P>DXDEC void __cdecl SAL_debug_printf          (char *fmt, ...);</P>

<P>DXDEC  S32 WINAPI  SAL_get_preference        (U32   number);</P>
<P>                   </P>
<P>DXDEC  S32 WINAPI  SAL_set_preference        (U32   number, </P>
<P>                                              S32   value);</P>

<P>//</P>
<P>// General services (not system-specific)</P>
<P>//</P>

<P>DXDEC void WINAPI SAL_set_palette_entry      (S32        index,</P>
<P>                                              SAL_RGB32 *entry,</P>
<P>                                              S32        wait_flag);</P>
<P>                                             </P>
<P>DXDEC void WINAPI SAL_get_palette_entry      (S32        index,</P>
<P>                                              SAL_RGB32 *entry);</P>

<P>DXDEC void WINAPI SAL_set_palette_range      (S32        index,</P>
<P>                                              S32        num_entries,</P>
<P>                                              SAL_RGB32 *entry_list,</P>
<P>                                              S32        wait_flag);</P>
<P>                                             </P>
<P>DXDEC void WINAPI SAL_get_palette_range      (S32        index,</P>
<P>                                              S32        num_entries,</P>
<P>                                              SAL_RGB32 *entry_list);</P>

<P>DXDEC void WINAPI SAL_get_pixel_format       (S32       *pixel_pitch,</P>
<P>                                              S32       *bytes_per_pixel,</P>
<P>                                              S32       *R_shift,</P>
<P>                                              U32       *R_mask,</P>
<P>                                              S32       *R_width,</P>
<P>                                              S32       *G_shift,</P>
<P>                                              U32       *G_mask,</P>
<P>                                              S32       *G_width,</P>
<P>                                              S32       *B_shift,</P>
<P>                                              U32       *B_mask,</P>
<P>                                              S32       *B_width);</P>

<P>&nbsp;</P>
<P>DXDEC void WINAPI SAL_flip_surface           (void);</P>
<P>DXDEF void WINAPI SAL_blit_surface&#9;&#9;&#9;&#9;(void);</P>

<P>DXDEC void WINAPI SAL_wipe_surface           (S32        surface,</P>
<P>                                              U32        color);</P>

<P>DXDEC void WINAPI SAL_lock_surface           (S32        surface,</P>
<P>                                              U8       **ptr,</P>
<P>                                              S32       *pitch);</P>

<P>DXDEC void WINAPI SAL_release_surface        (S32        surface,</P>
<P>                                              S32        perform_flip);</P>

<P>DXDEC void WINAPI SAL_lock_region            (S32        surface,</P>
<P>                                              SAL_REGION region,</P>
<P>                                              U8       **ptr,</P>
<P>                                              S32       *pitch);</P>

<P>DXDEC void WINAPI SAL_release_region         (S32        surface,</P>
<P>                                              SAL_REGION region);</P>

<P>//</P>
<P>// Mouse services</P>
<P>//</P>

<P>DXDEC void WINAPI SAL_show_system_mouse      (void);</P>
<P>DXDEC void WINAPI SAL_hide_system_mouse      (void);</P>

<P>DXDEC void WINAPI SAL_constrain_mouse        (void);</P>
<P>DXDEC void WINAPI SAL_unconstrain_mouse      (void);</P>

<P>//</P>
<P>// System-specific functions for Win32 version</P>
<P>//</P>

<P>#ifdef IS_WIN32</P>
<P>  </P>
<P>  DXDEC S32        WINAPI SAL_startup                 (BOOL FileLog);</P>
<P>  DXDEC void       WINAPI SAL_shutdown                (void);</P>

<P>  DXDEC BOOL WINAPI SAL_set_main_window(HWND hWindow);</P>
<P>  // CHANGE! (12/18/96)</P>
<P>  // Must have a menu in my app. </P>
<P>  DXDEC HWND WINAPI SAL_create_main_window  (const char *MenuName);</P>
<P>                                                      </P>
<P>  DXDEC S32        WINAPI SAL_set_display_mode        (S32   display_size_X,</P>
<P>                                                       S32   display_size_Y,</P>
<P>                                                       S32   display_bpp,</P>
<P>                                                       S32   initial_window_mode,</P>
<P>                                                       S32   allow_mode_switch);</P>

<P>  DXDEC S32        WINAPI SAL_window_status           (void);</P>
<P>  DXDEC void       WINAPI SAL_window_area             (SAL_WINAREA *area);</P>
<P>  DXDEC void       WINAPI SAL_client_area             (SAL_WINAREA *area);</P>
<P>  DXDEC S32        WINAPI SAL_set_window_area         (SAL_WINAREA *area);</P>
<P>  DXDEC S32        WINAPI SAL_is_app_active           (void);</P>
<P>  DXDEC SALFOCUSCB WINAPI SAL_register_focus_callback (SALFOCUSCB fn);</P>
<P>  DXDEC WNDPROC    WINAPI SAL_register_WNDPROC        (WNDPROC fn);</P>

<P>  DXDEC void       WINAPI SAL_serve_message_queue     (void);</P>

<P>  DXDEC void      __cdecl SAL_error_box               (C8 *caption,</P>
<P>                                                       C8 *fmt, ...);</P>
<P>  // CHANGE! (12/18/96) John Pollard</P>
<P>  DXDEC void WINAPI SAL_GetBackBufferDC(HDC *dc);</P>
<P>  DXDEC void WINAPI SAL_ReleaseBackBufferDC(HDC dc);</P>

<P>#endif</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070013">Scene.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  scene.h                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:       John Pollard, Ken Baird                                               */</P>
<P>/*  Description:  scene header                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef SCENE_H</P>
<P>#define SCENE_H</P>

<P>#include &lt;Windows.H&gt;</P>

<P>#include "DCommon.h"</P>

<P>#define RENDER_NONE&#9;&#9;&#9;0</P>
<P>#define RENDER_WORLD&#9;&#9;1</P>
<P>#define RENDER_MESHES&#9;&#9;2</P>
<P>#define RENDER_MODELS&#9;&#9;3</P>

<P>extern int32&#9;RenderMode;</P>

<P>BOOL DRIVERCC BeginScene(BOOL Clear, BOOL ClearZ, RECT *WorldRect);</P>
<P>BOOL DRIVERCC EndScene(void);</P>
<P>BOOL DRIVERCC BeginWorld(void);</P>
<P>BOOL DRIVERCC EndWorld(void);</P>
<P>BOOL DRIVERCC BeginMeshes(void);</P>
<P>BOOL DRIVERCC EndMeshes(void);</P>
<P>BOOL DRIVERCC BeginModels(void);</P>
<P>BOOL DRIVERCC EndModels(void);</P>

<P>#endif</P>

<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070014">Softdrv.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  softdrv.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:       John Pollard, Ken Baird                                               */</P>
<P>/*  Description:  header for softdrv                                                    */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef SOFTDRV_H</P>
<P>#define SOFTDRV_H</P>

<P>#include "DCommon.h"</P>
<P>#include "ddraw.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" DRV_Window&#9;&#9;ClientWindow;</P>
<P>#else</P>
<P>extern DRV_Window&#9;&#9;ClientWindow;</P>
<P>#endif</P>

<P>extern DRV_Driver&#9;&#9;&#9;SOFTDRV;</P>
<P>extern DRV_CacheInfo&#9;&#9;CacheInfo;</P>

<P>enum&#9;VidSurfFlags</P>
<P>{</P>
<P>&#9;SYSTEM&#9;&#9;&#9;&#9;=1,&#9;//store buffer in system</P>
<P>&#9;VIDEO&#9;&#9;&#9;&#9;=2,&#9;//or video ram</P>
<P>&#9;HARDWARE&#9;&#9;&#9;=4,&#9;//refresh choices</P>
<P>&#9;DMABLT&#9;&#9;&#9;&#9;=8,</P>
<P>&#9;FASTBLT&#9;&#9;&#9;&#9;=16,</P>
<P>&#9;SAFEBLT&#9;&#9;&#9;&#9;=32,</P>
<P>&#9;FLIP&#9;&#9;&#9;&#9;=64,</P>
<P>&#9;DMAPAGELOCKREQUIRED&#9;=128,//pagelock for dma req</P>
<P>&#9;DMAASYNCH&#9;&#9;&#9;=256,//can do asynch dma</P>
<P>&#9;STRETCHMODE&#9;&#9;&#9;=512,//stretch to fit</P>
<P>&#9;MODEXMODE&#9;&#9;&#9;=1024</P>
<P>};</P>

<P>typedef struct VidModeListTag</P>
<P>{</P>
<P>&#9;uint32&#9;width;</P>
<P>&#9;uint32&#9;height;</P>
<P>&#9;uint32&#9;pitch;</P>
<P>&#9;uint32&#9;flags;&#9;&#9;&#9;&#9;//capabilities</P>
<P>&#9;uint32&#9;current;&#9;&#9;&#9;//caps in use</P>
<P>&#9;uint32&#9;bpp;</P>
<P>}&#9;VidModeList;</P>

<P>typedef struct VidEnumInfoTag</P>
<P>{</P>
<P>&#9;DDDEVICEIDENTIFIER&#9;DeviceInfo;</P>
<P>&#9;DDDEVICEIDENTIFIER&#9;DeviceInfoHost;</P>
<P>&#9;GUID&#9;&#9;&#9;&#9;*DeviceGuid;</P>
<P>&#9;VidModeList&#9;&#9;&#9;VidModes[128];&#9;//let's be safe</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;NumVidModes;</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;CurrentVidMode;</P>
<P>&#9;uint32&#9;&#9;&#9;&#9;&#9;bpp;&#9;&#9;&#9;//bytes per pixel</P>
<P>}&#9;VidEnumInfo;</P>

<P>typedef struct&#9;CPUInfoTag</P>
<P>{</P>
<P>&#9;uint32&#9;&#9;MaxCPUIDVal;</P>
<P>&#9;char&#9;VendorString[16];</P>
<P>&#9;char&#9;ProcName[48];</P>
<P>&#9;uint32&#9;&#9;ProcType;</P>
<P>&#9;uint32&#9;&#9;ProcFamily;</P>
<P>&#9;uint32&#9;&#9;ProcModel;</P>
<P>&#9;uint32&#9;&#9;ProcStepping;</P>
<P>&#9;uint32&#9;&#9;ProcSpeed;</P>
<P>&#9;BOOL&#9;HasRDTSC;</P>
<P>&#9;BOOL&#9;HasMMX;</P>
<P>&#9;BOOL&#9;Has3DNow;</P>
<P>&#9;BOOL&#9;HasFCMOV;</P>
<P>}&#9;CPUInfo;</P>

<P>BOOL DRIVERCC DrvShutdown(void);</P>
<P>void DRIVERCC ErrorBox(char *Str);</P>
<P>void SetLastDrvError(S32 Error, char *ErrorStr);</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>void&#9;ErrorPrintf(char *text, ...);</P>
<P>void&#9;DumpErrorLogToFile(char *fname);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070015">Span.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  span.h                                                                              */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:       John Pollard, Ken Baird                                               */</P>
<P>/*  Description:  Header for span.c and important defines                               */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef SPAN_H</P>
<P>#define SPAN_H</P>

<P>#include "basetype.h"</P>

<P>#define MAXSPANS 25000</P>
<P>#define MAXSCANLINES 768</P>

<P>typedef struct SList </P>
<P>{</P>
<P>    uint8&#9;&#9;Used;</P>
<P>&#9;int32&#9;&#9;Min, Max;</P>
<P>&#9;float&#9;z1, z2;&#9;&#9;// So we can spit z spans out for other spans that need to be occluded</P>
<P>    uint32&#9;&#9;Flags;</P>
<P>    struct SList&#9;*Last;</P>
<P>    struct SList&#9;*Next;</P>
<P>} SList;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;SList&#9;*First;</P>
<P>&#9;SList&#9;*Current;</P>
<P>} SpanMinMax;</P>

<P>extern&#9;int32&#9;NumCachedAlphaPolys;</P>
<P>extern&#9;int32&#9;NumCachedAlphaSpans;</P>

<P>SList&#9;*NewSList(void);</P>
<P>void&#9;FreeSList(SList *s);</P>
<P>void&#9;ResetSList(void);</P>
<P>void&#9;ResetSpans(uint32 Rows);</P>

<P>extern SpanMinMax SMinMax[MAXSCANLINES];</P>
<P>extern SList ScanHash[MAXSPANS];  // hash table for SList</P>
<P>extern int32 CurrentSList;</P>

<P>&nbsp;</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070016">System.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  system.h                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:       John Pollard, Ken Baird                                               */</P>
<P>/*  Description:  header for system.c                                                   */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef SYSTEM_H</P>
<P>#define SYSTEM_H</P>

<P>#include &lt;Windows.h&gt;</P>
<P>#include &lt;stdio.h&gt;</P>

<P>BOOL SysInit(void);</P>
<P>BOOL SysShutdown(void);</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454070017">x86span555.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  x86span555.h                                                                        */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:       Ken Baird                                                             */</P>
<P>/*  Description:  header for x86 renderstates                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>typedef struct EdgeAsmTag EdgeAsm;</P>
<P>typedef struct EdgeAsmFPUTag EdgeAsmFPU;</P>

<P>//x86 fpu based non world faces 555</P>
<P>//DRV_RENDER_NO_ZMASK</P>
<P>extern void DrawScanLineGouraudNoZBufferZWrite_Asm555X86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>extern void DrawScanLineGouraudNoZBufferZWriteTrans_Asm555X86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>//solid color</P>
<P>extern void DrawScanLineGouraudNoZBufferZWriteSolid_Asm555X86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>

<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_NO_ZWRITE</P>
<P>extern void DrawScanLineGouraudNoZ_Asm555X86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>extern void DrawScanLineGouraudNoZTrans_Asm555X86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>//solid color</P>
<P>extern void DrawScanLineGouraudNoZSolid_Asm555X86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>

<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_NO_ZWRITE | DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudNoZAlphaTex_Asm555X86FPU(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudNoZBufferZWriteAlphaTex_Asm555X86FPU(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudZBufferNoZWriteAlphaTex_Asm555X86FPU(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudZBufferAlphaTex_Asm555X86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>

<P>//!(DRV_RENDER_NO_ZMASK | DRV_RENDER_NO_ZWRITE)</P>
<P>extern void DrawScanLineGouraudZBuffer_Asm555X86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>extern void DrawScanLineGouraudZBufferTrans_Asm555X86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>//solid color</P>
<P>extern void DrawScanLineGouraudZBufferSolid_Asm555X86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>

<P>//DRV_RENDER_NO_ZWRITE</P>
<P>extern void DrawScanLineGouraudZBufferNoZWrite_Asm555X86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>extern void DrawScanLineGouraudZBufferNoZWriteTrans_Asm555X86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>//solid color</P>
<P>extern void DrawScanLineGouraudZBufferNoZWriteSolid_Asm555X86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>

<P>&nbsp;</P>
<P>//world perspective correct faces</P>
<P>void&#9;DrawSpan16_AsmLit555X86FPU(int32 x1, int32 x2, int32 y);</P>
<P>void&#9;DrawSpan16_AsmLitZWrite555X86FPU(int32 x1, int32 x2, int32 y);</P>
<P>void&#9;DrawSpan16_AsmLitZBuffer555X86FPU(int32 x1, int32 x2, int32 y);</P>
<P>void&#9;DrawSpan16_AsmGouraud555X86FPU(int32 x1, int32 x2, int32 y, int32 r1, int32 g1, int32 b1, int32 r2, int32 g2, int32 b2);</P>
<P>void&#9;DrawSpan16_AsmGouraudZWrite555X86FPU(int32 x1, int32 x2, int32 y, int32 r1, int32 g1, int32 b1, int32 r2, int32 g2, int32 b2);</P>
<P>void&#9;DrawSpan16_AsmGouraudZBuffer555X86FPU(int32 x1, int32 x2, int32 y, int32 r1, int32 g1, int32 b1, int32 r2, int32 g2, int32 b2);</P>
<P>void&#9;DrawSpan16_AsmGouraudZBufferTrans555X86FPU(int32 x1, int32 x2, int32 y, int32 r1, int32 g1, int32 b1, int32 r2, int32 g2, int32 b2);</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070018">x86span565.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  x86span565.h                                                                        */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:       Ken Baird                                                             */</P>
<P>/*  Description:  header for x86 renderstates                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>typedef struct EdgeAsmTag EdgeAsm;</P>
<P>typedef struct EdgeAsmFPUTag EdgeAsmFPU;</P>

<P>//x86 fpu based non world faces</P>
<P>//DRV_RENDER_NO_ZMASK</P>
<P>extern void DrawScanLineGouraudNoZBufferZWrite_AsmX86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>extern void DrawScanLineGouraudNoZBufferZWriteTrans_AsmX86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>//solid color</P>
<P>extern void DrawScanLineGouraudNoZBufferZWriteSolid_AsmX86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>

<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_NO_ZWRITE</P>
<P>extern void DrawScanLineGouraudNoZ_AsmX86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>extern void DrawScanLineGouraudNoZTrans_AsmX86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>//solid color</P>
<P>extern void&#9;DrawScanLineGouraudNoZSolid_AsmX86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>

<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_NO_ZWRITE | DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudNoZAlphaTex_AsmX86FPU(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudNoZBufferZWriteAlphaTex_AsmX86FPU(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//DRV_RENDER_NO_ZMASK | DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudZBufferNoZWriteAlphaTex_AsmX86FPU(EdgeAsm *pLeft, EdgeAsm *pRight);</P>
<P>//DRV_RENDER_ALPHA</P>
<P>extern void DrawScanLineGouraudZBufferAlphaTex_AsmX86FPU(EdgeAsm *pLeft, EdgeAsm *pRight);</P>

<P>//!(DRV_RENDER_NO_ZMASK | DRV_RENDER_NO_ZWRITE)</P>
<P>extern void DrawScanLineGouraudZBuffer_AsmX86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>extern void DrawScanLineGouraudZBufferTrans_AsmX86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>//solid color</P>
<P>extern void DrawScanLineGouraudZBufferSolid_AsmX86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>

<P>//DRV_RENDER_NO_ZWRITE</P>
<P>extern void DrawScanLineGouraudZBufferNoZWrite_AsmX86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>extern void DrawScanLineGouraudZBufferNoZWriteTrans_AsmX86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>
<P>//solid color</P>
<P>extern void DrawScanLineGouraudZBufferNoZWriteSolid_AsmX86FPU(EdgeAsmFPU *pLeft, EdgeAsmFPU *pRight);</P>

<P>&nbsp;</P>
<P>//world perspective correct faces</P>
<P>void&#9;DrawSpan16_AsmLitX86FPU(int32 x1, int32 x2, int32 y);</P>
<P>void&#9;DrawSpan16_AsmLitZWriteX86FPU(int32 x1, int32 x2, int32 y);</P>
<P>void&#9;DrawSpan16_AsmLitZBufferX86FPU(int32 x1, int32 x2, int32 y);</P>
<P>void&#9;DrawSpan16_AsmGouraudX86FPU(int32 x1, int32 x2, int32 y, int32 r1, int32 g1, int32 b1, int32 r2, int32 g2, int32 b2);</P>
<P>void&#9;DrawSpan16_AsmGouraudZWriteX86FPU(int32 x1, int32 x2, int32 y, int32 r1, int32 g1, int32 b1, int32 r2, int32 g2, int32 b2);</P>
<P>void&#9;DrawSpan16_AsmGouraudZBufferX86FPU(int32 x1, int32 x2, int32 y, int32 r1, int32 g1, int32 b1, int32 r2, int32 g2, int32 b2);</P>
<P>void&#9;DrawSpan16_AsmGouraudZBufferTransX86FPU(int32 x1, int32 x2, int32 y, int32 r1, int32 g1, int32 b1, int32 r2, int32 g2, int32 b2);</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<I><P><A NAME="_Toc454070019">OpenSource/Source/Engine/Drivers/SoftDrv2 Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>This subdirectory contains a set of experimental software driver routines.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070020">CPUInfo.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  CPUInfo.H                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:  Mike Sandige, Ken Baird                                                    */</P>
<P>/*  Description:  simple cpu capabilities tests                                         */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef CPUInfo_H</P>
<P>#define CPUInfo_H</P>

<P>//  Tests cpu for various features.</P>

<P>&nbsp;</P>
<P>#include "basetype.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>geBoolean CPUInfo_TestFor3DNow(void);</P>
<P>geBoolean CPUInfo_TestForMMX(void);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070021">DDrawDisplay.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  DDRAWDisplay.H                                                                      */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:  Mike Sandige                                                               */</P>
<P>/*  Description:  display surface manager for full screen Direct Draw using a direct    */</P>
<P>/*                draw surface for the the frame buffer                                 */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef DDRAWDISPLAY_H</P>
<P>#define DDRAWDISPLAY_H</P>

<P>&nbsp;</P>
<P>#include "basetype.h"</P>
<P>#include "DisplayModeInfo.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct DDRAWDisplay DDRAWDisplay;</P>

<P>void&#9; DDRAWDisplay_GetDisplayFormat(&#9;&#9;const DDRAWDisplay *D,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32   *Width, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32   *Height,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32   *BitsPerPixel,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32  *Flags);</P>

<P>geBoolean DDRAWDisplay_GetDisplayInfo(&#9;char&#9;&#9;&#9;*DescriptionString, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;unsigned int&#9; DescriptionStringMaxLength,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DisplayModeInfo *Info);</P>

<P>geBoolean DDRAWDisplay_GetPixelFormat(&#9;DDRAWDisplay *D,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//int32       *pixel_pitch,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *bytes_per_pixel,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *R_shift,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32      *R_mask,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *R_width,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *G_shift,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32      *G_mask,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *G_width,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *B_shift,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32      *B_mask,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *B_width);</P>

<P>geBoolean&#9;DDRAWDisplay_Lock(&#9;&#9;DDRAWDisplay *D,uint8 **Buffer, int32 *Pitch);</P>
<P>geBoolean&#9;DDRAWDisplay_Unlock(&#9;DDRAWDisplay *D);</P>
<P>geBoolean&#9;DDRAWDisplay_Blit(&#9;&#9;DDRAWDisplay *D);</P>
<P>geBoolean&#9;DDRAWDisplay_Wipe(&#9;&#9;DDRAWDisplay *D,uint32 color);</P>
<P>geBoolean&#9;DDRAWDisplay_SetActive(&#9;DDRAWDisplay *D, geBoolean Active);</P>
<P>void&#9;&#9;DDRAWDisplay_Destroy(&#9;DDRAWDisplay **D);</P>

<P>#ifdef _INC_WINDOWS&#9;</P>
<P>DDRAWDisplay *DDRAWDisplay_Create( HWND hwnd, int Width, int Height, int BBP, uint32 Flags);</P>
<P>#endif</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>

<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454070022">DIBDisplay.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  DIBDisplay.H                                                                        */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:  Mike Sandige                                                               */</P>
<P>/*  Description:  display surface manager for windows with a DIB as the frame buffer    */</P>
<P>/*                Code fragments contributed by John Miles                              */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>&nbsp;</P>
<P>#ifndef DIBDisplay_H</P>
<P>#define DIBDisplay_H</P>

<P>#include "basetype.h"</P>
<P>#include "DisplayModeInfo.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct DIBDisplay DIBDisplay;</P>

<P>geBoolean DIBDisplay_GetDisplayInfo(&#9;char&#9;&#9;&#9;*DescriptionString, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;unsigned int&#9; DescriptionStringMaxLength,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DisplayModeInfo *Info);</P>

<P>void DIBDisplay_GetDisplayFormat(&#9;&#9;const DIBDisplay *D,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32   *Width, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32   *Height,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32   *BitsPerPixel,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32  *Flags);</P>

<P>geBoolean DIBDisplay_GetPixelFormat  (&#9;const DIBDisplay *D,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//int32       *pixel_pitch,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *bytes_per_pixel,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *R_shift,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32      *R_mask,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *R_width,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *G_shift,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32      *G_mask,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *G_width,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *B_shift,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32      *B_mask,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *B_width);</P>

<P>&nbsp;</P>
<P>geBoolean DIBDisplay_Blit&#9;&#9;(&#9;DIBDisplay *D);</P>

<P>geBoolean DIBDisplay_Wipe&#9;&#9;(&#9;DIBDisplay *D,&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32        color);</P>

<P>geBoolean DIBDisplay_Lock&#9;&#9;(&#9;DIBDisplay *D,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint8       **ptr,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *pitch);</P>

<P>geBoolean DIBDisplay_Unlock&#9;&#9;(&#9;DIBDisplay *D);</P>

<P>void DIBDisplay_Destroy&#9;&#9;&#9;(&#9;DIBDisplay **pDIBDisplay);</P>

<P>                         </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9; </P>
<P>#ifdef _INC_WINDOWS&#9;&#9;&#9;&#9;&#9;&#9;                             </P>
<P>DIBDisplay *DIBDisplay_Create&#9;(&#9;HWND hWindow,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int  Width,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int  Height,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int  display_bpp,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 Flags);</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070023">display.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Display.H                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:  Mike Sandige                                                               */</P>
<P>/*  Description:  Abstracts all low-level display surfaces into a single API            */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>// Display</P>
<P>//   display manager </P>
<P>//</P>
<P>//   manages </P>
<P>//     DIB format window displays</P>
<P>//     DDRAW format fullscreen displays</P>

<P>&nbsp;</P>
<P>#ifndef Display_H</P>
<P>#define Display_H</P>

<P>#include "basetype.h"</P>
<P>#include "DisplayModeInfo.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef enum { DISPLAY_DIB_WINDOW, DISPLAY_DDRAW_FULLSCREEN, DISPLAY_COUNT } Display_Type;</P>

<P>typedef struct Display Display;</P>

<P>geBoolean Display_GetDisplayInfo(&#9;&#9;Display_Type&#9; DisplayType,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;char&#9;&#9;&#9;*DescriptionString, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;unsigned int&#9; DescriptionStringMaxLength,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DisplayModeInfo *Info);</P>

<P>geBoolean Display_GetPixelFormat&#9;(&#9;const Display *D,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//int32       *pixel_pitch,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *bytes_per_pixel,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *R_shift,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32      *R_mask,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *R_width,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *G_shift,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32      *G_mask,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *G_width,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *B_shift,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32      *B_mask,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *B_width);</P>

<P>void&#9;Display_GetDisplayFormat(&#9;&#9;const Display *D,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Display_Type *DisplayType,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32   *Width, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32   *Height,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32   *BitsPerPixel,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32  *Flags);</P>

<P>geBoolean Display_Blit&#9;&#9;(&#9;Display *D);</P>

<P>geBoolean Display_Wipe&#9;&#9;(&#9;Display *D,&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32        color);</P>

<P>geBoolean Display_Lock&#9;&#9;(&#9;Display *D,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint8       **ptr,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32       *pitch);</P>

<P>geBoolean Display_Unlock&#9;(&#9;Display *D);</P>

<P>void Display_Destroy&#9;&#9;(&#9;Display **pDisplay);</P>

<P>geBoolean Display_SetActive&#9;(&#9;Display *D, geBoolean Active );</P>

<P>&#9;&#9;&#9;&#9;&#9;&#9; </P>
<P>#ifdef _INC_WINDOWS&#9;&#9;&#9;&#9;&#9;&#9;                             </P>
<P>Display *Display_Create&#9;(&#9;HWND hWindow,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Display_Type DisplayType,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32   RenderSizeAcross, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32   RenderSizeDown,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32   Display_BitsPerPixel,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32  Display_Flags);</P>
<P>#endif</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454070024">DisplayModeInfo.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  DisplayModeInfo.H                                                                   */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:  Mike Sandige                                                               */</P>
<P>/*  Description:  This is a simple container to hold information about available display*/</P>
<P>/*                modes for the software driver.                                        */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#ifndef DisplayModeInfo_H</P>
<P>#define DisplayModeInfo_H</P>

<P>#include "basetype.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>enum&#9;DisplayModeInfo_Flags</P>
<P>{</P>
<P>&#9;SYSTEM&#9;&#9;&#9;&#9;=1,&#9;//store buffer in system</P>
<P>&#9;VIDEO&#9;&#9;&#9;&#9;=2,&#9;//or video ram</P>
<P>&#9;HARDWARE&#9;&#9;&#9;=4,&#9;//refresh choices</P>
<P>&#9;DMABLT&#9;&#9;&#9;&#9;=8,</P>
<P>&#9;FASTBLT&#9;&#9;&#9;&#9;=16,</P>
<P>&#9;SAFEBLT&#9;&#9;&#9;&#9;=32,</P>
<P>&#9;FLIP&#9;&#9;&#9;&#9;=64,</P>
<P>&#9;DMAPAGELOCKREQUIRED&#9;=128,//pagelock for dma req</P>
<P>&#9;DMAASYNCH&#9;&#9;&#9;=256,//can do asynch dma</P>
<P>&#9;STRETCHMODE&#9;&#9;&#9;=512,//stretch to fit</P>
<P>&#9;MODEXMODE&#9;&#9;&#9;=1024</P>
<P>};</P>

<P>typedef struct DisplayModeInfo DisplayModeInfo;</P>

<P>DisplayModeInfo *&#9;DisplayModeInfo_Create(&#9;&#9;&#9;void );</P>

<P>void&#9;&#9;&#9;&#9;DisplayModeInfo_Destroy(&#9;&#9;DisplayModeInfo **Info );</P>

<P>int&#9;&#9;&#9;&#9;&#9;DisplayModeInfo_GetModeCount(&#9;DisplayModeInfo *Info);</P>

<P>geBoolean&#9;&#9;&#9;DisplayModeInfo_AddEntry(&#9;&#9;DisplayModeInfo *Info, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int Width,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int Height,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int BitsPerPixel,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 Flags );</P>

<P>geBoolean&#9;&#9;&#9;DisplayModeInfo_GetNth(&#9;&#9;&#9;DisplayModeInfo *Info, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int Nth,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int *Width, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int *Height,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int *BitsPerPixel,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 *Flags);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070025">DrawDecal.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  DrawDecal.H                                                                         */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Ken Baird, Mike Sandige                                                     */</P>
<P>/*  Description:  This is a simple 2d blitter for the Genesis3d software driver.        */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef DRAWDECAL</P>
<P>#define DRAWDECAL</P>

<P>#include "SWTHandle.h"&#9;// geRDriver_THandle, RECT. </P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>geBoolean DRIVERCC DrawDecal(geRDriver_THandle *THandle, RECT *SRect, int32 x, int32 y);</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454070026">rop.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  ROP.H                                                                               */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige                                                                */</P>
<P>/*  Description:  This defines the available rops for the software driver triangle      */</P>
<P>/*                rasterizer.                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef ROP_H</P>
<P>#define ROP_H</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>&#9;</P>
<P>//&#9;light = gourad,map,flat,none(fullbright)</P>
<P>//  alpha = none, map(only with a texture), flat</P>
<P>typedef enum {</P>
<P>&#9;&#9;&#9; </P>
<P>//ROP ID&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//&#9; texture   light  alpha&#9;&#9;z&#9;&#9;z&#9;  &#9;span&#9;span&#9;priority</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;test&#9;set&#9;&#9;test&#9;set&#9;&#9;&#9;&#9;&#9;&#9;&#9;  </P>
<P>GE_ROP_LSHADE,  &#9;&#9;&#9;&#9;&#9;&#9;//&#9;|&#9;-&#9;|&#9;g&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;m&#9;&#9;</P>
<P>GE_ROP_LSHADE_ZSET,  &#9;&#9;&#9;&#9;&#9;//&#9;|&#9;-&#9;|&#9;g&#9;|&#9;-&#9;|&#9;-&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;m&#9;&#9;</P>
<P>GE_ROP_LSHADE_ZTEST,  &#9;&#9;&#9;&#9;&#9;//&#9;|&#9;-&#9;|&#9;g&#9;|&#9;-&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;m&#9;&#9;</P>
<P>GE_ROP_LSHADE_ZTESTSET,  &#9;&#9;&#9;&#9;//&#9;|&#9;-&#9;|&#9;g&#9;|&#9;-&#9;|&#9;+&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;h&#9;&#9;</P>
<P>GE_ROP_LSHADE_AFLAT,&#9;&#9;&#9;&#9;&#9;//&#9;|&#9;-&#9;|&#9;g&#9;|&#9;f&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;l&#9;&#9;</P>
<P>GE_ROP_LSHADE_AFLAT_ZSET,&#9;&#9;&#9;&#9;//&#9;|&#9;-&#9;|&#9;g&#9;|&#9;f&#9;|&#9;-&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;l&#9;&#9;</P>
<P>GE_ROP_LSHADE_AFLAT_ZTEST,&#9;&#9;&#9;&#9;//&#9;|&#9;-&#9;|&#9;g&#9;|&#9;f&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;l&#9;&#9;</P>
<P>GE_ROP_LSHADE_AFLAT_ZTESTSET,&#9;&#9;&#9;//&#9;|&#9;-&#9;|&#9;g&#9;|&#9;f&#9;|&#9;+&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;l&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE,  &#9;&#9;&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;m&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_ZSET,&#9;&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;-&#9;|&#9;-&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;m&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_ZTEST,  &#9;&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;-&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;m&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_ZTESTSET,&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;-&#9;|&#9;+&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;h&#9;&#9;</P>
<P>GE_ROP_TMAP_LMAP_ZSET_SBUF,  &#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;m&#9;|&#9;-&#9;|&#9;-&#9;|&#9;+&#9;|&#9;+&#9;|&#9;+&#9;|&#9;h&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_ZSET_SBUF,&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;-&#9;|&#9;-&#9;|&#9;+&#9;|&#9;+&#9;|&#9;+&#9;|&#9;h&#9;&#9;</P>
<P>GE_ROP_TMAP_LMAP_ZTESTSET,&#9;&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;m&#9;|&#9;-&#9;|&#9;+&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;h&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_AFLAT,&#9;&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;f&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;l&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_AFLAT_ZSET,&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;f&#9;|&#9;-&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;l&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_AFLAT_ZTEST,&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;f&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;l&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_AFLAT_ZTESTSET,&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;f&#9;|&#9;+&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;l&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_AMAP,&#9;&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;m&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;m&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_AMAP_ZSET,&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;m&#9;|&#9;-&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;m&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_AMAP_ZTEST,&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;m&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;m&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_AMAP_ZTESTSET,&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;m&#9;|&#9;+&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;m&#9;&#9;</P>
<P>GE_ROP_TMAP_LMAP_AMAP,&#9;&#9;&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;m&#9;|&#9;m&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;l&#9;&#9;</P>
<P>GE_ROP_TMAP_LMAP_AMAP_ZSET,&#9;&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;m&#9;|&#9;m&#9;|&#9;-&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;l&#9;&#9;</P>
<P>GE_ROP_TMAP_LMAP_AMAP_ZTEST,&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;m&#9;|&#9;m&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;l&#9;&#9;</P>
<P>GE_ROP_TMAP_LMAP_AMAP_ZTESTSET,&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;m&#9;|&#9;m&#9;|&#9;+&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;l&#9;&#9;</P>
<P>GE_ROP_TMAP_LMAP_AFLAT_ZTESTSET,&#9;&#9;//&#9;|&#9;+&#9;|&#9;m&#9;|&#9;f&#9;|&#9;+&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;h&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_AMAP_AFLAT,&#9;&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;mf&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;m&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_AMAP_AFLAT_ZSET,&#9;&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;mf&#9;|&#9;-&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;m&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_AMAP_AFLAT_ZTEST,&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;mf&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;-&#9;|&#9;m&#9;&#9;</P>
<P>GE_ROP_TMAP_LSHADE_AMAP_AFLAT_ZTESTSET,&#9;//&#9;|&#9;+&#9;|&#9;g&#9;|&#9;mf&#9;|&#9;+&#9;|&#9;+&#9;|&#9;-&#9;|&#9;-&#9;|&#9;m&#9;&#9;</P>
<P>GE_ROP_END,</P>
<P>} geROP;</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070027">Softdrv.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  SoftDrv.H                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige                                                                */</P>
<P>/*  Description:  This is the API layer for the genesis software driver.                */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef SOFTDRV_H</P>
<P>#define SOFTDRV_H</P>

<P>#include "DCommon.h"</P>
<P>#include "Display.h"</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>extern DRV_Window&#9;&#9;&#9; ClientWindow;</P>

<P>extern Display&#9;&#9;&#9;&#9;*SD_Display;</P>
<P>extern geBoolean             SD_ProcessorHas3DNow;</P>
<P>extern geBoolean             SD_ProcessorHasMMX;</P>
<P>extern geBoolean&#9;&#9;&#9; SD_DIBDisplayMode;</P>
<P>extern geBoolean&#9;&#9;&#9; SD_Active;</P>
<P>extern DRV_Driver&#9;&#9;&#9; SOFTDRV;</P>
<P>extern int32&#9;&#9;&#9;&#9; RenderMode;</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070028">Span.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Span.H                                                                              */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige                                                                */</P>
<P>/*  Description:  Span abstracts and contains all the various ROP functions.            */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef SPAN_H</P>
<P>#define SPAN_H</P>

<P>#include "basetype.h"</P>
<P>#include "rop.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef void (GENESISCC *Span_DrawFunction)(void);</P>

<P>typedef enum </P>
<P>{</P>
<P>&#9;GE_SPAN_DESTINATION_FORMAT_555,</P>
<P>&#9;GE_SPAN_DESTINATION_FORMAT_565,</P>

<P>&#9;GE_SPAN_DESTINATION_FORMATS</P>
<P>} geSpan_DestinationFormat;</P>

<P>typedef enum</P>
<P>{</P>
<P>&#9;GE_SPAN_HARDWARE_INTEL,</P>
<P>&#9;GE_SPAN_HARDWARE_MMX,</P>
<P>&#9;GE_SPAN_HARDWARE_AMD,</P>

<P>&#9;GE_SPAN_HARDWARE_VERSIONS</P>
<P>} geSpan_CPU;</P>

<P>geBoolean GENESISCC Span_SetOutputMode( geSpan_DestinationFormat DestFormat, geSpan_CPU CPU);</P>

<P>Span_DrawFunction GENESISCC Span_GetDrawFunction(geROP ROP);</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070029">Span_AffineLoop.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Span_AffineLoop.H                                                                   */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige                                                                */</P>
<P>/*  Description:  This is a template to create multiple affine span line drawing        */</P>
<P>/*                routines.  See Span, Span_Factory                                     */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>while(i-- &gt; 0)</P>
<P>&#9;{</P>
<P>&#9;&#9;#if SPANROP &amp; ZTEST</P>
<P>&#9;&#9;ZFromMap = *(ZMapBits);</P>
<P>&#9;&#9;if (ZFromMap &gt; (Z&gt;&gt;16))</P>
<P>&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;{</P>
<P>&#9;&#9;&#9;&#9;#if SPANROP &amp; ZSET</P>
<P>&#9;&#9;&#9;&#9;*(ZMapBits++) = (ZMAPPIXEL)(Z&gt;&gt;16);</P>
<P>&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;#if SPANROP &amp; ZTEST</P>
<P>&#9;&#9;&#9;&#9;&#9;ZMapBits++;</P>
<P>&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;&#9;#if !(( SPANROP &amp; AFLAT) || (SPANROP &amp; AMAP))&#9;&#9;// NO alpha</P>
<P>&#9;&#9;&#9;&#9;&#9;#if (SPANROP &amp; TMAP) </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#ifdef TEST_LIGHTMAP</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Color = 0xFFFFFF;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Color = Palette[*(TextureBits + ((U&gt;&gt;16)&amp;UMask) + TOPDOWN_OR_BOTTOMUP(((V&gt;&gt;16)&amp;VMask) &lt;&lt; StrideShift))];</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#if SPANROP &amp; D565 </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#ifdef RGB</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) (&#9;((((Color&amp;0xFF)*R)&gt;&gt;15)&amp;0xF800) | (((((Color&amp;0xFF00)&gt;&gt;8)*G)&gt;&gt;20)&amp;0x7E0) | ((((Color&amp;0xFF0000)&gt;&gt;16)*B)&gt;&gt;26) );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) (&#9;((Color&amp;0xF8)&lt;&lt;8) /*R*/ | ((Color&amp;0xFC00)&gt;&gt;5) /*G*/ | ((Color&amp;0xF80000)&gt;&gt;19)/*B*/ );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#ifdef RGB</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) (&#9;((((Color&amp;0xFF)*R)&gt;&gt;16)&amp;0x7C00) | (((((Color&amp;0xFF00)&gt;&gt;8)*G)&gt;&gt;21)&amp;0x3E0) | ((((Color&amp;0xFF0000)&gt;&gt;16)*B)&gt;&gt;26) );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) (&#9;((Color&amp;0xF8)&lt;&lt;7) /*R*/ | ((Color&amp;0xF800)&gt;&gt;6) /*G*/ | ((Color&amp;0xF80000)&gt;&gt;19)/*B*/ );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#if SPANROP &amp; D565</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#ifdef RGB</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL)&#9;(  ((R&gt;&gt;(RGB_FXP_SHIFTER + 3))&lt;&lt;11) | ((G&gt;&gt;(RGB_FXP_SHIFTER + 2))&lt;&lt;5) | (B&gt;&gt;(RGB_FXP_SHIFTER + 3))  );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) Color;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#ifdef RGB</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL)(  ((R&gt;&gt;(RGB_FXP_SHIFTER + 3))&lt;&lt;10) | ((G&gt;&gt;(RGB_FXP_SHIFTER + 3))&lt;&lt;5) | (B&gt;&gt;(RGB_FXP_SHIFTER + 3))  );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) Color;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;&#9;#if (SPANROP &amp; AFLAT) || (SPANROP &amp; AMAP)&#9;&#9;// alpha map or alpha flat or both</P>
<P>&#9;&#9;&#9;&#9;&#9;{</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;int32 DColor,AR,AG,AB;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#if (SPANROP &amp; AMAP) &amp;&amp; (SPANROP &amp; AFLAT)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;int32 Alpha,OneMinusAlpha;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#endif </P>

<P>&#9;&#9;&#9;&#9;&#9;&#9;DColor = *DestBits;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#if SPANROP &amp; TMAP&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#if (SPANROP &amp; AMAP) </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Color = *( ((ALPHAMAPPIXEL *)TextureBits) + ((U&gt;&gt;16)&amp;UMask) + TOPDOWN_OR_BOTTOMUP(((V&gt;&gt;16)&amp;VMask) &lt;&lt; StrideShift));&#9;//4444 argb</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#ifdef RGB&#9;// alpha map and rgb shading</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (((Color &amp; 0xF00)&gt;&gt;8 ) * R) &gt;&gt;(4+RGB_FXP_SHIFTER);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (((Color &amp; 0x0F0)&gt;&gt;4 ) * G) &gt;&gt;(4+RGB_FXP_SHIFTER);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = ( (Color &amp; 0x00F)      * B) &gt;&gt;(4+RGB_FXP_SHIFTER);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else&#9;&#9;// alpha map only</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = ((Color &amp; 0xF00)&gt;&gt;4 ) ;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = ((Color &amp; 0x0F0)    ) ;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = ((Color &amp; 0x00F)&lt;&lt;4 ) ;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#if (SPANROP &amp; AFLAT)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Alpha  = ((Color&gt;&gt;12) * A)&gt;&gt;4;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;OneMinusAlpha = 16-Alpha;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;A = (Color&gt;&gt;12);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;OneMinusA = 16-A;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else&#9;// texture map without alpha</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Color = Palette[*(TextureBits + ((U&gt;&gt;16)&amp;UMask) + TOPDOWN_OR_BOTTOMUP(((V&gt;&gt;16)&amp;VMask) &lt;&lt; StrideShift))];&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#ifdef RGB</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (( Color &amp; 0xFF    )      * R) &gt;&gt;(8+RGB_FXP_SHIFTER);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (((Color &amp; 0xFF00  )&gt;&gt;8 ) * G) &gt;&gt;(8+RGB_FXP_SHIFTER);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = (((Color &amp; 0xFF0000)&gt;&gt;16) * B) &gt;&gt;(8+RGB_FXP_SHIFTER);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (Color &amp; 0xFF    );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (Color &amp; 0xFF00  )&gt;&gt;8;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = (Color &amp; 0xFF0000)&gt;&gt;16;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#else&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;// no texture</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#ifdef RGB&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = R &gt;&gt;RGB_FXP_SHIFTER;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = G &gt;&gt;RGB_FXP_SHIFTER;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = B &gt;&gt;RGB_FXP_SHIFTER;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (Color &amp; 0xFF    );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (Color &amp; 0xFF00  )&gt;&gt;8;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = (Color &amp; 0xFF0000)&gt;&gt;16; </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#if (SPANROP &amp; AMAP) &amp;&amp; (SPANROP &amp; AFLAT)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#if SPANROP &amp; D565</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (((DColor&amp;0xF800)&gt;&gt;8) * OneMinusAlpha) + (AR * Alpha);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (((DColor&amp;0x7E0)&gt;&gt;3)  * OneMinusAlpha) + (AG * Alpha);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = (((DColor&amp;0x1F)&lt;&lt;3)   * OneMinusAlpha) + (AB * Alpha);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) ( ( (AR&gt;&gt;7)&lt;&lt;11) | ( (AG&gt;&gt;6)&lt;&lt;5 ) | (AB&gt;&gt;7) );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (((DColor&amp;0x7C00)&gt;&gt;7) * OneMinusAlpha) + (AR * Alpha);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (((DColor&amp;0x3E0)&gt;&gt;2)  * OneMinusAlpha) + (AG * Alpha);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = (((DColor&amp;0x1F)&lt;&lt;3)   * OneMinusAlpha) + (AB * Alpha);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) ( ( (AR&gt;&gt;7)&lt;&lt;10) | ( (AG&gt;&gt;7)&lt;&lt;5 ) | (AB&gt;&gt;7) );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#if SPANROP &amp; D565</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (((DColor&amp;0xF800)&gt;&gt;8) * OneMinusA) + (AR * A);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (((DColor&amp;0x7E0)&gt;&gt;3)  * OneMinusA) + (AG * A);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = (((DColor&amp;0x1F)&lt;&lt;3)   * OneMinusA) + (AB * A);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) ( ( (AR&gt;&gt;7)&lt;&lt;11) | ( (AG&gt;&gt;6)&lt;&lt;5 ) | (AB&gt;&gt;7) );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (((DColor&amp;0x7C00)&gt;&gt;7) * OneMinusA) + (AR * A);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (((DColor&amp;0x3E0)&gt;&gt;2)  * OneMinusA) + (AG * A);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = (((DColor&amp;0x1F)&lt;&lt;3)   * OneMinusA) + (AB * A);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) ( ( (AR&gt;&gt;7)&lt;&lt;10) | ( (AG&gt;&gt;7)&lt;&lt;5 ) | (AB&gt;&gt;7) );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;&#9;&#9;}</P>
<P>&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;}</P>
<P>&#9;&#9;#if SPANROP &amp; ZTEST</P>
<P>&#9;&#9;else</P>
<P>&#9;&#9;&#9;{</P>
<P>&#9;&#9;&#9;&#9;ZMapBits++;</P>
<P>&#9;&#9;&#9;&#9;DestBits++;</P>
<P>&#9;&#9;&#9;}</P>
<P>&#9;&#9;#endif</P>
<P>&#9;</P>
<P>&#9;&#9;#if SPANROP &amp; TMAP</P>
<P>&#9;&#9;U += dU;</P>
<P>&#9;&#9;V += dV;</P>
<P>&#9;&#9;#endif</P>
<P>&#9;&#9;#ifdef RGB</P>
<P>&#9;&#9;R += dR;</P>
<P>&#9;&#9;G += dG;</P>
<P>&#9;&#9;B += dB;</P>
<P>&#9;&#9;#endif</P>
<P>&#9;&#9;#ifdef ZBUF</P>
<P>&#9;&#9;Z += dZ;</P>
<P>&#9;&#9;#endif</P>
<P>&#9;}</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070030">Span_Factory.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Span_AffineLoop.H                                                                   */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige                                                                */</P>
<P>/*  Description:  This is a template to create multiple affine span line drawing        */</P>
<P>/*                routines.  See Span, Span_Factory                                     */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>while(i-- &gt; 0)</P>
<P>&#9;{</P>
<P>&#9;&#9;#if SPANROP &amp; ZTEST</P>
<P>&#9;&#9;ZFromMap = *(ZMapBits);</P>
<P>&#9;&#9;if (ZFromMap &gt; (Z&gt;&gt;16))</P>
<P>&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;{</P>
<P>&#9;&#9;&#9;&#9;#if SPANROP &amp; ZSET</P>
<P>&#9;&#9;&#9;&#9;*(ZMapBits++) = (ZMAPPIXEL)(Z&gt;&gt;16);</P>
<P>&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;#if SPANROP &amp; ZTEST</P>
<P>&#9;&#9;&#9;&#9;&#9;ZMapBits++;</P>
<P>&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;&#9;#if !(( SPANROP &amp; AFLAT) || (SPANROP &amp; AMAP))&#9;&#9;// NO alpha</P>
<P>&#9;&#9;&#9;&#9;&#9;#if (SPANROP &amp; TMAP) </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#ifdef TEST_LIGHTMAP</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Color = 0xFFFFFF;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Color = Palette[*(TextureBits + ((U&gt;&gt;16)&amp;UMask) + TOPDOWN_OR_BOTTOMUP(((V&gt;&gt;16)&amp;VMask) &lt;&lt; StrideShift))];</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#if SPANROP &amp; D565 </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#ifdef RGB</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) (&#9;((((Color&amp;0xFF)*R)&gt;&gt;15)&amp;0xF800) | (((((Color&amp;0xFF00)&gt;&gt;8)*G)&gt;&gt;20)&amp;0x7E0) | ((((Color&amp;0xFF0000)&gt;&gt;16)*B)&gt;&gt;26) );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) (&#9;((Color&amp;0xF8)&lt;&lt;8) /*R*/ | ((Color&amp;0xFC00)&gt;&gt;5) /*G*/ | ((Color&amp;0xF80000)&gt;&gt;19)/*B*/ );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#ifdef RGB</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) (&#9;((((Color&amp;0xFF)*R)&gt;&gt;16)&amp;0x7C00) | (((((Color&amp;0xFF00)&gt;&gt;8)*G)&gt;&gt;21)&amp;0x3E0) | ((((Color&amp;0xFF0000)&gt;&gt;16)*B)&gt;&gt;26) );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) (&#9;((Color&amp;0xF8)&lt;&lt;7) /*R*/ | ((Color&amp;0xF800)&gt;&gt;6) /*G*/ | ((Color&amp;0xF80000)&gt;&gt;19)/*B*/ );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#if SPANROP &amp; D565</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#ifdef RGB</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL)&#9;(  ((R&gt;&gt;(RGB_FXP_SHIFTER + 3))&lt;&lt;11) | ((G&gt;&gt;(RGB_FXP_SHIFTER + 2))&lt;&lt;5) | (B&gt;&gt;(RGB_FXP_SHIFTER + 3))  );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) Color;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#ifdef RGB</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL)(  ((R&gt;&gt;(RGB_FXP_SHIFTER + 3))&lt;&lt;10) | ((G&gt;&gt;(RGB_FXP_SHIFTER + 3))&lt;&lt;5) | (B&gt;&gt;(RGB_FXP_SHIFTER + 3))  );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) Color;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;&#9;#if (SPANROP &amp; AFLAT) || (SPANROP &amp; AMAP)&#9;&#9;// alpha map or alpha flat or both</P>
<P>&#9;&#9;&#9;&#9;&#9;{</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;int32 DColor,AR,AG,AB;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#if (SPANROP &amp; AMAP) &amp;&amp; (SPANROP &amp; AFLAT)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;int32 Alpha,OneMinusAlpha;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#endif </P>

<P>&#9;&#9;&#9;&#9;&#9;&#9;DColor = *DestBits;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#if SPANROP &amp; TMAP&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#if (SPANROP &amp; AMAP) </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Color = *( ((ALPHAMAPPIXEL *)TextureBits) + ((U&gt;&gt;16)&amp;UMask) + TOPDOWN_OR_BOTTOMUP(((V&gt;&gt;16)&amp;VMask) &lt;&lt; StrideShift));&#9;//4444 argb</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#ifdef RGB&#9;// alpha map and rgb shading</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (((Color &amp; 0xF00)&gt;&gt;8 ) * R) &gt;&gt;(4+RGB_FXP_SHIFTER);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (((Color &amp; 0x0F0)&gt;&gt;4 ) * G) &gt;&gt;(4+RGB_FXP_SHIFTER);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = ( (Color &amp; 0x00F)      * B) &gt;&gt;(4+RGB_FXP_SHIFTER);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else&#9;&#9;// alpha map only</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = ((Color &amp; 0xF00)&gt;&gt;4 ) ;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = ((Color &amp; 0x0F0)    ) ;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = ((Color &amp; 0x00F)&lt;&lt;4 ) ;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#if (SPANROP &amp; AFLAT)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Alpha  = ((Color&gt;&gt;12) * A)&gt;&gt;4;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;OneMinusAlpha = 16-Alpha;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;A = (Color&gt;&gt;12);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;OneMinusA = 16-A;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else&#9;// texture map without alpha</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Color = Palette[*(TextureBits + ((U&gt;&gt;16)&amp;UMask) + TOPDOWN_OR_BOTTOMUP(((V&gt;&gt;16)&amp;VMask) &lt;&lt; StrideShift))];&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#ifdef RGB</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (( Color &amp; 0xFF    )      * R) &gt;&gt;(8+RGB_FXP_SHIFTER);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (((Color &amp; 0xFF00  )&gt;&gt;8 ) * G) &gt;&gt;(8+RGB_FXP_SHIFTER);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = (((Color &amp; 0xFF0000)&gt;&gt;16) * B) &gt;&gt;(8+RGB_FXP_SHIFTER);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (Color &amp; 0xFF    );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (Color &amp; 0xFF00  )&gt;&gt;8;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = (Color &amp; 0xFF0000)&gt;&gt;16;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#else&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;// no texture</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#ifdef RGB&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = R &gt;&gt;RGB_FXP_SHIFTER;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = G &gt;&gt;RGB_FXP_SHIFTER;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = B &gt;&gt;RGB_FXP_SHIFTER;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (Color &amp; 0xFF    );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (Color &amp; 0xFF00  )&gt;&gt;8;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = (Color &amp; 0xFF0000)&gt;&gt;16; </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#if (SPANROP &amp; AMAP) &amp;&amp; (SPANROP &amp; AFLAT)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#if SPANROP &amp; D565</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (((DColor&amp;0xF800)&gt;&gt;8) * OneMinusAlpha) + (AR * Alpha);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (((DColor&amp;0x7E0)&gt;&gt;3)  * OneMinusAlpha) + (AG * Alpha);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = (((DColor&amp;0x1F)&lt;&lt;3)   * OneMinusAlpha) + (AB * Alpha);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) ( ( (AR&gt;&gt;7)&lt;&lt;11) | ( (AG&gt;&gt;6)&lt;&lt;5 ) | (AB&gt;&gt;7) );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (((DColor&amp;0x7C00)&gt;&gt;7) * OneMinusAlpha) + (AR * Alpha);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (((DColor&amp;0x3E0)&gt;&gt;2)  * OneMinusAlpha) + (AG * Alpha);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = (((DColor&amp;0x1F)&lt;&lt;3)   * OneMinusAlpha) + (AB * Alpha);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) ( ( (AR&gt;&gt;7)&lt;&lt;10) | ( (AG&gt;&gt;7)&lt;&lt;5 ) | (AB&gt;&gt;7) );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#if SPANROP &amp; D565</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (((DColor&amp;0xF800)&gt;&gt;8) * OneMinusA) + (AR * A);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (((DColor&amp;0x7E0)&gt;&gt;3)  * OneMinusA) + (AG * A);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = (((DColor&amp;0x1F)&lt;&lt;3)   * OneMinusA) + (AB * A);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) ( ( (AR&gt;&gt;7)&lt;&lt;11) | ( (AG&gt;&gt;6)&lt;&lt;5 ) | (AB&gt;&gt;7) );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AR = (((DColor&amp;0x7C00)&gt;&gt;7) * OneMinusA) + (AR * A);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AG = (((DColor&amp;0x3E0)&gt;&gt;2)  * OneMinusA) + (AG * A);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AB = (((DColor&amp;0x1F)&lt;&lt;3)   * OneMinusA) + (AB * A);</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*(DestBits++) = (DESTPIXEL) ( ( (AR&gt;&gt;7)&lt;&lt;10) | ( (AG&gt;&gt;7)&lt;&lt;5 ) | (AB&gt;&gt;7) );</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;&#9;&#9;}</P>
<P>&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;}</P>
<P>&#9;&#9;#if SPANROP &amp; ZTEST</P>
<P>&#9;&#9;else</P>
<P>&#9;&#9;&#9;{</P>
<P>&#9;&#9;&#9;&#9;ZMapBits++;</P>
<P>&#9;&#9;&#9;&#9;DestBits++;</P>
<P>&#9;&#9;&#9;}</P>
<P>&#9;&#9;#endif</P>
<P>&#9;</P>
<P>&#9;&#9;#if SPANROP &amp; TMAP</P>
<P>&#9;&#9;U += dU;</P>
<P>&#9;&#9;V += dV;</P>
<P>&#9;&#9;#endif</P>
<P>&#9;&#9;#ifdef RGB</P>
<P>&#9;&#9;R += dR;</P>
<P>&#9;&#9;G += dG;</P>
<P>&#9;&#9;B += dB;</P>
<P>&#9;&#9;#endif</P>
<P>&#9;&#9;#ifdef ZBUF</P>
<P>&#9;&#9;Z += dZ;</P>
<P>&#9;&#9;#endif</P>
<P>&#9;}</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070031">SpanBuffer.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  SpanBuffer.H                                                                        */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige                                                                */</P>
<P>/*  Description:  This is a raster-line based span buffer (like a z buffer but it works */</P>
<P>/*                with groups of horizontal pixels, rather than single pixels)          */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef SPANBUFFER_H</P>
<P>#define SPANBUFFER_H</P>

<P>#include "basetype.h" </P>
<P> </P>
<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct </P>
<P>{&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// This is a clipped segment of a span.</P>
<P>&#9;int LeftOffset;&#9;&#9;&#9;&#9;&#9;// offset from starting pixel from original span (LeftStart)</P>
<P>&#9;int Width;&#9;&#9;&#9;&#9;&#9;&#9;// width of this segment</P>
<P>}  SpanBuffer_ClipSegment;&#9;&#9;</P>

<P>// this array holds the resulting clipped spans (segments) that result from calling _ClipAndAdd()</P>
<P>extern SpanBuffer_ClipSegment *SpanBuffer_Segments;</P>

<P>&nbsp;</P>
<P>&#9;// initializes the span buffer</P>
<P>geBoolean SpanBuffer_Create(int Width, int Height, int MaxSpans);</P>

<P>&#9;// destroys the span buffer</P>
<P>void SpanBuffer_Destroy(void);</P>

<P>&#9;// empties the span buffer</P>
<P>void&#9;SpanBuffer_Clear(void);</P>

<P>&#9;// adds a new span.  The span is specified by a starting pixel and a width(number of pixels)</P>
<P>&#9;//  The return value is the number of clipped spans (segments) to draw.  (0 if none)</P>
<P>&#9;//&#9;The clipped spans are put into the exported array (SpanBuffer_Segments[0..return value+1])</P>
<P>int&#9;&#9;SpanBuffer_ClipAndAdd(int Line, int LeftStart, int Width);</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070032">SpanEdges_Factory.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  SpanEdges_Factory.H                                                                 */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige                                                                */</P>
<P>/*  Description:  This is a template to create multiple function with similar structure,*/</P>
<P>/*                but with slightly different options.  This template creates           */</P>
<P>/*                edge-spanning functions for walking the edges of triangles, generating*/</P>
<P>/*                spans for each scan line.                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>// This generates various edge-spanning routines</P>
<P>//   The flag bits are</P>
<P>//     TMAP:   indicates texture mapping is used.  </P>
<P>//&#9;&#9;&#9;&#9;&#9;&#9;&#9;1/Z, U/Z, V/Z are stepped and prepared for the span routine</P>
<P>//     SBUF:   indicates span buffering is used.  SpanBuffer is queried and segments are generated.  </P>
<P>//&#9;&#9;&#9;&#9;&#9;&#9;&#9;1/Z, Y are stepped and prepared for the span routine</P>
<P>//     LSHADE: indicates gouraud rgb lighting is used.  </P>
<P>//&#9;&#9;&#9;&#9;&#9;&#9;&#9;R,G,B are stepped and prepared for the span routine</P>
<P>//&#9;   ZBUF:   indicates z buffering is used.  </P>
<P>//&#9;&#9;&#9;&#9;&#9;&#9;&#9;1/Z is stepped and prepared for the span routine</P>
<P>//    Combinations generate the (minimal) combination of stepping and preparation</P>

<P>&nbsp;</P>
<P>#ifndef SPANEDGES</P>
<P>error.  must define SPANEDGES for function creation options.</P>
<P>#endif</P>

<P>#define MAX_RGB_VALUE (255&lt;&lt;RGB_FXP_SHIFTER)</P>

<P>// void SpanEdges_xxx(int Height)</P>
<P>{</P>
<P>&#9;while(Height--) </P>
<P>&#9;{</P>
<P>&#9;&#9;Triangle.SpanWidth = Triangle.Right.X - Triangle.Left.X;</P>
<P>&#9;&#9;if (Triangle.SpanWidth&gt;0)</P>
<P>&#9;&#9;&#9;{</P>

<P>&#9;&#9;&#9;&#9;#if SPANEDGES &amp; SBUF</P>
<P>&#9;&#9;&#9;&#9;&#9;int Spans = SpanBuffer_ClipAndAdd(Triangle.Left.Y,Triangle.Left.X,Triangle.SpanWidth);</P>
<P>&#9;&#9;&#9;&#9;&#9;SpanBuffer_ClipSegment *Segment = &amp;(SpanBuffer_Segments[0]);</P>
<P>&#9;&#9;&#9;&#9;&#9;for (;Spans&gt;0; Spans--,Segment++)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;{</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Triangle.DestBits = ((DESTPIXEL *)Triangle.Left.Dest) + Segment-&gt;LeftOffset;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#if SPANEDGES &amp; TMAP</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Triangle.ZMapBits = ((ZMAPPIXEL *)(Triangle.Left.Dest + Triangle.ZBufferAddressDelta)) + Segment-&gt;LeftOffset;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#if (SPANEDGES &amp; TMAP) || (SPANEDGES &amp; ZBUF)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;OneOverZ = Triangle.Left.OneOverZ + Triangle.Gradients.dOneOverZdX * Segment-&gt;LeftOffset;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#if SPANEDGES &amp; TMAP</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;UOverZ   = Triangle.Left.UOverZ   + Triangle.Gradients.dUOverZdX   * Segment-&gt;LeftOffset;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;VOverZ   = Triangle.Left.VOverZ   + Triangle.Gradients.dVOverZdX   * Segment-&gt;LeftOffset;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#if (SPANEDGES &amp; LSHADE)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;R = Triangle.Left.R + Triangle.Gradients.dRdX * Segment-&gt;LeftOffset;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (R&lt;0) R=0; if (R&gt;MAX_RGB_VALUE) R=MAX_RGB_VALUE;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;G = Triangle.Left.G + Triangle.Gradients.dGdX * Segment-&gt;LeftOffset;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (G&lt;0) G=0; if (G&gt;MAX_RGB_VALUE) G=MAX_RGB_VALUE;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;B = Triangle.Left.B + Triangle.Gradients.dBdX * Segment-&gt;LeftOffset;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (B&lt;0) B=0; if (B&gt;MAX_RGB_VALUE) B=MAX_RGB_VALUE;&#9;</P>

<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Triangle.SpanWidth = Segment-&gt;Width;</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#if SPANEDGES &amp; LMAP</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (!Triangle.IsLightMapSetup)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TRaster_LightMapSetup();</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;TRaster_DrawSpan();</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;}</P>
<P>&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;#else</P>
<P>&#9;&#9;&#9;&#9;&#9;Triangle.DestBits = (DESTPIXEL *)Triangle.Left.Dest; </P>
<P>&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;#if SPANEDGES &amp; ZBUF</P>
<P>&#9;&#9;&#9;&#9;&#9;Triangle.ZMapBits = (ZMAPPIXEL *)(Triangle.Left.Dest + Triangle.ZBufferAddressDelta);</P>
<P>&#9;&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;&#9;&#9;#if SPANEDGES &amp; TMAP</P>
<P>&#9;&#9;&#9;&#9;&#9;UOverZ   = Triangle.Left.UOverZ;</P>
<P>&#9;&#9;&#9;&#9;&#9;VOverZ   = Triangle.Left.VOverZ;</P>
<P>&#9;&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;&#9;&#9;#if (SPANEDGES &amp; TMAP) || (SPANEDGES &amp; ZBUF)</P>
<P>&#9;&#9;&#9;&#9;&#9;OneOverZ = Triangle.Left.OneOverZ;</P>
<P>&#9;&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;&#9;&#9;#if (SPANEDGES &amp; LSHADE)</P>
<P>&#9;&#9;&#9;&#9;&#9;R = Triangle.Left.R;&#9;</P>
<P>&#9;&#9;&#9;&#9;&#9;if (R&lt;0) R=0; if (R&gt;MAX_RGB_VALUE) R=MAX_RGB_VALUE;&#9;</P>

<P>&#9;&#9;&#9;&#9;&#9;G = Triangle.Left.G;</P>
<P>&#9;&#9;&#9;&#9;&#9;if (G&lt;0) G=0; if (G&gt;MAX_RGB_VALUE) G=MAX_RGB_VALUE;&#9;</P>

<P>&#9;&#9;&#9;&#9;&#9;B = Triangle.Left.B;</P>
<P>&#9;&#9;&#9;&#9;&#9;if (B&lt;0) B=0; if (B&gt;MAX_RGB_VALUE) B=MAX_RGB_VALUE;&#9;</P>

<P>&#9;&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;&#9;&#9;#if SPANEDGES &amp; LMAP</P>
<P>&#9;&#9;&#9;&#9;&#9;if (!Triangle.IsLightMapSetup)</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;TRaster_LightMapSetup();</P>
<P>&#9;&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;&#9;&#9;TRaster_DrawSpan();</P>
<P>&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;}</P>

<P>&#9;&#9;// step left edge</P>
<P>&#9;&#9;Triangle.Left.X += Triangle.Left.XStep;&#9;&#9;&#9;  </P>
<P>&#9;&#9;Triangle.Left.Dest += Triangle.Left.DestStep; </P>
<P>&#9;&#9;Triangle.Left.Height--; </P>
<P>&#9;&#9;Triangle.Left.ErrorTerm += Triangle.Left.Numerator;&#9;&#9;&#9;</P>

<P>&#9;&#9;#if SPANEDGES &amp; TMAP</P>
<P>&#9;&#9;Triangle.Left.UOverZ += Triangle.Left.UOverZStep;&#9;&#9;&#9;</P>
<P>&#9;&#9;Triangle.Left.VOverZ += Triangle.Left.VOverZStep;&#9;&#9;</P>
<P>&#9;&#9;#endif</P>

<P>&#9;&#9;#if (SPANEDGES &amp; TMAP) || (SPANEDGES &amp; ZBUF)</P>
<P>&#9;&#9;Triangle.Left.OneOverZ  += Triangle.Left.OneOverZStep; </P>
<P>&#9;&#9;#endif</P>
<P>&#9;</P>

<P>&#9;&#9;#if SPANEDGES &amp; LSHADE</P>
<P>&#9;&#9;Triangle.Left.R += Triangle.Left.RStep; </P>
<P>&#9;&#9;Triangle.Left.G += Triangle.Left.GStep; </P>
<P>&#9;&#9;Triangle.Left.B += Triangle.Left.BStep;</P>
<P>&#9;&#9;#endif</P>

<P>&#9;&#9;#if SPANEDGES &amp; SBUF</P>
<P>&#9;&#9;Triangle.Left.Y ++;</P>
<P>&#9;&#9;#endif</P>

<P>&#9;&#9;if (Triangle.Left.ErrorTerm &gt;= Triangle.Left.Denominator) </P>
<P>&#9;&#9;&#9;{</P>
<P>&#9;&#9;&#9;&#9;Triangle.Left.X++; </P>
<P>&#9;&#9;&#9;&#9;Triangle.Left.Dest+=sizeof(DESTPIXEL); </P>
<P>&#9;&#9;&#9;&#9;Triangle.Left.ErrorTerm -= Triangle.Left.Denominator; </P>

<P>&#9;&#9;&#9;&#9;#if SPANEDGES &amp; TMAP</P>
<P>&#9;&#9;&#9;&#9;Triangle.Left.UOverZ    += Triangle.Left.dUOverZdX;&#9;</P>
<P>&#9;&#9;&#9;&#9;Triangle.Left.VOverZ    += Triangle.Left.dVOverZdX;</P>
<P>&#9;&#9;&#9;&#9;#endif</P>

<P>&#9;&#9;&#9;&#9;#if (SPANEDGES &amp; TMAP) || (SPANEDGES &amp; ZBUF)</P>
<P>&#9;&#9;&#9;&#9;Triangle.Left.OneOverZ  += Triangle.Left.dOneOverZdX;&#9;</P>
<P>&#9;&#9;&#9;&#9;#endif</P>

<P>&nbsp;</P>
<P>&#9;&#9;&#9;&#9;#if SPANEDGES &amp; LSHADE</P>
<P>&#9;&#9;&#9;&#9;Triangle.Left.R += Triangle.Left.dRdX; </P>
<P>&#9;&#9;&#9;&#9;Triangle.Left.G += Triangle.Left.dGdX; </P>
<P>&#9;&#9;&#9;&#9;Triangle.Left.B += Triangle.Left.dBdX;</P>
<P>&#9;&#9;&#9;&#9;#endif</P>
<P>&#9;&#9;&#9;}</P>

<P>&#9;&#9;// step right edge</P>
<P>&#9;&#9;Triangle.Right.X += Triangle.Right.XStep; </P>
<P>&#9;&#9;Triangle.Right.ErrorTerm += Triangle.Right.Numerator;</P>
<P>&#9;&#9;if (Triangle.Right.ErrorTerm &gt;= Triangle.Right.Denominator)&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;\</P>
<P>&#9;&#9;&#9;{&#9;</P>
<P>&#9;&#9;&#9;&#9;Triangle.Right.X++;  </P>
<P>&#9;&#9;&#9;&#9;Triangle.Right.ErrorTerm -= Triangle.Right.Denominator;</P>
<P>&#9;&#9;&#9;}&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;}</P>
<P>}</P>

<P>&nbsp;</P>
<P>#undef SPANEDGES</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070033">SWTHandle.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  SWTHandle.H                                                                         */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige, John Pollard                                                  */</P>
<P>/*  Description:  Manager for texture construction and available texture formats for    */</P>
<P>/*                the software driver                                                   */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef SWTHANDLE_H</P>
<P>#define SWTHANDLE_H</P>

<P>#include "DCommon.h"</P>
<P>#include "PixelFormat.h"</P>

<P>// THandle flags</P>
<P>#define THANDLE_UPDATE&#9;&#9;(1&lt;&lt;0)&#9;&#9;// Force a thandle to be uploaded to the card</P>
<P>#define&#9;THANDLE_TRANS&#9;&#9;(1&lt;&lt;2)&#9;&#9;// Texture has transparency</P>
<P>#define THANDLE_LOCKED&#9;&#9;(1&lt;&lt;3)&#9;&#9;// THandle is currently locked (invalid for rendering etc)</P>

<P>typedef struct geRDriver_THandle</P>
<P>{</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;Active, Width, Height, MipLevels;</P>
<P>&#9;geRDriver_PixelFormat&#9;PixelFormat;</P>
<P>&#9;uint16&#9;&#9;&#9;&#9;&#9;*BitPtr[16];//8 or 16</P>
<P>&#9;geRDriver_THandle&#9;&#9;*PalHandle;</P>
<P>&#9;geRDriver_THandle&#9;&#9;*AlphaHandle;</P>

<P>&#9;uint32&#9;&#9;&#9;&#9;&#9;Flags;</P>
<P>} geRDriver_THandle;</P>

<P>geBoolean&#9;&#9;&#9;DRIVERCC&#9;SWTHandle_EnumPixelFormats(DRV_ENUM_PFORMAT_CB *Cb, void *Context);</P>
<P>geBoolean&#9;&#9;&#9;&#9;&#9;&#9;SWTHandle_FreeAllTextureHandles(void);</P>
<P>geRDriver_THandle&#9;*DRIVERCC&#9;SWTHandle_CreateTexture(int32 Width, int32 Height, int32 NumMipLevels, const geRDriver_PixelFormat *PixelFormat);</P>
<P>geBoolean&#9;&#9;&#9;DRIVERCC&#9;SWTHandle_DestroyTexture(geRDriver_THandle *THandle);</P>

<P>geBoolean&#9;&#9;&#9;DRIVERCC&#9;SWTHandle_LockTextureHandle(geRDriver_THandle *THandle, int32 MipLevel, void **Data);</P>
<P>geBoolean&#9;&#9;&#9;DRIVERCC&#9;SWTHandle_UnLockTextureHandle(geRDriver_THandle *THandle, int32 MipLevel);</P>
<P>geBoolean&#9;&#9;&#9;DRIVERCC&#9;SWTHandle_GetInfo(geRDriver_THandle *THandle, int32 MipLevel, geRDriver_THandleInfo *Info);</P>

<P>geBoolean&#9;&#9;&#9;DRIVERCC&#9;SWTHandle_SetPalette(geRDriver_THandle *THandle, geRDriver_THandle *PalHandle);</P>
<P>geRDriver_THandle&#9;*DRIVERCC&#9;SWTHandle_GetPalette(geRDriver_THandle *THandle);</P>
<P>geBoolean&#9;&#9;&#9;DRIVERCC&#9;SWTHandle_SetAlpha(geRDriver_THandle *THandle, geRDriver_THandle *PalHandle);</P>
<P>geRDriver_THandle&#9;*DRIVERCC&#9;SWTHandle_GetAlpha(geRDriver_THandle *THandle);</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070034">traster.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  TRaster.H                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description:  API layer for Triangle Rasterizer                                     */</P>
<P>/*                                                                                      */</P>
<P>/*  Code fragments from Chris Hecker's texture mapping articles used with               */</P>
<P>/*  permission.  http://www.d6.com/users/checker                                        */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef TRASTER_H</P>
<P>#define TRASTER_H</P>
<P>//&#9; TRaster</P>
<P>//   Triangle Rasterizer</P>
<P>//</P>

<P>#include "basetype.h"</P>
<P>#include "rop.h"</P>
<P>#include "swthandle.h"&#9;&#9;&#9;// geRDriver_THandle</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define TRASTER_DEFAULT_MAX_AFFINE_SIZE (32)</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;unsigned short *BitPtr;&#9;&#9;&#9;&#9;&#9;&#9;// pointer to lightmap bits</P>
<P>&#9;int Height;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Lightmap Height</P>
<P>&#9;int Width;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Lightmap Width</P>
<P>&#9;float LightMapShiftU,LightMapShiftV;&#9;&#9;// Lightmap coordinates u (LMU) = (TextureU-LightMapShiftU)*LightMapScaleU</P>
<P>&#9;float LightMapScaleU,LightMapScaleV;&#9;&#9;// Lightmap coordinates v (LMV) = (TextureV-LightMapShiftV)*LightMapScaleV</P>
<P>&#9;int MipIndex;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Texture's mipping level</P>
<P>} TRaster_Lightmap;</P>

<P>&nbsp;</P>
<P>&#9;&#9;// Call this before calling _Rasterize</P>
<P>void GENESISCC TRaster_Setup(</P>
<P>&#9;&#9;int MaxAffineSize,&#9;&#9;&#9;&#9;&#9;&#9;// maximum width or height for a non-perspective corrected poly</P>
<P>&#9;&#9;geRDriver_THandle *Dest,&#9;&#9;&#9;&#9;// destination bitmap</P>
<P>&#9;&#9;geRDriver_THandle *ZBuffer,&#9;&#9;&#9;&#9;// zbuffer bitmap</P>
<P>&#9;&#9;void (*Callback)(TRaster_Lightmap *LM));// initialize lightmap callback </P>

<P>&#9;&#9;// expected ranges for pVertices elements:</P>
<P>&#9;&#9;//   x,y  (pretty much anything)  but these are in screen space...</P>
<P>&#9;&#9;//   z  (0..65536)  </P>
<P>&#9;&#9;//   r,g,b:  0..255</P>
<P>&#9;&#9;//   a: 0..255</P>
<P>&#9;&#9;//   pVertices expected in clockwise winding order.  Counter clockwise will not be rasterized.</P>
<P>void GENESISCC TRaster_Rasterize( </P>
<P>&#9;&#9;geROP ROP,&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// ROP (raster operation to use for this triangle)</P>
<P>&#9;&#9;geRDriver_THandle *Texture,&#9;&#9;&#9;&#9;// Texture to use (can be NULL if ROP doesn't use it)</P>
<P>&#9;&#9;int MipIndex,&#9;&#9;&#9;&#9;&#9;&#9;&#9;// index of MIP level to use. 0 is highest detail</P>
<P>&#9;&#9;const DRV_TLVertex &#9;*pVertices);&#9;&#9;// corners of the triangle (there must be 3 of these!)</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454070035">triangle.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Triangle.h                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige&#9;                                                            */</P>
<P>/*  Description:  Edge and Gradient calculations for triangle rasterizater              */</P>
<P>/*                                                                                      */</P>
<P>/*  Code fragments from Chris Hecker's texture mapping articles used with               */</P>
<P>/*  permission.  http://www.d6.com/users/checker                                        */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>&nbsp;</P>
<P>#ifndef TRIANGLE_H</P>
<P>#define TRIANGLE_H</P>

<P>#include "basetype.h"</P>
<P>#include "swthandle.h"&#9;&#9;&#9;// geRDriver_THandle</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>//#define NOISE_FILTER</P>

<P>#define USE_FIXED_POINT </P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#define OOZ_NUMERATOR_SHIFTER  (32)</P>
<P>#define OOZ_NUMERATOR     0xFFFFFFFF</P>
<P>/* oz 20 ooz 30 divprec 16 oozmulprec 8 ozmulprec 8  good. */</P>
<P>/* oz 20 ooz 26 divprec 16 oozmulprec 10 ozmulprec 6  good. */</P>
<P>/* oz 20 ooz 26 divprec 18 oozmulprec 12 ozmulprec 4  good. (small textures suffer a little)*/</P>

<P>//&#9;&#9;&#9;&#9;&#9;&#9;&#9; 32</P>
<P>#define OZ_FXP_SHIFTER /*________________   *     */  (20)&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>#define OOZ_FXP_SHIFTER       (26)&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;</P>

<P>#define OOZ_DIV_PRECISION_BITS (18)</P>

<P>#define OOZ_MULTIPLY_PRECISION_BITS   (12)</P>
<P>#define OZ_MULTIPLY_PRECISION_BITS    (4)&#9;&#9;&#9;&#9;// affects the accuracy to the nearest texel </P>

<P>#define OOZ_DIV_PREP_RSHIFT    (OOZ_FXP_SHIFTER - OOZ_DIV_PRECISION_BITS)&#9;&#9;&#9;&#9;</P>

<P>#define RGB_FXP_SHIFTER (15)&#9;</P>
<P>#define Z_FXP_SHIFTER (8)</P>

<P>#define Z_FXP_MULTIPLIER   ((float)( 1 &lt;&lt;   Z_FXP_SHIFTER ))&#9;</P>
<P>#define OOZ_FXP_MULTIPLIER ((float)( 1 &lt;&lt; OOZ_FXP_SHIFTER ))&#9;</P>
<P>#define OZ_FXP_MULTIPLIER  ((float)( 1 &lt;&lt;  OZ_FXP_SHIFTER )) </P>
<P>#define RGB_FXP_MULTIPLIER ((float)( 1 &lt;&lt; RGB_FXP_SHIFTER ))</P>

<P>#define OOZ_MUL_PREP_RSHIFT  (OOZ_NUMERATOR_SHIFTER - OOZ_FXP_SHIFTER + OOZ_DIV_PREP_RSHIFT - OOZ_MULTIPLY_PRECISION_BITS)&#9;&#9;</P>
<P>#define  OZ_MUL_PREP_RSHIFT  (OZ_FXP_SHIFTER - OZ_MULTIPLY_PRECISION_BITS)&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;</P>
<P>/* fixed point is used for the edge and span iterators.   </P>

<P>&#9;&#9;The 1/z (OOZ) iterator is stored with 6.26 precision.</P>
<P>&#9;&#9;The other 1/U iterators are stored with 12.20 precision.</P>
<P>&#9;&#9;(These were experimentially determined by minimizing the visible errors.)</P>

<P>&#9;&#9;(OOZ_NUMERATOR is ~= 0.32)</P>

<P>&#9;&#9;so, to compute a 16.16 fixed point U from 1/z and U/z</P>

<P>&#9;&#9; U  ={[(2^OZ_FXP_SHIFTER)/((1/z * 2^OOZ_FXP_SHIFTER)&gt;&gt;OOZ_DIV_PRE_RSHIFT)]&gt;&gt;OOZ_MUL_PREP_RSHIFT} * {[U/z * 2^OZ_FXP_SHIFTER]&gt;&gt;OZ_MUL_PRE_PRSHIFT}</P>

<P>&#9;&#9; U  ={[(2^32)/((1/z * 2^26)&gt;&gt;8)]&gt;&gt;2} * {[U/z * 2^20]&gt;&gt;16}</P>
<P>&#9;&#9;    ={[(2^32)/(   1/z * 2^18   ]&gt;&gt;2} * {   U/z * 2^4    }</P>
<P>&#9;&#9;    ={[       z * 2^14         ]&gt;&gt;2} * {   U/z * 2^4    }</P>
<P>&#9;&#9;&#9;={        z * 2^12             } * {   U/z * 2^4    }</P>
<P>&#9;&#9;&#9;=                        (z*U/z) * 2^16</P>
<P>&#9;&#9;&#9;=                              U * 2^16</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>*/</P>

<P>&nbsp;</P>
<P>#if OOZ_DIV_PREP_RSHIFT &gt; 0</P>
<P>&#9;#define OOZ_DIV_PREP(OOZ)   ((OOZ)&gt;&gt;OOZ_DIV_PREP_RSHIFT)</P>
<P>#else</P>
<P>&#9;#define OOZ_DIV_PREP(OOZ)   ((OOZ)&lt;&lt;(-OOZ_DIV_PREP_RSHIFT))</P>
<P>#endif</P>

<P>#if OZ_MUL_PREP_RSHIFT &gt; 0</P>
<P>&#9;#define OZ_MUL_PREP(OZ)&#9;&#9;((OZ)&gt;&gt;OZ_MUL_PREP_RSHIFT)   </P>
<P>#else</P>
<P>&#9;#define OZ_MUL_PREP(OZ)&#9;&#9;((OZ)&lt;&lt;(-OZ_MUL_PREP_RSHIFT))   </P>
<P>#endif</P>

<P>#if OOZ_MUL_PREP_RSHIFT &gt; 0</P>
<P>&#9;#define OOZ_MUL_PREP(OZ)&#9;((OZ)&gt;&gt;OOZ_MUL_PREP_RSHIFT)   </P>
<P>#else</P>
<P>&#9;#define OOZ_MUL_PREP(OZ)&#9;((OZ)&lt;&lt;(-OOZ_MUL_PREP_RSHIFT))   </P>
<P>#endif</P>

<P>#if (OOZ_MULTIPLY_PRECISION_BITS &gt; 8)</P>
<P>&#9;#define OOZ_MUL_Z(OOZ,Z)  ( ((OOZ)&gt;&gt;(OOZ_MULTIPLY_PRECISION_BITS-8)) * (Z) )</P>
<P>#else</P>
<P>&#9;#define OOZ_MUL_Z(OOZ,Z)  ( ((OOZ)&lt;&lt;(8-OOZ_MULTIPLY_PRECISION_BITS)) * (Z) )</P>
<P>#endif</P>

<P>#if (OOZ_MULTIPLY_PRECISION_BITS &gt; 8)</P>
<P>&#9;#define GRADIENT_OOZ_MUL_Z(OOZ,Z)  ( ((OOZ)&gt;&gt;(OOZ_FXPMULTIPLY_PRECISION_BITS-8)) * (Z) )</P>
<P>#else</P>
<P>&#9;#define GRADIENT_OOZ_MUL_Z(OOZ,Z)  ( ((OOZ)&lt;&lt;(8-OOZ_MULTIPLY_PRECISION_BITS)) * (Z) )</P>
<P>#endif</P>

<P>#if (OZ_MULTIPLY_SHIFTER &lt;0) || (OOZ_MULTIPLY_SHIFTER&lt;0)</P>
<P>&#9;error.  </P>
<P>#endif</P>

<P>#define USE_FIXED_POINT </P>
<P>#define DEST16BIT</P>

<P>#ifdef USE_FIXED_POINT</P>
<P>#define FXFL int32</P>
<P>#define FXFL_OOZ(XXX)   ((int32)((XXX) * OOZ_FXP_MULTIPLIER))</P>
<P>#define FXFL_OZ(XXX)    ((int32)((XXX) *  OZ_FXP_MULTIPLIER))</P>
<P>#define FXFL_RGB(XXX)   ((int32)((XXX) * RGB_FXP_MULTIPLIER))</P>
<P>#define FXFL_Z(XXX)     ((int32)((XXX) *   Z_FXP_MULTIPLIER))</P>
<P>#define OOZ_FXP_TO_16_16(XXX)  ( (XXX)&gt;&gt;(OOZ_FXP_SHIFTER-16) )</P>
<P>#define  OZ_FXP_TO_16_16(XXX)  ( (XXX)&gt;&gt;(OZ_FXP_SHIFTER-16)  )</P>
<P>#define     Z_FXP_TO_INT(XXX)  ( (XXX)&gt;&gt;Z_FXP_SHIFTER        )</P>
<P>#define RGB_FXP_TO_16_16(XXX)  (XXX)</P>
<P>#else</P>
<P>&#9;error.</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#define TEXTUREPIXEL&#9;unsigned char </P>
<P>#define LIGHTMAPPIXEL   unsigned char</P>
<P>#ifdef DEST16BIT</P>
<P>&#9;#define DESTPIXEL&#9;unsigned short</P>
<P>#else</P>
<P>&#9;#define DESTPIXEL&#9;unsigned char</P>
<P>#endif</P>
<P>#define ZMAPPIXEL&#9;&#9;unsigned short</P>
<P>#define ALPHAMAPPIXEL&#9;unsigned short</P>

<P>#define DESTPIXEL_SHIFTER (sizeof(DESTPIXEL)/2)</P>
<P>#ifdef USE_DIBS</P>
<P>#define TOPDOWN_OR_BOTTOMUP(XXX) (-(XXX))  // + for TOPDOWN, - for BOTTOMUP.</P>
<P>#else</P>
<P>#define TOPDOWN_OR_BOTTOMUP(XXX) ((XXX))  // + for TOPDOWN, - for BOTTOMUP.</P>
<P>#endif</P>

<P>// ROP FLAGS</P>
<P>#define TMAP&#9;&#9;0x1</P>
<P>#define LSHADE&#9;&#9;0x2</P>
<P>#define LFLAT&#9;&#9;0x4</P>
<P>#define LMAP        0x8</P>
<P>#define AFLAT&#9;&#9;0x10</P>
<P>#define AMAP&#9;&#9;0x20</P>
<P>#define ZSET&#9;&#9;0x40</P>
<P>#define ZTEST&#9;&#9;0x80</P>
<P>#define ZBUF&#9;&#9;0x100&#9;&#9;// any zbuffering</P>
<P>#define SBUF&#9;&#9;0x200</P>
<P>#define D565&#9;&#9;0x200&#9;&#9;// not really a rop flag, but used in generating spans</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#define TRASTER_SMALL_DIVIDE_TABLESIZE 129</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>typedef struct Triangle_Gradients </P>
<P>{</P>
<P>&#9;float OneOverZ[3];&#9;&#9;&#9;// 1/Z per vtx&#9;(if Affine Z per vtx)  Normalized!</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// all Z's stored here are normalized to [0..1]  see FZScale below</P>
<P>&#9;float UOverZ[3];&#9;&#9;&#9;// U/Z per vtx&#9;(if Affine U per vtx)  </P>
<P>&#9;float VOverZ[3];&#9;&#9;&#9;// V/Z per vtx&#9;(if Affine V per vtx)  </P>
<P>&#9;float FdOneOverZdX;&#9;&#9;&#9;// d(1/Z)/dX&#9;(if Affine dZ/dX )</P>
<P>&#9;float dOneOverZdY;&#9;&#9;&#9;// d(1/Z)/dY&#9;(if Affine dZ/dY )</P>
<P>&#9;float FdUOverZdX;&#9;&#9;&#9;// d(U/Z)/dX&#9;(if Affine dU/dX )</P>
<P>&#9;float dUOverZdY;&#9;&#9;&#9;// d(U/Z)/dY&#9;(if Affine dU/dY )</P>
<P>&#9;float FdVOverZdX;&#9;&#9;&#9;// d(V/Z)/dX&#9;(if Affine dV/dX )</P>
<P>&#9;float dVOverZdY;&#9;&#9;&#9;// d(V/Z)/dY&#9;(if Affine dV/dY )</P>

<P>&#9;int SubSpanWidth;&#9;&#9;&#9;// maximum affine subdivision width for this poly (power of 2)</P>
<P>&#9;int SubSpanShift;&#9;&#9;&#9;//   shift to divide by SubSpanLength   1&lt;&lt;SubSpanShift == SubSpanWidth</P>
<P>&#9;int Affine;&#9;&#9;&#9;&#9;&#9;// flag:  if true, then all gradients are NOT 1/Z, just Z</P>

<P>&#9;// lighting interpolation is always affine</P>
<P>&#9;float FdRdX;&#9;&#9;&#9;&#9;// dR/dX (the F means float, since there is a fixed point version of this also)</P>
<P>&#9;float  dRdY;&#9;&#9;&#9;&#9;// dR/dY  </P>
<P>&#9;float FdGdX;&#9;&#9;&#9;&#9;// dG/dX (the F means float, since there is a fixed point version of this also)</P>
<P>&#9;float  dGdY;&#9;&#9;&#9;&#9;// dG/dY  </P>
<P>&#9;float FdBdX;&#9;&#9;&#9;&#9;// dB/dX (the F means float, since there is a fixed point version of this also)</P>
<P>&#9;float  dBdY;&#9;&#9;&#9;&#9;// dB/dY  </P>

<P>&#9;FXFL dOneOverZdX;&#9;&#9;&#9;// fixed point FdOneOverZdX (FXFL_OOZ)&#9;&#9; see precision comments</P>
<P>&#9;FXFL dUOverZdX;&#9;&#9;&#9;&#9;// fixed point FdUOverZdX   (FXFL_OZ)</P>
<P>&#9;FXFL dVOverZdX;&#9;&#9;&#9;&#9;// fixed point FdVOverZdX   (FXFL_OZ)</P>
<P>&#9;FXFL dRdX;&#9;&#9;&#9;&#9;&#9;// fixed point FdRdX        (FXFL_RGB)</P>
<P>&#9;FXFL dGdX;&#9;&#9;&#9;&#9;&#9;// fixed point FdGdX        (FXFL_RGB)</P>
<P>&#9;FXFL dBdX;&#9;&#9;&#9;&#9;&#9;// fixed point FdBdX        (FXFL_RGB)</P>

<P>&#9;float FZScale;&#9;&#9;&#9;&#9;// Z is normalized to a max Z of 1.0.  so Normalized_Z = Z/FZScale;</P>
<P>&#9;FXFL  ZScale;&#9;&#9;&#9;&#9;// fixed point FZScale      (FXFL_Z)</P>
<P>} Triangle_Gradients;</P>

<P>&nbsp;</P>
<P>typedef struct Triangle_Edge</P>
<P>{</P>
<P>&#9;int32 X;&#9;&#9;&#9;&#9;&#9;// current X of edge pixel </P>
<P>&#9;int32 XStep;&#9;&#9;&#9;&#9;// X + XStep = X for next edge point</P>
<P>&#9;uint32 Dest;&#9;&#9;&#9;&#9;// current address into destination bits for edge pixel</P>
<P>&#9;int32 DestStep;&#9;&#9;&#9;&#9;// Dest + DestStep = Dest for next edge point</P>
<P>&#9;int32 Numerator, Denominator;// DDA fraction</P>
<P>&#9;int32 ErrorTerm;&#9;&#9;&#9;&#9;// DDA error</P>

<P>&#9;FXFL OneOverZ;&#9;&#9;&#9;&#9;// current 1/Z &#9; (if Gradients.Affine: Z)</P>
<P>&#9;FXFL OneOverZStep;&#9;&#9;&#9;// OneOverZ + OneOverZStep = 1/Z for next edge point</P>
<P>&#9;FXFL UOverZ;&#9;&#9;&#9;&#9;// current U/Z   (if Gradients.Affine: U)</P>
<P>&#9;FXFL UOverZStep;&#9;&#9;&#9;// UOneOverZ + UOverZStep = U/Z for next edge point</P>
<P>&#9;FXFL VOverZ;&#9;&#9;&#9;&#9;// V/Z and step     (if Gradients.Affine: V )</P>
<P>&#9;FXFL VOverZStep;&#9;&#9;&#9;// VOneOverZ + VOverZStep = V/Z for next edge point</P>
<P>&#9;FXFL R;&#9;&#9;&#9;&#9;&#9;&#9;// current R</P>
<P>&#9;FXFL RStep;&#9;&#9;&#9;&#9;&#9;// R + RStep = R for next edge point</P>
<P>&#9;FXFL G;&#9;&#9;&#9;&#9;&#9;&#9;// current G</P>
<P>&#9;FXFL GStep;&#9;&#9;&#9;&#9;&#9;// G + GStep = G for next edge point</P>
<P>&#9;FXFL B;&#9;&#9;&#9;&#9;&#9;&#9;// B</P>
<P>&#9;FXFL BStep;&#9;&#9;&#9;&#9;&#9;// B + BStep = B for next edge point</P>
<P>&#9;</P>
<P>&#9;// (these are copied from Gradients) </P>
<P>&#9;FXFL dOneOverZdX;&#9;</P>
<P>&#9;FXFL dUOverZdX; &#9;</P>
<P>&#9;FXFL dVOverZdX; &#9;</P>
<P>&#9;FXFL dRdX;&#9;&#9;&#9;</P>
<P>&#9;FXFL dGdX;&#9;&#9;&#9;</P>
<P>&#9;FXFL dBdX;&#9;&#9;&#9;</P>
<P>&#9;//--------</P>

<P>&#9;int Y;&#9;&#9;&#9;&#9;&#9;&#9;// current Y of edge pixel</P>
<P>&#9;int Height;&#9;&#9;&#9;&#9;&#9;// number of vertical pixels in this edge</P>

<P>} Triangle_Edge;</P>

<P>&nbsp;</P>
<P>#define Triangle_PaletteEntry uint32</P>

<P>typedef struct Triangle_Triangle</P>
<P>{</P>
<P>&#9;int ROPFlags;&#9;&#9;&#9;&#9;&#9;&#9;// bit flags for rop.</P>
<P>&#9;Triangle_Gradients Gradients;&#9;&#9;// Changes across the triangle with respect to the screen</P>
<P>&#9;Triangle_Edge Left;&#9;&#9;&#9;&#9;&#9;// current left edge of currently drawing triangle</P>
<P>&#9;Triangle_Edge Right;&#9;&#9;&#9;&#9;// current right edge of currently drawing triangle</P>
<P>&#9;</P>
<P>&#9;DESTPIXEL *DestBits;&#9;&#9;&#9;&#9;// pointer into destination bits at left edge of span to draw</P>
<P>&#9;TEXTUREPIXEL *TextureBits;&#9;&#9;&#9;// pointer to first scan line of texture bits</P>
<P>&#9;Triangle_PaletteEntry *Palette;&#9;&#9;// pointer to texture palette</P>
<P>&#9;int MipIndex;&#9;&#9;&#9;&#9;&#9;&#9;// mip level; index 0 is highest detail</P>
<P>&#9;int StrideShift;&#9;&#9;&#9;&#9;&#9;// Texture is always a power of two width.  This is the power.</P>

<P>&#9;int   SpanWidth;&#9;&#9;&#9;&#9;&#9;// Width in pixels of current span</P>

<P>&#9;int UMask;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Mask U by this for tiling</P>
<P>&#9;int VMask;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Mask V by this for tiling</P>
<P>&#9;</P>
<P>&#9;LIGHTMAPPIXEL *LightMapBits;&#9;&#9;// pointer to first scan line of light map bits as supplied by engine</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// scale a U or V down into the lightmap</P>
<P>&#9;int LightMapWidth;&#9;&#9;&#9;&#9;&#9;// in lightmap pixels (luxels)</P>
<P>&#9;int LightMapStride;&#9;&#9;&#9;&#9;&#9;// in bytes</P>
<P>&#9;int LightMapHeight;&#9;&#9;&#9;&#9;&#9;// in lightmap pixels (luxels)</P>
<P>&#9;int LightMapMaxU;&#9;&#9;&#9;&#9;&#9;// maximum lightmap U (in 16:16 fixed point)</P>
<P>&#9;int LightMapMaxV;&#9;&#9;&#9;&#9;&#9;// maximum lightmap V (in 16:16 fixed point)</P>
<P>&#9;int32 LightMapShiftU;&#9;&#9;&#9;&#9;&#9;&#9;// 16:16 shift such that LMU = (u-LightMapShiftU)*LightMapScaleU</P>
<P>&#9;int32 LightMapScaleU;&#9;&#9;&#9;&#9;&#9;&#9;// 8:8 multiplication such that LMU = (u-LightMapShiftU)*LightMapScaleU</P>
<P>&#9;int32 LightMapShiftV;&#9;&#9;&#9;&#9;&#9;&#9;// 16:16 shift such that LMV = (v-LightMapShiftV)*LightMapScaleV</P>
<P>&#9;int32 LightMapScaleV;&#9;&#9;&#9;&#9;&#9;&#9;// 8:8 multiplication such that LMV = (v-LightMapShiftV)*LightMapScaleV</P>

<P>&#9;ZMAPPIXEL *ZMapBits;&#9;&#9;&#9;&#9;// pointer into zmap bits at left edge of span to draw.</P>
<P>&#9;geRDriver_THandle *ZMap;&#9;&#9;&#9;// reference to currently selected zmap</P>
<P>&#9;geRDriver_THandle *DestMap;&#9;&#9;&#9;// reference to currently selected destination bitmap</P>
<P>&#9;int ZBufferAddressDelta;&#9;&#9;&#9;// Destination bitmap bits + ZBufferAddressDelta = Zbuffer bits</P>

<P>&#9;int SmallDivideTable[TRASTER_SMALL_DIVIDE_TABLESIZE];&#9;// for quick divides by 1..TRASTER_SMALL_DIVIDE_TABLESIZE</P>

<P>&#9;float MaxAffineSize;&#9;&#9;&#9;&#9;// if triangle is smaller than this, the rasterizer reverts to affine.</P>

<P>&#9;geBoolean IsLightMapSetup;&#9;&#9;&#9;// GE_TRUE if light map is already set up. </P>
<P>&#9;void (*LightMapSetup)();&#9;&#9;&#9;// called to set up lightmap </P>

<P>&#9;#ifdef NOISE_FILTER&#9;&#9;</P>
<P>&#9;int RandomIndex;&#9;&#9;&#9;&#9;&#9;// experimental: to reduce 16bit banding&#9;&#9;&#9;</P>
<P>&#9;int RandomTable[256];</P>
<P>&#9;unsigned char RandomTableIndex=0;</P>
<P>&#9;#endif</P>
<P>} Triangle_Triangle;</P>

<P>// Global used by span routines.  Not in Triangle for simplified asm addressing.</P>

<P>int32 OneOverZ,UOverZ,VOverZ;&#9;&#9;&#9;// Current 1/Z, U/Z, V/Z for left edge of span (and subspans)</P>
<P>int32 R,G,B;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Current R,G,B,A for left edge of span (and subspans) </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//  R = Red Channel, G = Green Channel, B = Blue Channel</P>
<P>int32 A,OneMinusA;&#9;&#9;&#9;&#9;&#9;&#9;//  A = Alpha Channel   A is 0..16    OneMinusA is 16..0</P>

<P>Triangle_Triangle Triangle;</P>

<P>&#9;// computes gradients for triangle.  </P>
<P>&#9;// Doesn't set any global variables (Triangle), but may reference them for mode info (sorry)</P>
<P>geBoolean GENESISCC Triangle_GradientsCompute( </P>
<P>&#9;&#9;&#9;&#9;&#9;Triangle_Gradients *G,&#9;&#9;&#9;// Gradients to compute (yeah, this is also global)</P>
<P>&#9;&#9;&#9;&#9;&#9;const DRV_TLVertex *pVertices,&#9;// vertex corners of triangle (U,V,R,G,B,etc are [0..1])</P>
<P>&#9;&#9;&#9;&#9;&#9;float TextureWidth,&#9;&#9;&#9;&#9;// Width of texture in pixels  (scale U up to [0..Width])</P>
<P>&#9;&#9;&#9;&#9;&#9;float TextureHeight);&#9;&#9;&#9;// Height of texture in pixels (scale V up to [0..Height])</P>

<P>&nbsp;</P>
<P>&#9;//&#9;computes gradients for an edge of the triangle.</P>
<P>&#9;//  Doesn't set or reference any global variables (Triangle).</P>
<P>void GENESISCC Triangle_EdgeCompute( </P>
<P>&#9;&#9;Triangle_Edge *E,&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Edge to compute</P>
<P>&#9;&#9;const Triangle_Gradients *Gradients,&#9;&#9;// Gradients to use (yeah, this is also global)</P>
<P>&#9;&#9;const DRV_TLVertex *pVertices,&#9;&#9;&#9;&#9;// vertex corners of triangle (U,V,R,G,B,etc are [0..1])</P>
<P>&#9;&#9;int Top,&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Index into pVertices for 'top' (smallest y) vertex </P>
<P>&#9;&#9;int Bottom,&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Index into pVertices for 'bottom' (greatest y) vertex</P>
<P>&#9;&#9;int IsLeftEdge);&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Flag:  is this on the left side of the triangle</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//   only x is computed for the right side</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#endif</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<I><P><A NAME="_Toc454070036">OpenSource/Source/Engine/Logo Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>The header files in this subdirectory are used to create the Genesis3D logo and it's "electrical" effect.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070037">electric.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  ELECTRIC.H                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Eli Boling                                                                  */</P>
<P>/*  Description: Animated electrical bolt special effect interface                      */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef&#9;ELECTRIC_H</P>
<P>#define ELECTRIC_H</P>

<P>#ifdef&#9;__cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#include "Genesis.h"</P>

<P>#define&#9;ELECTRIC_BOLT_REDDOMINANT&#9;0</P>
<P>#define&#9;ELECTRIC_BOLT_GREENDOMINANT&#9;1</P>
<P>#define&#9;ELECTRIC_BOLT_BLUEDOMINANT&#9;2</P>

<P>#pragma warning( disable : 4068 )</P>

<P>typedef struct&#9;_Electric_BoltEffect</P>
<P>{</P>
<P>&#9;int&#9;&#9;&#9;beInitialized;</P>
<P>&#9;int&#9;&#9;&#9;beNumPoints;</P>
<P>&#9;geFloat&#9;&#9;beWildness;</P>

<P>&#9;/* For rendering */</P>
<P>&#9;geVec3d&#9;&#9;beStart;</P>
<P>&#9;geVec3d&#9;&#9;beEnd;</P>

<P>&#9;/* For generating the geometry */</P>
<P>&#9;geVec3d&#9;*&#9;beCenterPoints;</P>
<P>&#9;geVec3d *&#9;beCurrentPoint;</P>

<P>&#9;geFloat&#9;&#9;beBaseColors[3];</P>
<P>&#9;geFloat&#9;&#9;beCurrentColors[3];</P>
<P>&#9;geFloat&#9;&#9;beBaseBlue;</P>
<P>&#9;int&#9;&#9;&#9;beDecayRate;</P>
<P>&#9;int&#9;&#9;&#9;beDominantColor;</P>

<P>&#9;int&#9;&#9;&#9;beWidth;</P>

<P>}&#9;_Electric_BoltEffect;</P>

<P>_Electric_BoltEffect * _Electric_BoltEffectCreate(</P>
<P>&#9;int &#9;&#9;&#9;&#9;&#9;NumPolys,&#9;/* Number of polys, must be power of 2 */</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;&#9;Width,&#9;&#9;/* Width in world units of the bolt */</P>
<P>&#9;geFloat &#9;&#9;&#9;&#9;Wildness);&#9;/* How wild the bolt is (0 to 1 inclusive) */</P>

<P>void _Electric_BoltEffectDestroy(_Electric_BoltEffect *Effect);</P>

<P>void _Electric_BoltEffectAnimate(</P>
<P>&#9;_Electric_BoltEffect *&#9;Effect,</P>
<P>&#9;const geVec3d *&#9;&#9;&#9;start,&#9;&#9;/* Starting point of the bolt */</P>
<P>&#9;const geVec3d *&#9;&#9;&#9;end);&#9;&#9;/* Ending point of the bolt */</P>

<P>void _Electric_BoltEffectRender(</P>
<P>&#9;geWorld *&#9;&#9;&#9;&#9;World,&#9;&#9;/* World to render for */</P>
<P>&#9;_Electric_BoltEffect *&#9;Effect,&#9;&#9;/* Bolt to render */</P>
<P>&#9;const geXForm3d *&#9;&#9;XForm);&#9;&#9;/* Transform of our point of view */</P>

<P>void _Electric_BoltEffectSetColorInfo(</P>
<P>&#9;_Electric_BoltEffect *&#9;Effect,</P>
<P>&#9;GE_RGBA *&#9;&#9;&#9;&#9;BaseColor,&#9;&#9;/* Base color of the bolt (2 colors should be the same */</P>
<P>&#9;int&#9;&#9;&#9;&#9;&#9;&#9;DominantColor);&#9;/* Which color is the one to leave fixed */</P>

<P>#ifdef&#9;__cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<I><P><A NAME="_Toc454070038">OpenSource/Source/Engine/Entities Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>The header files in this subdirectory are used to define entities in theGenesis3D world.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070039">Entities.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Entities.h                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Eli Boling / John Pollard                                                   */</P>
<P>/*  Description: EntitySet creation / Entity Compiler                                   */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_ENTITIES_H</P>
<P>#define GE_ENTITIES_H</P>

<P>#include &lt;Assert.h&gt;</P>
<P>#include &lt;Windows.h&gt;</P>

<P>#include "BaseType.h"</P>
<P>#include "Errorlog.h"</P>
<P>#include "Vec3d.h"</P>
<P>#include "System.h"</P>
<P>#include "World.h"</P>
<P>#include "Ram.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//=====================================================================================</P>
<P>//&#9;Defines / Structure defines</P>
<P>//=====================================================================================</P>
<P>// Enumerated types</P>
<P>typedef&#9;enum</P>
<P>{</P>
<P>&#9;TYPE_INT,</P>
<P>&#9;TYPE_FLOAT,</P>
<P>&#9;TYPE_COLOR,</P>
<P>&#9;TYPE_POINT,</P>
<P>&#9;TYPE_STRING,</P>
<P>&#9;TYPE_MODEL,</P>
<P>&#9;TYPE_STRUCT,</P>
<P>&#9;TYPE_PTR,</P>
<P>} geEntity_ClassType;</P>

<P>typedef struct&#9;geEntity_Class&#9;geEntity_Class;</P>

<P>// Fields within a geEntity_Class</P>
<P>typedef struct geEntity_Field</P>
<P>{</P>
<P>&#9;char&#9;&#9;&#9;&#9;&#9;*Name;&#9;&#9;&#9;&#9;&#9;// Name of the field</P>
<P>&#9;geEntity_Class&#9;&#9;&#9;*TypeClass;&#9;&#9;&#9;&#9;// Atomic class the defines field</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;Offset;&#9;&#9;&#9;&#9;&#9;// Offset in Entity's UserData</P>

<P>&#9;struct geEntity_Field&#9;*Next;&#9;&#9;&#9;&#9;&#9;// Next Field list</P>

<P>} geEntity_Field;</P>

<P>typedef&#9;struct geEntity_Class</P>
<P>{</P>
<P>&#9;char&#9;&#9;&#9;&#9;&#9;*Name;&#9;&#9;&#9;&#9;&#9;// Class Name</P>
<P>&#9;geEntity_ClassType&#9;&#9;Type;&#9;&#9;&#9;&#9;&#9;// Type of class</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;TypeSize;</P>
<P>&#9;geEntity_Field&#9;&#9;&#9;*Fields;&#9;&#9;&#9;&#9;// Fields in this Class</P>
<P>&#9;int32&#9;&#9;&#9;&#9;&#9;FieldSize;&#9;&#9;&#9;&#9;// Size of all fields</P>

<P>&#9;struct geEntity_Class&#9;*Next;</P>

<P>} geEntity_Class; </P>

<P>typedef struct geEntity_Epair</P>
<P>{</P>
<P>&#9;struct geEntity_Epair&#9;*Next;</P>
<P>&#9;char&#9;&#9;&#9;&#9;&#9;*Key;</P>
<P>&#9;char&#9;&#9;&#9;&#9;&#9;*Value;</P>
<P>} geEntity_Epair;</P>

<P>typedef struct geEntity</P>
<P>{</P>
<P>&#9;geEntity_Class&#9;&#9;&#9;*Class;&#9;&#9;&#9;&#9;&#9;// Class data</P>

<P>&#9;geEntity_Epair&#9;&#9;&#9;*Epairs;&#9;&#9;&#9;&#9;// Parsed epair list from entity string list</P>

<P>&#9;void&#9;&#9;&#9;&#9;&#9;*UserData;&#9;&#9;&#9;&#9;// User structure parsed from entity</P>
<P>} geEntity;</P>

<P>typedef struct geEntity_EntitySet</P>
<P>{</P>
<P>&#9;struct geEntity_EntitySet&#9;*Next;&#9;&#9;&#9;&#9;// Next entity in this set</P>
<P>&#9;struct geEntity_EntitySet&#9;*Current;&#9;&#9;&#9;// Current entity set as an iterator</P>

<P>&#9;geBoolean&#9;&#9;&#9;&#9;&#9;OwnsEntities;&#9;&#9;// GE_TRUE if </P>

<P>&#9;geEntity&#9;&#9;&#9;&#9;&#9;*Entity;&#9;&#9;&#9;// The entity</P>
<P>&#9;geEntity_Class&#9;&#9;&#9;&#9;*Classes;&#9;&#9;&#9;// List of classes for set</P>

<P>} geEntity_EntitySet;</P>

<P>&nbsp;</P>
<P>//=====================================================================================</P>
<P>//&#9;Function prototypes</P>
<P>//=====================================================================================</P>
<P>geBoolean&#9;Ent_WorldInit(geWorld *World);</P>
<P>void&#9;&#9;Ent_WorldShutdown(geWorld *World);</P>

<P>geEntity&#9;&#9;&#9;&#9;*geEntity_Create(void);</P>
<P>void&#9;&#9;&#9;&#9;&#9;geEntity_Destroy(geEntity *Entity);</P>
<P>geBoolean&#9;&#9;&#9;&#9;geEntity_GetModelNumForKey(geEntity *Entity, const char *Key, int32 *ModelNum);</P>
<P>geBoolean&#9;&#9;&#9;&#9;geEntity_AddEpair(geEntity *Entity, geEntity_Epair *Epair);</P>
<P>const char&#9;&#9;&#9;&#9;*geEntity_GetStringForKey(const geEntity *Entity, const char *Key);</P>
<P>geEntity_Epair&#9;&#9;&#9;*geEntity_EpairCreate(void);</P>
<P>void&#9;&#9;&#9;&#9;&#9;geEntity_EpairDestroy(geEntity_Epair *Epair);</P>
<P>geEntity_Field&#9;&#9;&#9;*geEntity_FieldCreate(const char *Name, int32 Offset, geEntity_Class *TypeClass);</P>
<P>void&#9;&#9;&#9;&#9;&#9;geEntity_FieldDestroy(geEntity_Field *Field);</P>
<P>geEntity_Class&#9;&#9;&#9;*geEntity_ClassCreate(geEntity_ClassType Type, const char *Name, int32 TypeSize);</P>
<P>void&#9;&#9;&#9;&#9;&#9;geEntity_ClassDestroy(geEntity_Class *Class);</P>
<P>geBoolean&#9;&#9;&#9;&#9;geEntity_ClassAddField(geEntity_Class&#9;*Class, geEntity_Field *Field);</P>
<P>geEntity_Field&#9;&#9;&#9;*geEntity_ClassFindFieldByName(geEntity_Class *Class, const char *Name);</P>
<P>geEntity_EntitySet&#9;&#9;*geEntity_EntitySetCreate(void);</P>
<P>void&#9;&#9;&#9;&#9;&#9;geEntity_EntitySetDestroy(geEntity_EntitySet *EntitySet);</P>
<P>geEntity_Class&#9;&#9;&#9;*geEntity_EntitySetFindClassByName(geEntity_EntitySet *Set, const char *Name);</P>
<P>geEntity&#9;&#9;&#9;&#9;*geEntity_EntitySetFindEntityByName(geEntity_EntitySet *EntitySet, const char *Name);</P>
<P>GENESISAPI void&#9;&#9;&#9;&#9;&#9;geEntity_GetName(const geEntity *Entity, char *Buff, int MaxLen);</P>
<P>geBoolean &#9;geEntity_EntitySetAddEntity(geEntity_EntitySet *EntitySet, geEntity *Entity);</P>
<P>GENESISAPI&#9;geEntity&#9;*geEntity_EntitySetGetNextEntity(geEntity_EntitySet *EntitySet, geEntity *Entity);</P>
<P>geBoolean&#9;&#9;&#9;&#9;geEntity_EntitySetAddClass(geEntity_EntitySet *EntitySet, geEntity_Class *Class);</P>
<P>geEntity_EntitySet&#9;&#9;*LoadEntitySet(const char *EntityData, int32 EntityDataSize);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454070040">OpenSource/Source/Engine/Font Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>The header files in this subdirectory are used to allow Truetype fonts in the Genesis3D world.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070041">Font.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  FONT.H                                                                              */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Thom Robertson                                                              */</P>
<P>/*  Description: Bitmapped font support interface                                       */</P>
<P>/*               This implementation supports any TrueType fonts provided by Windows    */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_FONT_H</P>
<P>#define GE_FONT_H</P>

<P>// includes</P>
<P>#include "genesis.h"</P>
<P>#include "basetype.h"</P>
<P>#include "bitmap.h"</P>
<P>// **************************</P>
<P>// to use this API:</P>

<P>// 2.  geFont_CreateFont().</P>

<P>// 3.  (Optionally) geFont_AddCharacters().</P>
<P>// 3A. Otherwise, IF you intend to use geFont_DrawText(), call geFont_AddBitmapBuffer().</P>

<P>// 4.  Between geEngine_BeginFrame() and geEngine_EndFrame(), and after geEngine_RenderWorld(),</P>
<P>//       geFont_DrawText(). You may call geFont_DrawTextToBitmap() anytime, though.</P>

<P>// 5.  When finished, geFont_Destroy().</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>//*************************************************************************************** </P>
<P>// these are bit flags for _DrawText(). Currently only _WORDWRAP is implemented, and without</P>
<P>// it, the function will still wrap, just not on word boundaries.</P>
<P>// Note that these will fail for non ascii fonts.</P>
<P>#define GE_FONT_WRAP                0x00000001  // wrap to fit inside the drawing rect</P>
<P>#define GE_FONT_WORDWRAP            0x00000002  // wrap on word boundaries</P>
<P>#define GE_FONT_JUST_RETURN_FIT     0x00000004  // returns number of characters that fit in drawing rectangle, WITHOUT drawing anything.</P>
<P>#define GE_FONT_JUSTIFY_RIGHT       0x00000008</P>
<P>#define GE_FONT_JUSTIFY_CENTER      0x00000010</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>// opaque structure headers.</P>
<P>typedef struct geFont geFont;&#9;&#9;&#9;// an instance of a font</P>

<P>&nbsp;</P>
<P>//*************************************************************************************** </P>
<P>GENESISAPI geFont *GENESISCC geFont_Create(const geEngine *Engine, const char *fontNameString, </P>
<P>                                               const int fontSize,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   const int fontWeight , const geBoolean antialiased) ;</P>
<P>   // Creates a font, and returns a pointer to it.</P>
<P>   // Pass in the string name of the TrueType font (case sensitive), and the height in pixels.</P>
<P>   </P>
<P>   // ARGUMENTS:</P>
<P>   // fontNameString - char pointer to a string containing the case sensitive name of the font.</P>
<P>   // fontSize - the pixel height of the requested font.</P>

<P>   // RETURNS:</P>
<P>   // success: pointer to the newly created font.</P>
<P>   // failure: NULL.</P>

<P>   // NOTE: the new font set has NO actual characters in it at first.  You must add characters</P>
<P>   // to it with the _AddCharacters() function before you can use the font.</P>
<P>   // NOTE: all fonts start out with a grayscale palette, with the range 0 to 128.</P>

<P>//*************************************************************************************** </P>
<P>GENESISAPI void GENESISCC geFont_CreateRef(geFont *font);</P>

<P>&nbsp;</P>
<P>//*************************************************************************************** </P>
<P>GENESISAPI void GENESISCC geFont_Destroy(geFont **font);</P>
<P>   // destroys a font.</P>

<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the font to be destroyed.</P>

<P>   // RETURNS:</P>
<P>   // nothing.</P>

<P>//*************************************************************************************** </P>
<P>GENESISAPI geBoolean GENESISCC geFont_AddCharacters(geFont *font, </P>
<P>                                                  unsigned char leastIndex, </P>
<P>                                                  unsigned char mostIndex</P>
<P>                                                  );</P>
<P>   // Adds a set of characters to the font defined by the ascii range passed in </P>
<P>   // (leastIndex and mostIndex, inclusive).</P>

<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the font to add characters to.</P>
<P>   // e - pointer to a valid geEngine.</P>
<P>   // leastIndex and mostIndex - the ASCII range of characters to add.</P>
<P>   // cellBuffer - an allocated hunk of ram to temproarily store the character image</P>
<P>   // bufferSize - length of the above buffer</P>

<P>   // RETURNS:</P>
<P>   // success: GE_TRUE.</P>
<P>   // failure: GE_FALSE.</P>

<P>   // NOTES:</P>
<P>   // This is the function that actually uses the</P>
<P>   // Win32 GetGlyphOutline() function to draw the character onto a geBitmap, which can be</P>
<P>   // blitted to the screen.</P>

<P>&nbsp;</P>
<P>//*******************************************************************************</P>
<P>GENESISAPI void GENESISCC geFont_DestroyBitmapBuffer( geFont *font );</P>
<P>   // destroys any valid "scratch-pad" buffer attached to the geFont.</P>
<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the geFont.</P>
<P>   //</P>
<P>   // NOTES:</P>
<P>   // you'll rarely need to call this function; it's called by geFont_Destroy() anyway.</P>
<P>   // Calling this function with a geFont that has no initialized buffer doesn't</P>
<P>   // hurt anything.</P>

<P>//*******************************************************************************</P>
<P>GENESISAPI geBoolean GENESISCC geFont_AddBitmapBuffer(</P>
<P>                                  geFont *font, const uint32 width, const uint32 height);</P>
<P>   // Adds a geBitmap to the geFont, to be used as a temporary "scratch-pad".  This is</P>
<P>   // required for using geFont_DrawText() when no characters have been added.</P>

<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the geFont to add a buffer to.</P>
<P>   // width and height - the size of the buffer to create.  Make sure this size is &gt;=</P>
<P>   // the biggest rectagle of text you'll want to write to the screen using this geFont</P>
<P>   // and DrawText().</P>

<P>   // RETURNS:</P>
<P>   // success: GE_TRUE.</P>
<P>   // failure: GE_FALSE.</P>

<P>   // NOTES:</P>
<P>   // You don't need to call this function IF you _AddCharacters() to this geFont.</P>
<P>   // You call this function for each geFont you need to use.  geFont's don't share buffers.</P>
<P>   // if you call this function on a geFont that already has a valid buffer, the buffer is</P>
<P>   // destroyed, and replaced by the new one.</P>

<P>//*************************************************************************************** </P>
<P>GENESISAPI geBoolean GENESISCC geFont_DrawText(geFont *font, const char *textString, </P>
<P>                                           const GE_Rect *Rect, const GE_RGBA *Color, </P>
<P>                                           uint32 flags, const GE_Rect *clipRect);</P>
<P>   // This is the function you put between geEngine_BeginFrame() and _EndFrame(), the function</P>
<P>   // that draws text to the screen.</P>

<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the font to draw with.  IF the font has NO characters in it</P>
<P>   //  (added by geFont_AddCharacters() ) then a different, more windows-intensive way is</P>
<P>   //  used to draw out the characters.</P>
<P>   // textString - pointer to the text string to output to the screen.</P>
<P>   // Rect - screen rectangle to place the text within.</P>
<P>   // Color - RGB color the text should be.</P>
<P>   // flags - a bitfield of GE_FONT_ values.</P>
<P>   // clipRect - pointer to a screen rectangle to clip the text to.  MAY BE NULL, in which</P>
<P>   // case the text is only clipped by the boundaries of the screen.</P>

<P>   // RETURNS:</P>
<P>   // success: GE_TRUE.</P>
<P>   // failure: GE_FALSE.</P>

<P>   // NOTES:</P>
<P>   // Assuming you've added characters to the font, characters which have NOT been added</P>
<P>   // WILL cause an assert if you try to draw them.  </P>
<P>   // Only GE_FONTSET_WORDWRAP is meaningfull right now.  Using any other flags will cause</P>
<P>   // an assert.</P>
<P>   // As stated above, you can use an entirely different way of creating a string, by</P>
<P>   // making a font with no characters in it.  This</P>
<P>   // jumps through Windows DIB hoops, and draws the text in a non-anti-aliased, but</P>
<P>   // (hopefully) more unicode-tolerant way (DrawText() ).</P>

<P>&nbsp;</P>
<P>//*************************************************************************************** </P>
<P>GENESISAPI geBoolean GENESISCC geFont_DrawTextToBitmap(geFont *font, const char *textString, </P>
<P>                                           const GE_Rect *Rect, const GE_RGBA *Color, </P>
<P>                                           uint32 flags, const GE_Rect *clipRect,</P>
<P>                                           geBitmap *targetBitmap);</P>
<P>   // This is the function you put between geEngine_BeginFrame() and _EndFrame(), the function</P>
<P>   // that draws text to the screen.</P>

<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the font to draw with.  IF the font has NO characters in it</P>
<P>   //  (added by geFont_AddCharacters() ) then a different, more windows-intensive way is</P>
<P>   //  used to draw out the characters.</P>
<P>   // textString - pointer to the text string to output to the screen.</P>
<P>   // Rect - screen rectangle to place the text within.</P>
<P>   // Color - RGB color the text should be.</P>
<P>   // flags - a bitfield of GE_FONT_ values.</P>
<P>   // clipRect - pointer to a screen rectangle to clip the text to.  MAY BE NULL, in which</P>
<P>   // case the text is only clipped by the boundaries of the screen.</P>
<P>   // targetBitmap - pointer to a target bitmap to draw the text into.  MAY NOT BE NULL,</P>
<P>   // and MUST BE GE_PIXELFORMAT_8BIT.</P>

<P>   // RETURNS:</P>
<P>   // success: GE_TRUE.</P>
<P>   // failure: GE_FALSE.</P>

<P>   // NOTES:</P>
<P>   // Assuming you've added characters to the font, characters which have NOT been added</P>
<P>   // WILL cause an assert if you try to draw them.  </P>
<P>   // Only GE_FONTSET_WORDWRAP is meaningfull right now.  Using any other flags will cause</P>
<P>   // an assert.</P>
<P>   // As stated above, you can use an entirely different way of creating a string, by</P>
<P>   // making a font with no characters in it.  This</P>
<P>   // jumps through Windows DIB hoops, and draws the text in a non-anti-aliased, but</P>
<P>   // (hopefully) more unicode-tolerant way (DrawText() ).</P>
<P>   // The Color argument is will be used to modify the existing palette of the targetBitmap</P>
<P>   // passed in.  Therefore, you won't be able to _DrawTextToBitmap() a red piece of text,</P>
<P>   // then a green piece, then a blue piece.  You'll end up with three lines of blue text.</P>

<P>&nbsp;</P>
<P>//*************************************************************************************** </P>
<P>GENESISAPI int32 GENESISCC geFont_GetStringPixelWidth (geFont *font, const char *textString);</P>
<P>GENESISAPI int32 GENESISCC geFont_GetStringPixelHeight(geFont *font, const char *textString);</P>
<P>   // These two functions return the pixel width and height of the string passed in.</P>

<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the font to draw with.</P>
<P>   // textString - pointer to the text string to output to the screen.</P>

<P>   // RETURNS:</P>
<P>   // success: a positive value in pixels.  IF the text passed in contains characters</P>
<P>   //          which haven't been added to the font yet, BUT other characters HAVE</P>
<P>   //          been added, the function asserts.</P>
<P>   // failure: -1.</P>
<P>   // NOTES:</P>
<P>   // these two functions assume no text wrapping!</P>

<P>//*************************************************************************************** </P>
<P>GENESISAPI geBitmap* GENESISCC geFont_GetBuffer(geFont *font);</P>
<P>   // This function returns a pointer to the drawing buffer contained by the font.</P>

<P>   // ARGUMENTS:</P>
<P>   // font - pointer to the font.</P>

<P>   // RETURNS:</P>
<P>   // a valid pointer to a geBitmap, OR NULL, signifying that the buffer wasn't initialized.</P>

<P>&nbsp;</P>
<P>//*************************************************************************************** </P>
<P>GENESISAPI geBoolean GENESISCC geFont_GetCharMap(geFont *font, uint8 character, GE_Rect *Rect, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; geBitmap **targetBitmap, int32 *fullWidth, int32 *fullHeight, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; int32 *offsetX, int32 *offsetY);</P>

<P>//*************************************************************************************** </P>
<P>GENESISAPI void GENESISCC geFont_EnableAntialiasing(geFont *font, const geBoolean anti);</P>
<P>//*************************************************************************************** </P>
<P>GENESISAPI geBoolean GENESISCC geFont_IsAntialiased(geFont *font);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>

<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070042">wgClip.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  WGCLIP.H                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Thom Robertson                                                              */</P>
<P>/*  Description: 2D rectangular clip testing support                                    */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_CLIP_H</P>
<P>#define GE_CLIP_H</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define GE_CLIP_CENTER 1</P>
<P>#define GE_CLIP_CORNER 0</P>
<P>#include&#9;"basetype.h"</P>
<P>#include&#9;"getypes.h"</P>

<P>//***************************************************************</P>
<P>// returns true if you need to draw at all.</P>
<P>GENESISAPI geBoolean GENESISCC CalculateClipping(</P>
<P>                           GE_Rect *artRect, int32 *resultX, int32 *resultY, </P>
<P>                           int32 x, int32 y,</P>
<P>                           const GE_Rect bounds, int32 type);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial"><P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070043">OpenSource/Source/Engine/Math Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>The header files in this subdirectory are the essential math routines used to create the Genesis3D world.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070044">Box.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  BOX.H                                                                               */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Jason Wood                                                                  */</P>
<P>/*  Description: Box is a 3D Oriented Bounding Box                                      */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>

<P>#if !defined (GE_BOX_H)</P>
<P>#define GE_BOX_H</P>

<P>#include "Vec3d.h"</P>
<P>#include "XForm3d.h"</P>

<P>typedef struct geBox</P>
<P>{</P>
<P>&#9;// all member variables are **PRIVATE**</P>
<P>&#9;// the Box's scales along the Box's local frame axes</P>

<P>&#9;float xScale, yScale, zScale;</P>

<P>&#9;// the Box's local frame origin lies at (0, 0, 0) in local space</P>
<P>&#9;//</P>
<P>&#9;// these are the scaled Box axes in the global frame</P>
<P>&#9; </P>
<P>&#9;geVec3d GlobalFrameAxes[3];</P>

<P>&#9;// the transformation that takes the Box's axes from local space</P>
<P>&#9;// to global space, and its inverse</P>

<P>&#9;geXForm3d Transform, TransformInv;</P>

<P>}geBox;</P>

<P>/////////////////////////////////////////////////////////////////////////////</P>
<P>// call this to set up a Box for the first time or when the Box's</P>
<P>// local frame axes scale(s) change</P>
<P>void geBox_Set(geBox* Box, float xScale, float yScale, float zScale, const geXForm3d* Transform);</P>

<P>&nbsp;</P>
<P>// call this to set the Box's transformation matrix (does not change the</P>
<P>// scales of the Box's local frame axes)</P>
<P>void geBox_SetXForm(geBox* Box, const geXForm3d* Transform);</P>

<P>&nbsp;</P>
<P>// returns GE_TRUE if the boxes overlap, GE_FALSE otherwise</P>
<P>geBoolean geBox_DetectCollisionBetween(const geBox* Box1, const geBox* Box2);</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070045">CRC32.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  CRC32.H                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description: CRC construction module                                                */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_CRC32_H</P>
<P>#define GE_CRC32_H</P>

<P>#include "basetype.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>extern uint32 CRC32_Array(const uint8 * buf,uint32 buflen);</P>

<P>extern uint32 CRC32_Start(void);</P>
<P>extern uint32 CRC32_Finish(uint32 crc);</P>

<P>extern uint32 CRC32_AddByte(uint32 crc,uint8 b);</P>
<P>extern uint32 CRC32_AddWord(uint32 crc,uint16 w);</P>
<P>extern uint32 CRC32_AddLong(uint32 crc,uint32 w);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif /* GE_CRC32_H */</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070046">ExtBox.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  EXTBOX.H                                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:                                                                             */</P>
<P>/*  Description: Axial aligned bounding box (extent box) support                        */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_EXTBOX_H</P>
<P>#define GE_EXTBOX_H</P>

<P>#include "basetype.h"</P>
<P>#include "vec3d.h"</P>

<P>#ifdef __cplusplus</P>
<P>&#9;extern "C" {</P>
<P>#endif</P>

<P>typedef struct geExtBox</P>
<P>{</P>
<P>&#9;geVec3d Min;</P>
<P>&#9;geVec3d Max;</P>
<P>} geExtBox;</P>

<P>// Set the values in a box</P>
<P>void GENESISCC geExtBox_Set (  geExtBox *B,</P>
<P>&#9;&#9;&#9;&#9;  geFloat X1,&#9;  geFloat Y1,&#9;  geFloat Z1,</P>
<P>&#9;&#9;&#9;&#9;  geFloat X2,&#9;  geFloat Y2,&#9;  geFloat Z2 );</P>

<P>// Test a box for validity ( non NULL and max &gt;= min )</P>
<P>geBoolean GENESISCC geExtBox_IsValid(  const geExtBox *B );</P>

<P>// Set box Min and Max to the passed point</P>
<P>void GENESISCC geExtBox_SetToPoint ( geExtBox *B, const geVec3d *Point );</P>

<P>// Extend a box to encompass the passed point</P>
<P>void GENESISCC geExtBox_ExtendToEnclose( geExtBox *B, const geVec3d *Point );</P>

<P>// Return result of box intersection.</P>
<P>// If no intersection, returns GE_FALSE and bResult is not modified.</P>
<P>// If intersection, returns GE_TRUE and fills bResult (if not NULL)</P>
<P>// with the intersected box,</P>
<P>// bResult may be one of b1 or b2.</P>
<P>// </P>
<P>geBoolean GENESISCC geExtBox_Intersection ( const geExtBox *B1, const geExtBox *B2, geExtBox *Result&#9;);</P>

<P>// computes union of b1 and b2 and returns in bResult.</P>
<P>void GENESISCC geExtBox_Union ( const geExtBox *B1, const geExtBox *B2, geExtBox *Result );</P>

<P>geBoolean GENESISCC geExtBox_ContainsPoint ( const geExtBox *B, const geVec3d  *Point );</P>

<P>void GENESISCC geExtBox_GetTranslation ( const geExtBox *B,       geVec3d *pCenter );</P>
<P>void GENESISCC geExtBox_SetTranslation (       geExtBox *B, const geVec3d *pCenter );</P>
<P>void GENESISCC geExtBox_Translate      (       geExtBox *B, geFloat DX, geFloat DY, geFloat DZ );</P>

<P>void GENESISCC geExtBox_GetScaling     ( const geExtBox *B,       geVec3d *pScale );</P>
<P>void GENESISCC geExtBox_SetScaling     (       geExtBox *B, const geVec3d *pScale );</P>
<P>void GENESISCC geExtBox_Scale          (       geExtBox *B, geFloat DX, geFloat DY,geFloat DZ );</P>

<P>//  Creates a box that encloses the entire area of a box that moves along linear path</P>
<P>void GENESISCC geExtBox_LinearSweep(&#9;const geExtBox *BoxToSweep, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *StartPoint, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *EndPoint, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;geExtBox *EnclosingBox );</P>

<P>// Collides a ray with box B.  The ray is directed, from Start to End.  </P>
<P>//   Only returns a ray hitting the outside of the box.  </P>
<P>//     on success, GE_TRUE is returned, and </P>
<P>//       if T is non-NULL, T is returned as 0..1 where 0 is a collision at Start, and 1 is a collision at End</P>
<P>//       if Normal is non-NULL, Normal is the surface normal of the box where the collision occured.</P>
<P>geBoolean GENESISCC geExtBox_RayCollision( const geExtBox *B, const geVec3d *Start, const geVec3d *End, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geFloat *T, geVec3d *Normal );</P>

<P>#ifdef __cplusplus</P>
<P>&#9;}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070047">QUATERN.H</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  QUATERN.H                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige                                                                */</P>
<P>/*  Description: Quaternion mathematical system interface                               */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_QUATERNION_H</P>
<P>#define GE_QUATERNION_H</P>

<P>/***************************************************************************</P>

<P>&#9;The quatern module contains basic support for a quaternion object.</P>

<P>&#9;quaternions are an extension of complex numbers that allows an</P>
<P>&#9;expression for rotation that can be easily interpolated.  geQuaternion_s are also </P>
<P>&#9;more numericaly stable for repeated rotations than matrices.</P>

<P>&#9;</P>
<P>&#9;A quaternion is a 4 element 'vector'  [w,x,y,z] where:</P>

<P>&#9;q = w + xi + yj + zk</P>
<P>&#9;i*i = -1</P>
<P>&#9;j*j = -1</P>
<P>&#9;k*k = -1</P>
<P>&#9;i*j = -j*i = k</P>
<P>&#9;j*k = -k*j = i</P>
<P>&#9;k*i = -i*k = j</P>
<P>&#9;q' (conjugate) = w - xi - yj - zk</P>
<P>&#9;||q|| (magnitude) = sqrt(q*q') = sqrt(w*w + x*x + y*y + z*z)</P>
<P>&#9;unit quaternion ||q|| == 1; this implies  q' == qinverse </P>
<P>&#9;quaternions are associative (q1*q2)*q3 == q1*(q2*q3)</P>
<P>&#9;quaternions are not commutative  q1*q2 != q2*q1</P>
<P>&#9;qinverse (inverse (1/q) ) = q'/(q*q')</P>
<P>&#9;</P>
<P>&#9;q can be expressed by w + xi + yj + zk or [w,x,y,z] </P>
<P>&#9;or as in this implementation (s,v) where s=w, and v=[x,y,z]</P>

<P>&#9;quaternions can represent a rotation.  The rotation is an angle t, around a </P>
<P>&#9;unit vector u.   q=(s,v);  s= cos(t/2);   v= u*sin(t/2).</P>

<P>&#9;quaternions can apply the rotation to a point.  let the point be p [px,py,pz],</P>
<P>&#9;and let P be a quaternion(0,p).  Protated = q*P*qinverse </P>
<P>&#9;( Protated = q*P*q' if q is a unit quaternion)</P>

<P>&#9;concatenation rotations is similar to matrix concatenation.  given two rotations</P>
<P>&#9;q1 and q2,  to rotate by q1, then q2:  let qc = (q2*q1), then the combined </P>
<P>&#9;rotation is given by qc*P*qcinverse (= qc*P*qc' if q is a unit quaternion)</P>

<P>&#9;multiplication: </P>
<P>&#9;q1 = w1 + x1i + y1j + z1k</P>
<P>&#9;q2 = w2 + x2i + y2j + z2k</P>
<P>&#9;q1*q2 = q3 =</P>
<P>&#9;&#9;&#9;(w1*w2 - x1*x2 - y1*y2 - z1*z2)     {w3}</P>
<P>&#9;        (w1*x2 + x1*w2 + y1*z2 - z1*y2)i&#9;{x3}</P>
<P>&#9;&#9;&#9;(w1*y2 - x1*z2 + y1*w2 + z1*x2)j    {y3}</P>
<P>&#9;&#9;&#9;(w1*z2 + x1*y2 + y1*x2 + z1*w2)k&#9;{z3}</P>

<P>&#9;also, </P>
<P>&#9;q1 = (s1,v1) = [s1,(x1,y1,z1)]</P>
<P>&#9;q2 = (s2,v2) = [s2,(x2,y2,z2)]</P>
<P>&#9;q1*q2 = q3&#9;=&#9;(s1*s2 - dot_product(v1,v2),&#9;&#9;&#9;{s3}</P>
<P>&#9;&#9;&#9;&#9;&#9;(s1*v2 + s2*v1 + cross_product(v1,v2))&#9;{v3}</P>

<P>&nbsp;</P>
<P>&#9;interpolation - it is possible (and sometimes reasonable) to interpolate between</P>
<P>&#9;two quaternions by interpolating each component.  This does not quarantee a </P>
<P>&#9;resulting unit quaternion, and will result in an animation with non-linear </P>
<P>&#9;rotational velocity.</P>

<P>&#9;spherical interpolation: (slerp) treat the quaternions as vectors </P>
<P>&#9;find the angle between them (w = arccos(q1 dot q2) ).</P>
<P>&#9;given 0&lt;=t&lt;=1,  q(t) = q1*(sin((1-t)*w)/sin(w) + q2 * sin(t*w)/sin(w).</P>
<P>&#9;since q == -q, care must be taken to rotate the proper way.  </P>

<P>&#9;this implementation uses the notation quaternion q = (quatS,quatV) </P>
<P>&#9;  where quatS is a scalar, and quatV is a 3 element vector.</P>

<P>********************************************/</P>

<P>#include "basetype.h"</P>
<P>#include "xform3d.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct </P>
<P>{</P>
<P>&#9;geFloat&#9;W;</P>
<P>&#9;geFloat   X,Y,Z;</P>
<P>&#9;//geVec3d   QuatV;</P>
<P>} geQuaternion;</P>

<P>&nbsp;</P>
<P>#define&#9;QUATERNION_PI&#9;(GE_PI)</P>

<P>geBoolean GENESISCC geQuaternion_IsValid( const geQuaternion *Q );</P>
<P>&#9;// return GE_TRUE if Q is non null and for has no NAN's in its components</P>

<P>void GENESISCC geQuaternion_Set( geQuaternion *Q, geFloat W, geFloat X, geFloat Y, geFloat Z);</P>
<P>&#9;// set quaternion components.  Doesn't normalize</P>
<P>void GENESISCC geQuaternion_SetVec3d( geQuaternion *Q, geFloat W, const geVec3d *V);</P>
<P>&#9;// set quaternion components.  Doesn't normalize</P>
<P>GENESISAPI void GENESISCC geQuaternion_SetFromAxisAngle(geQuaternion *Q, const geVec3d *Axis, geFloat Theta);</P>
<P>&#9;// set a quaternion from an axis and a rotation around the axis</P>
<P>geBoolean GENESISCC geQuaternion_GetAxisAngle(const geQuaternion *Q, geVec3d *Axis, geFloat *Theta);</P>
<P>&#9;// gets an axis and angle of rotation around the axis from a quaternion</P>
<P>&#9;// returns GE_TRUE if there is an axis.  </P>
<P>&#9;// returns GE_FALSE if there is no axis (and Axis is set to 0,0,0, and Theta is 0)</P>

<P>void GENESISCC geQuaternion_Get( const geQuaternion *Q, </P>
<P>&#9;&#9;&#9;&#9;&#9;geFloat *W, geFloat *X, geFloat *Y, geFloat *Z);</P>
<P>&#9;// get quaternion components into W,X,Y,Z</P>
<P>void GENESISCC geQuaternion_GetVec3d( const geQuaternion *Q, geFloat *W, geVec3d *V);</P>
<P>&#9;// get quaternion components into W and V</P>

<P>void GENESISCC geQuaternion_FromMatrix(</P>
<P>&#9;const geXForm3d&#9;&#9;*RotationMatrix,</P>
<P>&#9;      geQuaternion&#9;*QDest);</P>
<P>&#9;// takes upper 3 by 3 portion of matrix (rotation sub matrix) </P>
<P>&#9;// and generates a quaternion</P>

<P>GENESISAPI void GENESISCC geQuaternion_ToMatrix(</P>
<P>&#9;const geQuaternion&#9;*Q, </P>
<P>&#9;&#9;  geXForm3d&#9;&#9;*RotationMatrixDest);</P>
<P>&#9;// takes a unit quaternion and makes RotationMatrixDest an equivelant rotation xform.</P>
<P>&#9;// (any translation in RotationMatrixDest will be list)</P>

<P>void GENESISCC geQuaternion_Slerp(</P>
<P>&#9;const geQuaternion&#9;&#9;*Q0, </P>
<P>&#9;const geQuaternion&#9;&#9;*Q1, </P>
<P>&#9;geFloat&#9;&#9;&#9;&#9;&#9;T,&#9;&#9;</P>
<P>&#9;geQuaternion&#9;&#9;&#9;*QT);</P>
<P>&#9;// spherical interpolation between q0 and q1.   0&lt;=t&lt;=1 </P>
<P>&#9;// resulting quaternion is 'between' q0 and q1</P>
<P>&#9;// with t==0 being all q0, and t==1 being all q1.</P>
<P>&#9;// returns a quaternion with a positive W - always takes shortest route</P>
<P>&#9;// through the positive W domain.</P>

<P>void GENESISCC geQuaternion_SlerpNotShortest(</P>
<P>&#9;const geQuaternion&#9;&#9;*Q0, </P>
<P>&#9;const geQuaternion&#9;&#9;*Q1, </P>
<P>&#9;geFloat&#9;&#9;&#9;&#9;&#9;T,&#9;&#9;</P>
<P>&#9;geQuaternion&#9;&#9;&#9;*QT);</P>
<P>&#9;// spherical interpolation between q0 and q1.   0&lt;=t&lt;=1 </P>
<P>&#9;// resulting quaternion is 'between' q0 and q1</P>
<P>&#9;// with t==0 being all q0, and t==1 being all q1.</P>

<P>&nbsp;</P>
<P>void GENESISCC geQuaternion_Multiply(</P>
<P>&#9;const geQuaternion&#9;*Q1, </P>
<P>&#9;const geQuaternion&#9;*Q2, </P>
<P>&#9;geQuaternion&#9;&#9;&#9;*QProduct);</P>
<P>&#9;// multiplies q1 * q2, and places the result in q.</P>
<P>&#9;// no failure. &#9;renormalization not automatic</P>

<P>void GENESISCC geQuaternion_Rotate(</P>
<P>&#9;const geQuaternion&#9;*Q, </P>
<P>&#9;const geVec3d       *V, </P>
<P>&#9;geVec3d&#9;&#9;&#9;&#9;*VRotated);</P>
<P>&#9;// Rotates V by the quaternion Q, places the result in VRotated.</P>

<P>geBoolean GENESISCC geQuaternion_IsUnit(const geQuaternion *Q);</P>
<P>&#9;// returns GE_TRUE if q is a unit quaternion.  GE_FALSE otherwise.</P>

<P>GENESISAPI geFloat GENESISCC geQuaternion_Normalize(geQuaternion *Q);</P>
<P>&#9;// normalizes q to be a unit quaternion.  returns original magnitude of q</P>

<P>GENESISAPI void GENESISCC geQuaternion_Copy(const geQuaternion *QSrc, geQuaternion *QDst);</P>
<P>&#9;// copies quaternion QSrc into QDst</P>

<P>void GENESISCC geQuaternion_SetNoRotation(geQuaternion *Q);</P>
<P>&#9;// sets Q to be a quaternion with no rotation (like an identity matrix)</P>

<P>void GENESISCC geQuaternion_Ln(</P>
<P>&#9;const geQuaternion *Q, </P>
<P>&#9;geQuaternion *LnQ);</P>
<P>&#9;// ln(Q) for unit quaternion only!</P>

<P>void GENESISCC geQuaternion_Exp(</P>
<P>&#9;const geQuaternion *Q,</P>
<P>&#9;geQuaternion *ExpQ);</P>
<P>&#9;// exp(Q) for pure quaternion only!  (zero scalar part (W))</P>

<P>void GENESISCC geQuaternion_Scale(</P>
<P>&#9;const geQuaternion *Q,</P>
<P>&#9;geFloat Scale,</P>
<P>&#9;geQuaternion *QScaled);</P>
<P>&#9;// Q = Q * Scale  (result is not generally a unit quaternion!)</P>

<P>void GENESISCC geQuaternion_Add(</P>
<P>&#9;const geQuaternion *Q1,</P>
<P>&#9;const geQuaternion *Q2,</P>
<P>&#9;geQuaternion *QSum);</P>
<P>&#9;// QSum = Q1 + Q2  (result is not generally a unit quaternion!)</P>

<P>void GENESISCC geQuaternion_Subtract(</P>
<P>&#9;const geQuaternion *Q1, </P>
<P>&#9;const geQuaternion *Q2, </P>
<P>&#9;geQuaternion *QSum);</P>
<P>&#9;// QSum = Q1 - Q2  (result is not generally a unit quaternion!)</P>

<P>void GENESISCC geQuaternion_Inverse(const geQuaternion *Q, geQuaternion *QInv);</P>
<P>&#9;// sets QInv to the inverse of Q.  </P>

<P>geFloat GENESISCC geQuaternion_Magnitude(const geQuaternion *Q);</P>
<P>&#9;// returns Magnitude of Q.  </P>

<P>geBoolean GENESISCC geQuaternion_Compare( geQuaternion *Q1, geQuaternion *Q2, geFloat Tolerance );</P>
<P>&#9;// return GE_TRUE if quaternions differ elementwise by less than Tolerance.</P>

<P>&nbsp;</P>
<P>#ifndef NDEBUG</P>
<P>void GENESISCC geQuaternion_SetMaximalAssertionMode( geBoolean Enable );</P>
<P>#endif</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#endif // GE_QUATERNION_H</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070048">VEC3D.H</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  VEC3D.H                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:                                                                             */</P>
<P>/*  Description: 3D Vector interface                                                    */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_VEC3D_H</P>
<P>#define GE_VEC3D_H</P>

<P>#include "basetype.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;geFloat X, Y, Z;</P>
<P>} geVec3d;</P>

<P>#ifndef NDEBUG</P>
<P>GENESISAPI&#9;geFloat GENESISCC   geVec3d_GetElement(geVec3d *V, int Index);</P>
<P>#else</P>
<P>&#9;#define geVec3d_GetElement(Vector,Index)  (* ((&amp;((Vector)-&gt;X)) +  (Index) ))</P>
<P>#endif</P>

<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Set(geVec3d *V, geFloat X, geFloat Y, geFloat Z);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Get(const geVec3d *V, geFloat *X, geFloat *Y, geFloat *Z);</P>

<P>GENESISAPI geFloat GENESISCC&#9;geVec3d_DotProduct(const geVec3d *V1, const geVec3d *V2);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_CrossProduct(const geVec3d *V1, const geVec3d *V2, geVec3d *VResult);</P>
<P>GENESISAPI geBoolean GENESISCC&#9;geVec3d_Compare(const geVec3d *V1, const geVec3d *V2,geFloat tolarance);</P>
<P>GENESISAPI geFloat GENESISCC&#9;geVec3d_Normalize(geVec3d *V1);</P>
<P>GENESISAPI geBoolean GENESISCC &#9;geVec3d_IsNormalized(const geVec3d *V);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Scale(const geVec3d *VSrc, geFloat Scale, geVec3d *VDst);</P>
<P>GENESISAPI geFloat GENESISCC&#9;geVec3d_Length(const geVec3d *V1); </P>
<P>GENESISAPI geFloat GENESISCC&#9;geVec3d_LengthSquared(const geVec3d *V1);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Subtract(const geVec3d *V1, const geVec3d *V2, geVec3d *V1MinusV2);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Add(const geVec3d *V1, const geVec3d *V2,  geVec3d *VSum);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Copy(const geVec3d *Vsrc, geVec3d *Vdst);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Clear(geVec3d *V);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_Inverse(geVec3d *V);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_MA(geVec3d *V1, geFloat Scale, const geVec3d *V2, geVec3d *V1PlusV2Scaled);</P>
<P>GENESISAPI void GENESISCC&#9;&#9;geVec3d_AddScaled(const geVec3d *V1, const geVec3d *V2, geFloat Scale, geVec3d *V1PlusV2Scaled);</P>

<P>GENESISAPI geFloat GENESISCC&#9;&#9;geVec3d_DistanceBetween(const geVec3d *V1, const geVec3d *V2);&#9;// returns length of V1-V2&#9;</P>

<P>GENESISAPI geBoolean GENESISCC geVec3d_IsValid(const geVec3d *V);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070049">XFORM3D.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  XFORM3D.H                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:                                                                             */</P>
<P>/*  Description: 3D transform interface                                                 */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_XFORM_H</P>
<P>#define GE_XFORM_H</P>

<P>&nbsp;</P>
<P>#include "Vec3d.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct</P>
<P>{&#9;</P>
<P>&#9;geFloat AX,AY,AZ;&#9;// e[0][0],e[0][1],e[0][2]</P>
<P>&#9;geFloat BX,BY,BZ;&#9;// e[1][0],e[1][1],e[1][2]</P>
<P>&#9;geFloat CX,CY,CZ;&#9;// e[2][0],e[2][1],e[2][2]</P>
<P>&#9;geVec3d Translation;  // e[0][3],e[1][3],e[2][3]</P>
<P>&#9;//&#9;  0,0,0,1&#9;&#9;// e[3][0],e[3][1],e[3][2]</P>
<P>} geXForm3d;</P>

<P>/*   this is essentially a 'standard' 4x4 transform matrix,</P>
<P>     with the bottom row always 0,0,0,1</P>

<P>&#9;| AX, AY, AZ, Translation.X |  </P>
<P>&#9;| BX, BY, BZ, Translation.Y |  </P>
<P>&#9;| CX, CY, CZ, Translation.Z |  </P>
<P>&#9;|  0,  0,  0,      1        |  </P>
<P>*/</P>

<P>//  all geXForm3d_Set* functions return a right-handed transform.</P>

<P>#define GEXFORM3D_MINIMUM_SCALE (0.00001f)</P>

<P>&nbsp;</P>
<P>GENESISAPI void GENESISCC geXForm3d_Copy(</P>
<P>&#9;const geXForm3d *Src, </P>
<P>&#9;geXForm3d *Dst);</P>
<P>&#9;// copies Src to Dst.  </P>

<P>GENESISAPI geBoolean GENESISCC geXForm3d_IsValid(const geXForm3d *M);</P>
<P>&#9;// returns GE_TRUE if M is 'valid'  </P>
<P>&#9;// 'valid' means that M is non NULL, and there are no NAN's in the matrix.</P>

<P>GENESISAPI geBoolean GENESISCC geXForm3d_IsOrthonormal(const geXForm3d *M);</P>
<P>&#9;// returns GE_TRUE if M is orthonormal </P>
<P>&#9;// (if the rows and columns are all normalized (transform has no scaling or shearing)</P>
<P>&#9;// and is orthogonal (row1 cross row2 = row3 &amp; col1 cross col2 = col3)</P>
<P>&#9;// * does not check for right-handed convention *</P>

<P>GENESISAPI geBoolean GENESISCC geXForm3d_IsOrthogonal(const geXForm3d *M);</P>
<P>&#9;// returns GE_TRUE if M is orthogonal</P>
<P>&#9;// (row1 cross row2 = row3 &amp; col1 cross col2 = col3)</P>
<P>&#9;// * does not check for right-handed convention *</P>

<P>GENESISAPI void GENESISCC geXForm3d_Orthonormalize(geXForm3d *M);</P>
<P>&#9;// essentially removes scaling (or other distortions) from </P>
<P>&#9;// an orthogonal (or nearly orthogonal) matrix </P>
<P>&#9;// returns a right-handed matrix</P>

<P>&nbsp;</P>
<P>GENESISAPI void GENESISCC geXForm3d_SetIdentity(geXForm3d *M);&#9;&#9;&#9;</P>
<P>&#9;// sets M to an identity matrix (clears it)</P>
<P>&#9;</P>
<P>GENESISAPI void GENESISCC geXForm3d_SetXRotation(geXForm3d *M,geFloat RadianAngle);</P>
<P>&#9;// sets up a transform that rotates RadianAngle about X axis</P>
<P>&#9;// all existing contents of M are replaced</P>
<P>&#9;</P>
<P>GENESISAPI void GENESISCC geXForm3d_SetYRotation(geXForm3d *M,geFloat RadianAngle);</P>
<P>&#9;// sets up a transform that rotates RadianAngle about Y axis</P>
<P>&#9;// all existing contents of M are replaced</P>

<P>GENESISAPI void GENESISCC geXForm3d_SetZRotation(geXForm3d *M,geFloat RadianAngle);</P>
<P>&#9;// sets up a transform that rotates RadianAngle about Z axis</P>
<P>&#9;// all existing contents of M are replaced</P>

<P>GENESISAPI void GENESISCC geXForm3d_SetTranslation(geXForm3d *M,geFloat x, geFloat y, geFloat z);</P>
<P>&#9;// sets up a transform that translates x,y,z</P>
<P>&#9;// all existing contents of M are replaced</P>

<P>GENESISAPI void GENESISCC geXForm3d_SetScaling(geXForm3d *M,geFloat x, geFloat y, geFloat z);</P>
<P>&#9;// sets up a transform that scales by x,y,z</P>
<P>&#9;// all existing contents of M are replaced</P>

<P>GENESISAPI void GENESISCC geXForm3d_RotateX(geXForm3d *M,geFloat RadianAngle);  </P>
<P>&#9;// Rotates M by RadianAngle about X axis   </P>
<P>&#9;// applies the rotation to the existing contents of M</P>

<P>GENESISAPI void GENESISCC geXForm3d_RotateY(geXForm3d *M,geFloat RadianAngle);</P>
<P>&#9;// Rotates M by RadianAngle about Y axis</P>
<P>&#9;// applies the rotation to the existing contents of M</P>

<P>GENESISAPI void GENESISCC geXForm3d_RotateZ(geXForm3d *M,geFloat RadianAngle);</P>
<P>&#9;// Rotates M by RadianAngle about Z axis</P>
<P>&#9;// applies the rotation to the existing contents of M</P>

<P>GENESISAPI void GENESISCC geXForm3d_Translate(geXForm3d *M,geFloat x, geFloat y, geFloat z);&#9;</P>
<P>&#9;// Translates M by x,y,z</P>
<P>&#9;// applies the translation to the existing contents of M</P>

<P>GENESISAPI void GENESISCC geXForm3d_Scale(geXForm3d *M,geFloat x, geFloat y, geFloat z);&#9;&#9;</P>
<P>&#9;// Scales M by x,y,z</P>
<P>&#9;// applies the scale to the existing contents of M</P>

<P>GENESISAPI void GENESISCC geXForm3d_Multiply(</P>
<P>&#9;const geXForm3d *M1, </P>
<P>&#9;const geXForm3d *M2, </P>
<P>&#9;geXForm3d *MProduct);</P>
<P>&#9;// MProduct = matrix multiply of M1*M2</P>
<P>&#9;// Concatenates the transformation in the M2 matrix onto the transformation in M1</P>

<P>GENESISAPI void GENESISCC geXForm3d_Transform(</P>
<P>&#9;const geXForm3d *M,</P>
<P>&#9;const geVec3d *V, </P>
<P>&#9;geVec3d *Result);</P>
<P>&#9;// Result is Matrix M * Vector V:  V Tranformed by M</P>

<P>GENESISAPI void GENESISCC geXForm3d_TransformArray(&#9;const geXForm3d *XForm, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Source, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *Dest, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 Count);</P>

<P>GENESISAPI void GENESISCC geXForm3d_Rotate(</P>
<P>&#9;const geXForm3d *M,</P>
<P>&#9;const geVec3d *V, </P>
<P>&#9;geVec3d *Result);</P>
<P>&#9;// Result is Matrix M * Vector V:  V Rotated by M (no translation)</P>

<P>&nbsp;</P>
<P>/***</P>
<P>*</P>
<P>&#9;"Left,Up,In" are just the basis vectors in the new coordinate space.</P>
<P>&#9;You can get them by multiplying the unit bases into the transforms.</P>
<P>*</P>
<P>******/</P>

<P>GENESISAPI void GENESISCC geXForm3d_GetLeft(const geXForm3d *M, geVec3d *Left);</P>
<P>&#9;// Gets a vector that is 'left' in the frame of reference of M (facing -Z)</P>

<P>GENESISAPI void GENESISCC geXForm3d_GetUp(const geXForm3d *M,    geVec3d *Up);</P>
<P>&#9;// Gets a vector that is 'up' in the frame of reference of M (facing -Z)</P>

<P>GENESISAPI void GENESISCC geXForm3d_GetIn(const geXForm3d *M,  geVec3d *In);</P>
<P>&#9;// Gets a vector that is 'in' in the frame of reference of M (facing -Z)</P>

<P>GENESISAPI void GENESISCC geXForm3d_GetTranspose(const geXForm3d *M, geXForm3d *MTranspose);</P>
<P>&#9;// Gets the Transpose transform of M   (M^T) </P>
<P>&#9;// Transpose of a matrix is the switch of the rows and columns</P>
<P>&#9;// The transpose is usefull because it is rapidly computed and is equal to the inverse </P>
<P>&#9;// transform for orthonormal transforms    [inverse is (M')  where M*M' = Identity ]</P>

<P>GENESISAPI void GENESISCC geXForm3d_TransposeTransform(</P>
<P>&#9;const geXForm3d *M, </P>
<P>&#9;const geVec3d *V, </P>
<P>&#9;geVec3d *Result);</P>
<P>&#9;// applies the transpose transform of M to V.  Result = (M^T) * V</P>

<P>/*****</P>
<P>*</P>
<P>&#9;the Euler angles are subsequent rotations :</P>
<P>&#9;&#9;by Angles-&gt;Z around the Z axis</P>
<P>&#9;&#9;then by Angles-&gt;Y around the Y axis, in the newly rotate coordinates</P>
<P>&#9;&#9;then by Angles-&gt;X around the X axis</P>
<P>*</P>
<P>******/&#9;</P>

<P>GENESISAPI void GENESISCC geXForm3d_GetEulerAngles(const geXForm3d *M, geVec3d *Angles);</P>
<P>&#9;// Finds Euler angles from M and puts them into Angles</P>
<P>&#9;</P>
<P>GENESISAPI void GENESISCC geXForm3d_SetEulerAngles(geXForm3d *M, const geVec3d *Angles);</P>
<P>&#9;// Applies Euler angles to build M</P>

<P>GENESISAPI void GENESISCC geXForm3d_SetFromLeftUpIn(</P>
<P>&#9;geXForm3d *M,</P>
<P>&#9;const geVec3d *Left, </P>
<P>&#9;const geVec3d *Up, </P>
<P>&#9;const geVec3d *In);</P>
<P>&#9;// Builds an geXForm3d from orthonormal Left, Up and In vectors</P>

<P>GENESISAPI void GENESISCC geXForm3d_Mirror(</P>
<P>&#9;const&#9;&#9;geXForm3d *Source, </P>
<P>&#9;const&#9;&#9;geVec3d *PlaneNormal, </P>
<P>&#9;float&#9;&#9;PlaneDist, </P>
<P>&#9;geXForm3d&#9;*Dest);</P>
<P>&#9;// Mirrors a XForm3d about a plane</P>

<P>&nbsp;</P>
<P>//--------------</P>

<P>#ifndef NDEBUG</P>
<P>&#9;GENESISAPI &#9;void GENESISCC geXForm3d_SetMaximalAssertionMode( geBoolean Enable );</P>
<P>#else</P>
<P>&#9;#define geXForm3d_SetMaximalAssertionMode(Enable)</P>
<P>#endif</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>

<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454070050">OpenSource/Source/Engine/Support Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>The header files in this subdirectory are used to allow Truetype fonts in the Genesis3D world.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070051">BASETYPE.H</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  BASETYPE.H                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:                                                                             */</P>
<P>/*  Description: Basic type definitions and calling convention defines                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_BASETYPE_H</P>
<P>#define GE_BASETYPE_H</P>
<P> </P>
<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>/******** The Genesis Calling Conventions ***********/ </P>

<P>#define&#9;GENESISCC&#9;_fastcall</P>

<P>#if&#9;defined(BUILDGENESIS) &amp;&amp; defined(GENESISDLLVERSION)</P>
<P>  #define GENESISAPI&#9;_declspec(dllexport)</P>
<P>#else</P>
<P>  #if&#9;defined(GENESISDLLVERSION)</P>
<P>    #define GENESISAPI&#9;_declspec(dllimport)</P>
<P>  #else</P>
<P>    #define GENESISAPI</P>
<P>  #endif</P>
<P>#endif</P>

<P>/******** The Basic Types ****************************/</P>

<P>typedef signed int geBoolean;</P>
<P>#define GE_FALSE&#9;(0)</P>
<P>#define GE_TRUE&#9;&#9;(1)</P>

<P>typedef float geFloat;</P>

<P>#ifndef NULL</P>
<P>#define NULL&#9;((void *)0)</P>
<P>#endif</P>

<P>typedef signed long     int32;</P>
<P>typedef signed short    int16;</P>
<P>typedef signed char     int8 ;</P>
<P>typedef unsigned long  uint32;</P>
<P>typedef unsigned short uint16;</P>
<P>typedef unsigned char  uint8 ;</P>

<P>/******** Macros on Genesis basic types *************/</P>

<P>#define GE_ABS(x)&#9;&#9;&#9;&#9;( (x) &lt; 0 ? (-(x)) : (x) )</P>
<P>#define GE_CLAMP(x,lo,hi)&#9;&#9;( (x) &lt; (lo) ? (lo) : ( (x) &gt; (hi) ? (hi) : (x) ) )</P>
<P>#define GE_CLAMP8(x)&#9;&#9;&#9;GE_CLAMP(x,0,255)</P>
<P>#define GE_CLAMP16(x)&#9;&#9;&#9;GE_CLAMP(x,0,65536)</P>
<P>#define GE_BOOLSAME(x,y)&#9;&#9;( ( (x) &amp;&amp; (y) ) || ( !(x) &amp;&amp; !(y) ) )</P>

<P>#define GE_EPSILON&#9;&#9;&#9;&#9;((geFloat)0.000797f)</P>
<P>#define GE_FLOATS_EQUAL(x,y)&#9;( GE_ABS((x) - (y)) &lt; GE_EPSILON )</P>
<P>#define GE_FLOAT_ISZERO(x)&#9;&#9;GE_FLOATS_EQUAL(x,0.0f)</P>

<P>#define&#9;GE_PI&#9;&#9;&#9;&#9;&#9;((geFloat)3.14159265358979323846f)</P>

<P>/****************************************************/</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P> </P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070052">Errorlog.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  ERRORLOG.H                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Mike Sandige                                                                */</P>
<P>/*  Description: Generic error logging system interface                                 */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_ERRORLOG_H</P>
<P>#define GE_ERRORLOG_H</P>

<P>#include "basetype.h"</P>

<P>#ifndef NDEBUG </P>
<P>&#9;#define ERRORLOG_FULL_REPORTING</P>
<P>#endif</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef enum</P>
<P>{</P>
<P>&#9;GE_ERR_INVALID_DRIVER_HANDLE,&#9;&#9;&#9;// Driver not supported</P>
<P>&#9;GE_ERR_INVALID_MODE_HANDLE,&#9;&#9;&#9;&#9;// Mode not supported</P>
<P>&#9;GE_ERR_DRIVER_INIT_FAILED,&#9;&#9;&#9;&#9;// Could not init Driver</P>
<P>&#9;GE_ERR_DRIVER_ALLREADY_INITIALIZED,&#9;&#9;// Driver init failure</P>
<P>&#9;GE_ERR_DRIVER_NOT_FOUND,&#9;&#9;&#9;&#9;// File open error for driver</P>
<P>&#9;GE_ERR_DRIVER_NOT_INITIALIZED,&#9;&#9;&#9;// Driver shutdown failure</P>
<P>&#9;GE_ERR_INVALID_DRIVER,&#9;&#9;&#9;&#9;&#9;// Wrong driver version, or bad driver</P>
<P>&#9;GE_ERR_DRIVER_BEGIN_SCENE_FAILED,</P>
<P>&#9;GE_ERR_DRIVER_END_SCENE_FAILED,</P>
<P>&#9;GE_ERR_CREATE_SOUND_MANAGER_FAILED,</P>
<P>&#9;GE_ERR_CREATE_SOUND_BUFFER_FAILED,</P>
<P>&#9;GE_ERR_DS_ERROR,</P>
<P>&#9;GE_ERR_INVALID_WAV,</P>
<P>&#9;GE_ERR_NO_PERF_FREQ,</P>
<P>&#9;GE_ERR_FILE_OPEN_ERROR,</P>
<P>&#9;GE_ERR_FILE_READ_ERROR,</P>
<P>&#9;GE_ERR_FILE_WRITE_ERROR,</P>
<P>&#9;GE_ERR_PALETTE_LOAD_FAILURE,</P>
<P>&#9;GE_ERR_GBSP_LOAD_FAILURE,</P>
<P>&#9;GE_ERR_INVALID_PARMS,</P>
<P>&#9;GE_ERR_INVALID_CAMERA,</P>
<P>&#9;GE_ERR_RENDER_WORLD_FAILED,</P>
<P>&#9;GE_ERR_BEGIN_WORLD_FAILED,</P>
<P>&#9;GE_ERR_END_WORLD_FAILED,</P>
<P>&#9;GE_ERR_BEGIN_MODELS_FAILED,</P>
<P>&#9;GE_ERR_END_MODELS_FAILED,</P>
<P>&#9;GE_ERR_BEGIN_MESHES_FAILED,</P>
<P>&#9;GE_ERR_END_MESHES_FAILED,</P>
<P>&#9;GE_ERR_RENDER_MESH_FAILED,</P>
<P>&#9;GE_ERR_BAD_LMAP_EXTENTS,</P>
<P>&#9;GE_ERR_INVALID_TEXTURE,</P>
<P>&#9;GE_ERR_REGISTER_WORLD_TEXTURE_FAILED,</P>
<P>&#9;GE_ERR_REGISTER_LIGHTMAPS_FAILED,</P>
<P>&#9;GE_ERR_REGISTER_WORLD_PALETTE_FAILED,</P>
<P>&#9;GE_ERR_REGISTER_MISC_TEXTURE_FAILED,</P>
<P>&#9;GE_ERR_INVALID_MESH_FILE,</P>
<P>&#9;GE_ERR_LOAD_BITMAP_FAILED,</P>
<P>&#9;GE_ERR_MAX_MESH_DEFS,</P>
<P>&#9;GE_ERR_MESH_MAX_NODES,</P>
<P>&#9;GE_ERR_INVALID_MESH_MATERIAL,</P>
<P>&#9;GE_ERR_MAX_MESH_MATERIALS,</P>
<P>&#9;GE_ERR_MAX_MESH_CLIP_PLANES,</P>
<P>&#9;GE_ERR_RENDERQ_OVERFLOW,</P>
<P>&#9;GE_ERR_INVALID_LTYPE,</P>
<P>&#9;GE_ERR_MAX_ENTITIES,</P>
<P>&#9;GE_ERR_GET_ENTITY_DATA_ERROR,</P>
<P>&#9;GE_ERR_INVALID_ENTITY_FIELD_TYPE,</P>
<P>&#9;GE_ERR_MODEL_NOT_FOUND,</P>
<P>&#9;GE_ERR_MODEL_NOT_IN_ENTITY,</P>
<P>&#9;GE_ERR_MAX_TEXTURES,</P>
<P>&#9;GE_ERR_MAX_DECALS,</P>
<P>&#9;GE_ERR_MAX_VERTS,</P>
<P>&#9;GE_ERR_OUT_OF_MEMORY,</P>
<P>&#9;GE_ERR_INVALID_BSP_TAG,</P>
<P>&#9;GE_ERR_INVALID_BSP_VERSION,</P>
<P>&#9;GE_ERR_ERROR_READING_BSP_CHUNK,</P>
<P>&#9;ERR_PATH_CREATE_ENOMEM,&#9;&#9;&#9;&#9;// failure to create a path (memory allocation failed)</P>
<P>&#9;ERR_PATH_INSERT_R_KEYFRAME,&#9;&#9;&#9;// failure to insert a rotation keyframe</P>
<P>&#9;ERR_PATH_INSERT_T_KEYFRAME,&#9;&#9;&#9;// failure to insert a translation keyframe</P>
<P>&#9;ERR_PATH_DELETE_R_KEYFRAME,&#9;&#9;&#9;// failure to delete a rotation keyframe</P>
<P>&#9;ERR_PATH_DELETE_T_KEYFRAME,&#9;&#9;&#9;// failure to delete a translation keyframe</P>
<P>&#9;ERR_PATH_FILE_READ,&#9;&#9;&#9;&#9;&#9;// failure to read from file</P>
<P>&#9;ERR_PATH_FILE_VERSION,&#9;&#9;&#9;&#9;// tried to create path from file with wrong/bad version</P>
<P>&#9;ERR_PATH_FILE_PARSE,&#9;&#9;&#9;&#9;// failure to parse file (unexpected format problem)</P>
<P>&#9;ERR_PATH_FILE_WRITE,&#9;&#9;&#9;&#9;// failure to read from file</P>
<P>&#9;ERR_MOTION_CREATE_ENOMEM,&#9;&#9;&#9;// failure to create (memory allocation failed)</P>
<P>&#9;ERR_MOTION_ADDPATH_ENOMEM,&#9;&#9;&#9;// failure to add path into motion (memory allocation failed)</P>
<P>&#9;ERR_MOTION_ADDPATH_PATH,&#9;&#9;&#9;// failure to add path into motion (path creation failed)</P>
<P>&#9;ERR_MOTION_ADDPATH_BAD_NAME,&#9;&#9;// failure to add path into motion due to name conflict</P>
<P>&#9;ERR_MOTION_INSERT_EVENT,&#9;&#9;&#9;// failure to insert event (memory allocation failed or duplicate key)</P>
<P>&#9;ERR_MOTION_DELETE_EVENT,&#9;&#9;&#9;// failure to insert event</P>
<P>&#9;ERR_MOTION_FILE_READ,&#9;&#9;&#9;&#9;// failure to read from file</P>
<P>&#9;ERR_MOTION_FILE_WRITE,&#9;&#9;&#9;&#9;// failure to write to file</P>
<P>&#9;ERR_MOTION_FILE_PARSE,&#9;&#9;&#9;&#9;// failure to parse file (unexpected format problem)</P>
<P>&#9;ERR_TKARRAY_INSERT_IDENTICAL,&#9;&#9;// failure to insert into list because of existing identical key</P>
<P>&#9;ERR_TKARRAY_INSERT_ENOMEM,&#9;&#9;&#9;// failure to insert into list because of memory allocation failure</P>
<P>&#9;ERR_TKARRAY_DELETE_NOT_FOUND,&#9;&#9;// failure to delete from list because key was not found</P>
<P>&#9;ERR_TKARRAY_CREATE,&#9;&#9;&#9;&#9;&#9;// failure to create TKArray object (out of memroy)</P>
<P>&#9;ERR_TKARRAY_TOO_BIG,&#9;&#9;&#9;&#9;// TKArray object can't be added to - it's list is as big as it can get</P>
<P>&#9;ERR_VKARRAY_INSERT,&#9;&#9;&#9;&#9;&#9;// insertion to VKArray failed</P>
<P>&#9;ERR_QKARRAY_INSERT,&#9;&#9;&#9;&#9;&#9;// insertion to QKArray failed</P>
<P>&#9;ERR_POSE_CREATE_ENOMEM,&#9;&#9;&#9;&#9;// Motion object failed to create (memory allocation failed)</P>
<P>&#9;ERR_POSE_ADDJOINT_ENOMEM,&#9;&#9;&#9;// Motion_AddJoint failed to allocate/reallocate memory for new joint</P>
<P>&#9;ERR_TKEVENTS_CREATE_ENOMEM,&#9;&#9;&#9;// failure to create TKEvents object (memory allocation failed)</P>
<P>&#9;ERR_TKEVENTS_DELETE_NOT_FOUND,&#9;&#9;// failure to delete from list because key was not found</P>
<P>&#9;ERR_TKEVENTS_INSERT_ENOMEM,&#9;&#9;&#9;// failure to insert into list because of memory allocation failure</P>
<P>&#9;ERR_TKEVENTS_INSERT,&#9;&#9;&#9;&#9;// failure to insert into list </P>
<P>&#9;ERR_TKEVENTS_FILE_READ,&#9;&#9;&#9;&#9;// failure to read from data file</P>
<P>&#9;ERR_TKEVENTS_FILE_WRITE,&#9;&#9;&#9;// failure to write to data file</P>
<P>&#9;ERR_TKEVENTS_FILE_VERSION,&#9;&#9;&#9;// failure to read tkevents object: file has wrong version</P>
<P>&#9;ERR_TKEVENTS_FILE_PARSE,&#9;&#9;&#9;// failure to parse file (unexpected format problem)</P>
<P>&#9;ERR_STRBLOCK_ENOMEM,&#9;&#9;&#9;&#9;// failure to create, insert, or append (memory allocation failed)</P>
<P>&#9;ERR_STRBLOCK_STRLEN,&#9;&#9;&#9;&#9;// string too long to insert or append</P>
<P>&#9;ERR_STRBLOCK_FILE_READ,&#9;&#9;&#9;&#9;// failure to read from data file</P>
<P>&#9;ERR_STRBLOCK_FILE_WRITE,&#9;&#9;&#9;// failure to write to data file</P>
<P>&#9;ERR_STRBLOCK_FILE_PARSE,&#9;&#9;&#9;// failure to parse reading from input file (unexpected format problem)</P>
<P>&#9;ERR_BODY_ENOMEM,&#9;&#9;&#9;&#9;&#9;// failure to create, or add (memory allocation failed)</P>
<P>&#9;ERR_BODY_FILE_PARSE,&#9;&#9;&#9;&#9;// failure to parse reading from input file (unexpected format problem)</P>
<P>&#9;ERR_BODY_FILE_READ,&#9;&#9;&#9;&#9;&#9;// failure to read from data file</P>
<P>&#9;ERR_BODY_FILE_WRITE,&#9;&#9;&#9;&#9;// failure to write to data file</P>
<P>&#9;ERR_BODY_BONEXFARRAY,&#9;&#9;&#9;&#9;// XFArray object failed to return array, or array size doesn't match bone count</P>
<P>&#9;ERR_XFARRAY_ENOMEM,&#9;&#9;&#9;&#9;&#9;// failure to create. (memory allocation failure)</P>
<P>&#9;ERR_PUPPET_ENOMEM,&#9;&#9;&#9;&#9;&#9;// failure to create. (memory allocation failure)</P>
<P>&#9;ERR_PUPPET_RENDER,&#9;&#9;&#9;&#9;&#9;// failure to render. </P>
<P>&#9;ERR_PUPPET_NO_MATERIALS,&#9;&#9;&#9;// failure to create: associated body has no materials.</P>
<P>&#9;ERR_PUPPET_LOAD_TEXTURE,&#9;&#9;&#9;// failure to load texture </P>
<P>&#9;ERR_TEXPOOL_ENOMEM,&#9;&#9;&#9;&#9;&#9;// failure to create or add to. (memory allocation/reallocation failure)</P>
<P>&#9;ERR_TEXPOOL_TOO_BIG,&#9;&#9;&#9;&#9;// failure to add to pool, pool is too large.</P>
<P>&#9;ERR_TEXPOOL_LOAD_TEXTURE,&#9;&#9;&#9;// failure to load texture into pool</P>
<P>&#9;ERR_TEXPOOL_TEXTURE_NOT_FREE,&#9;&#9;// texture pool destroyed without first freeing all it's shared textures</P>
<P>&#9;ERR_ACTOR_ENOMEM,&#9;&#9;&#9;&#9;&#9;// failure to create. (memory allocation failure)</P>
<P>&#9;ERR_ACTOR_RENDER_PREP,&#9;&#9;&#9;&#9;// failure to prepare actor for rendering (bad Body or allocation failure)</P>
<P>&#9;ERR_ACTOR_RENDER_FAILED,&#9;&#9;&#9;// failure to render.  failure to get geometry from Body </P>
<P>&#9;ERR_ACTOR_TOO_MANY_MOTIONS,&#9;&#9;&#9;// failure to add motion. too many.</P>
<P>&#9;ERR_ACTOR_FILE_READ,&#9;&#9;&#9;&#9;// failure to read from data file.</P>
<P>&#9;ERR_ACTOR_FILE_PARSE,&#9;&#9;&#9;&#9;// failure to parse reading from input file(unexpected format problem)</P>
<P>&#9;ERR_ACTOR_FILE_WRITE,&#9;&#9;&#9;&#9;// failure to write to data file.</P>
<P>&#9;GE_ERR_INVALID_MODEL_MOTION_FILE,&#9;// Bad model motion file (for bsp files)</P>
<P>&#9;GE_ERR_BAD_BSP_FILE_CHUNK_SIZE,&#9;&#9;// Chunk size does not match structure size of kind</P>
<P>} geErrorLog_ErrorIDEnumType;</P>

<P>&nbsp;</P>
<P>typedef enum </P>
<P>{</P>
<P>&#9;GE_ERR_MEMORY_RESOURCE,</P>
<P>&#9;GE_ERR_DISPLAY_RESOURCE,</P>
<P>&#9;GE_ERR_SOUND_RESOURCE,</P>
<P>&#9;GE_ERR_SYSTEM_RESOURCE,</P>
<P>&#9;GE_ERR_INTERNAL_RESOURCE,</P>
<P>&#9;</P>
<P>&#9;GE_ERR_FILEIO_OPEN,</P>
<P>&#9;GE_ERR_FILEIO_CLOSE,</P>
<P>&#9;GE_ERR_FILEIO_READ,</P>
<P>&#9;GE_ERR_FILEIO_WRITE,</P>
<P>&#9;GE_ERR_FILEIO_FORMAT,</P>
<P>&#9;GE_ERR_FILEIO_VERSION,</P>
<P>&#9;</P>
<P>&#9;GE_ERR_LIST_FULL,</P>
<P>&#9;GE_ERR_DATA_FORMAT,</P>
<P>&#9;GE_ERR_SEARCH_FAILURE,</P>
<P>} geErrorLog_ErrorClassType;</P>

<P>GENESISAPI void geErrorLog_Clear(void);</P>
<P>&#9;// clears error history</P>

<P>GENESISAPI int  geErrorLog_Count(void);</P>
<P>&#9;// reports size of current error log</P>

<P>GENESISAPI void geErrorLog_AddExplicit(geErrorLog_ErrorClassType,</P>
<P>&#9;const char *ErrorIDString,</P>
<P>&#9;const char *ErrorFileString,</P>
<P>&#9;int LineNumber,</P>
<P>&#9;const char *UserString,</P>
<P>&#9;const char *Context);</P>
<P>&#9;// not intended to be used directly: use ErrorLog_Add or ErrorLog_AddString</P>

<P>&nbsp;</P>
<P>#ifdef ERRORLOG_FULL_REPORTING</P>
<P>&#9;// 'Debug' version includes a textual error id, and the user string</P>

<P>&#9;#define geErrorLog_Add(Error, Context) geErrorLog_AddExplicit(Error, #Error, __FILE__, __LINE__,"", Context)</P>
<P>&#9;&#9;// logs an error.  </P>

<P>&#9;#define geErrorLog_AddString(Error,String, Context) geErrorLog_AddExplicit(Error, #Error, __FILE__,__LINE__, String, Context)</P>
<P>&#9;&#9;// logs an error with additional identifing string.  </P>
<P>&#9;</P>
<P>GENESISAPI&#9;geBoolean geErrorLog_AppendStringToLastError(const char *String);// use geErrorLog_AppendString</P>

<P>&#9;#define geErrorLog_AppendString(XXX) geErrorLog_AppendStringToLastError(XXX)</P>
<P>&#9;&#9;// adds text to the previous logged error</P>

<P>#else</P>
<P>&#9;// 'Release' version does not include the textual error id, or the user string</P>

<P>&#9;#define geErrorLog_Add(Error, Context) geErrorLog_AddExplicit(Error, "", __FILE__, __LINE__,"", Context)</P>
<P>&#9;&#9;// logs an error.  </P>

<P>&#9;#define geErrorLog_AddString(Error,String, Context) geErrorLog_AddExplicit(Error, "", __FILE__,__LINE__, "", Context)</P>
<P>&#9;&#9;// logs an error with additional identifing string.  </P>
<P>&#9;</P>
<P>&#9;#define geErrorLog_AppendString(XXX)</P>
<P>&#9;&#9;// adds text to the previous logged error</P>

<P>#endif</P>

<P>GENESISAPI geBoolean geErrorLog_Report(int History, geErrorLog_ErrorClassType *Error, const char **UserString);</P>
<P>&#9;// reports from the error log.  </P>
<P>&#9;// history is 0 for most recent,  1.. for second most recent etc.</P>
<P>&#9;// returns GE_TRUE if report succeeded.  GE_FALSE if it failed.</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070053">geAssert.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  GEASSERT.H                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:                                                                             */</P>
<P>/*  Description: Replacement for assert interface                                       */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_ASSERT_H</P>
<P>#define GE_ASSERT_H</P>

<P>#include &lt;assert.h&gt;</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>// You should use geAssert() anywhere in the Genesis engine that</P>
<P>// you would normally use assert().</P>
<P>//</P>
<P>// If you wish to be called back when asserts happen, use the</P>
<P>// routine geAssertSetCallback().  It returns the address of</P>
<P>// the callback routine that you're replacing.</P>

<P>&nbsp;</P>
<P>#ifdef NDEBUG</P>

<P>&#9;#define geAssert(exp)</P>

<P>#else</P>

<P>&#9;extern void geAssertEntryPoint( void *, void *, unsigned );</P>

<P>&#9;#define geAssert(exp) (void)( (exp) || (geAssertEntryPoint(#exp, __FILE__, __LINE__), 0) )</P>

<P>#endif</P>

<P>/************************************************************/</P>

<P>typedef void geAssertCallbackFn( void *exp, void *file, unsigned line );</P>

<P>geAssertCallbackFn *geAssertSetCallback( geAssertCallbackFn *newAssertCallback );</P>

<P>typedef void (*geAssert_CriticalShutdownCallback) (void *Context);</P>

<P>extern void geAssert_SetCriticalShutdownCallback( geAssert_CriticalShutdownCallback CB , void *Context);</P>

<P>/************************************************************/</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070054">LOG.H</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  LOG.H                                                                               */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:                                                                             */</P>
<P>/*  Description: Debugging logger interface                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_LOG_H</P>
<P>#define GE_LOG_H</P>

<P>#include &lt;stdarg.h&gt;</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#ifdef&#9;_LOG</P>

<P>void Log_Puts(&#9;const char * string);</P>
<P>void Log_Printf(const char * string, ...);</P>

<P>#else&#9;// _LOG</P>

<P>static _inline void Log_Printf(const char * str, ...) { }</P>
<P>#define Log_Puts(string)</P>

<P>#endif&#9;// _LOG</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif // LOG_H</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070055">MEMPOOL.H</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  MEMPOOL.H                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Charles Bloom                                                               */</P>
<P>/*  Description: Fixed size block memory allocator interface                            */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef MEMPOOL_H</P>
<P>#define MEMPOOL_H</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef struct MemPool MemPool;</P>

<P>extern MemPool * MemPool_Create(int HunkLength,int NumHunks,int AutoExtendNumItems);</P>
<P>extern int MemPool_Extend(MemPool * Pool,int NumHunks);</P>
<P>extern void MemPool_Destroy(MemPool ** pPool);</P>
<P>extern void MemPool_Reset(MemPool * Pool);</P>
<P>extern void * MemPool_GetHunk(MemPool * Pool);</P>
<P>extern int MemPool_FreeHunk(MemPool * Pool,void *Hunk);</P>

<P> /* NOTEZ: MemPool_Get clears the memory block to zeros*/</P>

<P>#ifdef _DEBUG</P>
<P>extern int MemPool_IsValid(MemPool * Pool);</P>
<P>#endif</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif /*CRB_MEMPOOL_H*/</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070056">RAM.H</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  RAM.H                                                                               */</P>
<P>/*                                                                                      */</P>
<P>/*  Author:                                                                             */</P>
<P>/*  Description: Replacement for malloc, realloc and free                               */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_RAM_H</P>
<P>#define GE_RAM_H</P>

<P>#include "basetype.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>typedef int (* geRam_CriticalCallbackFunction)(void);</P>

<P>/*</P>
<P>  Set the critical callback function.  ram_allocate will call the critical</P>
<P>  callback function if it's unable to allocate memory.</P>
<P>*/</P>
<P>GENESISAPI geRam_CriticalCallbackFunction geRam_SetCriticalCallback</P>
<P>    (</P>
<P>      geRam_CriticalCallbackFunction callback</P>
<P>    );</P>

<P>/*</P>
<P>  increments or decrements a counter .  if the counter is &gt;0</P>
<P>  the critical callback function (if set) is called for a failed memory allocation.</P>
<P>  add is added to the current counter value.  the new counter value is returned.</P>
<P>*/</P>
<P>GENESISAPI int geRam_EnableCriticalCallback(int add);</P>

<P>&nbsp;</P>
<P>/*</P>
<P>  Allocate memory of the given size.  In debug mode, the memory is filled</P>
<P>  with 0xA5, and we keep track of the amount of memory allocated.  Also, in debug</P>
<P>  mode, we track where the memory was allocated and can optionally provide a</P>
<P>  report of allocated blocks.  See geRam_ReportAllocations.</P>
<P>*/</P>
<P>#ifndef NDEBUG</P>

<P>#define geRam_Allocate(size) _geRam_DebugAllocate(size, __FILE__, __LINE__)</P>

<P>// Do not call _geRam_DebugAllocate directly.</P>
<P>GENESISAPI void* _geRam_DebugAllocate(uint32 size, const char* pFile, int line);</P>

<P>#else</P>

<P>GENESISAPI void *geRam_Allocate(uint32 size);</P>

<P>#endif</P>

<P>/*</P>
<P>  Free an allocated memory block.</P>
<P>*/</P>
<P>GENESISAPI void geRam_Free_(void *ptr);</P>

<P>&#9;&#9;extern void *StupidUnusedPointer;    // never used, except to mask the</P>
<P>&#9;&#9;// possible warning you get if you use the geRam_Free macro below, without</P>
<P>&#9;&#9;// using the xxx pointer again in the same block.  This is ugly.</P>
<P> </P>
<P>#define geRam_Free(xxx) geRam_Free_(xxx) ,(xxx)=NULL, StupidUnusedPointer=(xxx)</P>

<P>/*</P>
<P>  Reallocate memory.  This function supports shrinking and expanding blocks,</P>
<P>  and will also act like ram_allocate if the pointer passed to it is NULL.</P>
<P>  It won't, however, free the memory if you pass it a 0 size.</P>
<P>*/</P>
<P>#ifndef NDEBUG</P>

<P>#define geRam_Realloc(ptr, newsize) _geRam_DebugRealloc(ptr, newsize, __FILE__, __LINE__)</P>

<P>// Do not call _geRam_DebugRealloc directly.</P>
<P>GENESISAPI void* _geRam_DebugRealloc(void* ptr, uint32 size, const char* pFile, int line);</P>

<P>#else</P>

<P>GENESISAPI void *geRam_Realloc(void *ptr,uint32 newsize);</P>

<P>#endif</P>

<P>#ifndef NDEBUG</P>

<P>GENESISAPI void geRam_ReportAllocations(void);</P>

<P>#else</P>

<P>#define geRam_ReportAllocations() </P>

<P>#endif</P>

<P>#ifndef NDEBUG</P>
<P>    extern int32 geRam_CurrentlyUsed;</P>
<P>    extern int32 geRam_NumberOfAllocations;</P>
<P>    extern int32 geRam_MaximumUsed;</P>
<P>    extern int32 geRam_MaximumNumberOfAllocations;</P>

<P>GENESISAPI     void geRam_AddAllocation(int n,uint32 size);</P>
<P>#else</P>
<P>    #define geRam_AddAllocation(n,s)</P>
<P>#endif</P>

<P>// allocate the ram &amp; clear it. (calloc)</P>
<P>GENESISAPI void * geRam_AllocateClear(uint32 size);</P>

<P>#define GE_RAM_ALLOCATE_STRUCT(type)      (type *)geRam_Allocate (sizeof (type))</P>
<P>#define GE_RAM_ALLOCATE_ARRAY(type,count) (type *)geRam_Allocate (sizeof (type) * (count))</P>

<P>#ifndef NDEBUG</P>
<P>#define GE_RAM_REALLOC_ARRAY(ptr,type,count)  (type *)geRam_Realloc(  (ptr), sizeof(type) * (count) );{type *XX=(ptr);}</P>
<P>#else</P>
<P>#define GE_RAM_REALLOC_ARRAY(ptr,type,count)  (type *)geRam_Realloc(  (ptr), sizeof(type) * (count) )</P>
<P>#endif</P>

<P>#ifndef NDEBUG</P>
<P>geBoolean geRam_IsValidPtr(void *ptr);</P>
<P>#endif</P>

<P>#ifdef __cplusplus</P>
<P>  }</P>
<P>#endif</P>

<P>#endif</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<I><P><A NAME="_Toc454070057">OpenSource/Source/Engine/Vfile Subdirectory</A></P>
</B></I></FONT><FONT FACE="Arial"><P>The header files in this subdirectory are used to allow virtual files in the Genesis3D world.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070058">DirTree.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  DIRTREE.H                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Eli Boling                                                                  */</P>
<P>/*  Description: Directory tree interface                                               */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef&#9;DIRTREE_H</P>
<P>#define&#9;DIRTREE_H</P>

<P>#include&#9;"vfile.h"</P>

<P>typedef struct DirTree&#9;&#9;&#9;DirTree;</P>
<P>typedef struct DirTree_Finder&#9;DirTree_Finder;</P>

<P>DirTree *DirTree_Create(void);</P>

<P>DirTree *DirTree_CreateFromFile(geVFile *File);</P>

<P>geBoolean DirTree_WriteToFile(const DirTree *Tree, geVFile *File);</P>

<P>geBoolean DirTree_GetSize(const DirTree *Tree, long *Size);</P>
<P>&#9;// Gets the size of data that will be written to disk to persist</P>
<P>&#9;// the tree.  This API is NOT efficient.</P>

<P>void DirTree_Destroy(DirTree *Tree);</P>

<P>&nbsp;</P>
<P>DirTree *DirTree_FindExact(const DirTree *Tree, const char *Path);</P>
<P>DirTree *DirTree_FindPartial(</P>
<P>&#9;const DirTree *&#9;Tree,</P>
<P>&#9;const char *&#9;Path,</P>
<P>&#9;const char **&#9;LeftOvers);</P>

<P>DirTree * DirTree_AddFile(DirTree *Tree, const char *Path, geBoolean IsDirectory);</P>

<P>geBoolean DirTree_Remove(DirTree *Tree, DirTree *SubTree);</P>

<P>void DirTree_SetFileAttributes(DirTree *Tree, geVFile_Attributes Attributes);</P>

<P>void DirTree_GetFileAttributes(DirTree *Tree, geVFile_Attributes *Attributes);</P>

<P>void DirTree_SetFileOffset(DirTree *Tree, long Offset);</P>

<P>void DirTree_GetFileOffset(DirTree *Tree, long *Offset);</P>

<P>void DirTree_SetFileTime(DirTree *Tree, const geVFile_Time *Time);</P>

<P>void DirTree_GetFileTime(DirTree *Tree, geVFile_Time *Time);</P>

<P>void DirTree_SetFileSize(DirTree *Tree, long Size);</P>

<P>void DirTree_GetFileSize(DirTree *Tree, long *Size);</P>

<P>geBoolean DirTree_SetFileHints(DirTree *Tree, const geVFile_Hints *Hints);</P>

<P>void DirTree_GetFileHints(DirTree *Tree, geVFile_Hints *Hints);</P>

<P>geBoolean DirTree_GetName(DirTree *Tree, char *Buff, int MaxLen);</P>

<P>geBoolean DirTree_FileExists(const DirTree *Tree, const char *Path);</P>

<P>&nbsp;</P>
<P>DirTree_Finder * DirTree_CreateFinder(DirTree *Tree, const char *Path);</P>

<P>void DirTree_DestroyFinder(DirTree_Finder *Finder);</P>

<P>DirTree * DirTree_FinderGetNextFile(DirTree_Finder *Finder);</P>

<P>&nbsp;</P>
<P>#ifdef&#9;DEBUG</P>
<P>void DirTree_Dump(const DirTree *Tree);</P>
<P>#endif</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070059">FSDOS.H</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  FSDOS.H                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Eli Boling                                                                  */</P>
<P>/*  Description: DOS file system interface                                              */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef&#9;FSDOS_H</P>
<P>#define&#9;FSDOS_H</P>

<P>const&#9;geVFile_SystemAPIs *GENESISCC FSDos_GetAPIs(void);</P>

<P>#endif</P>

<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454070060">FSMemory.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  FSMEMORY.H                                                                          */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Eli Boling                                                                  */</P>
<P>/*  Description: Memory file system interface                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef&#9;FSMEMORY_H</P>
<P>#define&#9;FSMEMORY_H</P>

<P>const&#9;geVFile_SystemAPIs * GENESISCC FSMemory_GetAPIs(void);</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070061">FSVFS.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  FSVFS.H                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Eli Boling                                                                  */</P>
<P>/*  Description: Collection file system interface                                       */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef&#9;FSVFS_H</P>
<P>#define&#9;FSVFS_H</P>

<P>#include "vfile._h"</P>

<P>const&#9;geVFile_SystemAPIs * GENESISCC FSVFS_GetAPIs(void);</P>

<P>#endif</P>

<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P>&nbsp;</P>
<P><A NAME="_Toc454070062">VFILE._h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  VFILE._H                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Eli Boling                                                                  */</P>
<P>/*  Description: Systems internal interfaces for vfiles                                 */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef&#9;VFILE__H</P>
<P>#define VFILE__H</P>

<P>#include&#9;"basetype.h"</P>
<P>#include&#9;"vfile.h"</P>

<P>typedef void * &#9;&#9;(GENESISCC *geVFile_FinderCreateFN)(geVFile *FileSystem, void *Handle, const char *FileSpec);</P>
<P>typedef geBoolean &#9;(GENESISCC *geVFile_FinderGetNextFileFN)(void *Handle);</P>
<P>typedef geBoolean &#9;(GENESISCC *geVFile_FinderGetPropertiesFN)(void *Handle, geVFile_Properties *Properties);</P>
<P>typedef void &#9;&#9;(GENESISCC *geVFile_FinderDestroyFN)(void *Handle);</P>

<P>typedef&#9;void * &#9;(GENESISCC *geVFile_OpenNewSystemFN)(geVFile *FS,</P>
<P>&#9;&#9;&#9;&#9;&#9; const char *Name,</P>
<P>&#9;&#9;&#9;&#9;&#9; void *&#9;Context,</P>
<P>&#9;&#9;&#9;&#9;&#9; unsigned int OpenModeFlags);</P>

<P>typedef geBoolean (GENESISCC *geVFile_UpdateContextFN)(geVFile *FS, void *Handle, void *Context, int ContextSize);</P>

<P>typedef&#9;void * &#9;(GENESISCC *geVFile_OpenFN)(geVFile *FS,</P>
<P>&#9;&#9;&#9;&#9;&#9; void *Handle,</P>
<P>&#9;&#9;&#9;&#9;&#9; const char *Name,</P>
<P>&#9;&#9;&#9;&#9;&#9; void *&#9;Context,</P>
<P>&#9;&#9;&#9;&#9;&#9; unsigned int OpenModeFlags);</P>

<P>typedef&#9;geBoolean  (GENESISCC *geVFile_DeleteFileFN)(geVFile *FS, void *Handle, const char *FileName);</P>
<P>typedef&#9;geBoolean  (GENESISCC *geVFile_RenameFileFN)(geVFile *FS, void *Handle, const char *FileName, const char *NewFileName);</P>
<P>typedef&#9;geBoolean  (GENESISCC *geVFile_FileExistsFN)(geVFile *FS, void *Handle, const char *FileName);</P>
<P>typedef&#9;geBoolean  (GENESISCC *geVFile_DisperseFN)(geVFile *FS, void *Handle, const char *Directory, geBoolean Recursive);</P>
<P>typedef&#9;void &#9;  (GENESISCC *geVFile_CloseFN)(void *Handle);</P>

<P>typedef&#9;geBoolean  (GENESISCC *geVFile_GetSFN)(void *Handle, void *Buff, int MaxSize);</P>
<P>typedef&#9;geBoolean  (GENESISCC *geVFile_ReadFN)(void *Handle, void *Buff, int Count);</P>
<P>typedef&#9;geBoolean  (GENESISCC *geVFile_WriteFN)(void *Handle, const void *Buff, int Count);</P>
<P>typedef&#9;geBoolean  (GENESISCC *geVFile_SeekFN)(void *Handle, int Where, geVFile_Whence Whence);</P>
<P>typedef&#9;geBoolean  (GENESISCC *geVFile_EOFFN)(const void *Handle);</P>
<P>typedef&#9;geBoolean  (GENESISCC *geVFile_TellFN)(const void *Handle, long *Position);</P>
<P>typedef&#9;geBoolean  (GENESISCC *geVFile_GetPropertiesFN)(const void *Handle, geVFile_Properties *Properties);</P>

<P>typedef&#9;geBoolean  (GENESISCC *geVFile_SizeFN)(const void *Handle, long *Size);</P>
<P>typedef geBoolean  (GENESISCC *geVFile_SetSizeFN)(void *Handle, long Size);</P>
<P>typedef geBoolean  (GENESISCC *geVFile_SetAttributesFN)(void *Handle, geVFile_Attributes Attributes);</P>
<P>typedef geBoolean  (GENESISCC *geVFile_SetTimeFN)(void *Handle, const geVFile_Time *Time);</P>
<P>typedef geBoolean  (GENESISCC *geVFile_SetHintsFN)(void *Handle, const geVFile_Hints *Hints);</P>

<P>typedef&#9;struct&#9;geVFile_SystemAPIs</P>
<P>{</P>
<P>&#9;geVFile_FinderCreateFN&#9;&#9;FinderCreate;</P>
<P>&#9;geVFile_FinderGetNextFileFN&#9;FinderGetNextFile;</P>
<P>&#9;geVFile_FinderGetPropertiesFN FinderGetProperties;</P>
<P>&#9;geVFile_FinderDestroyFN&#9;&#9;FinderDestroy;</P>

<P>&#9;geVFile_OpenNewSystemFN&#9;&#9;OpenNewSystem;</P>
<P>&#9;geVFile_UpdateContextFN&#9;&#9;UpdateContext;</P>
<P>&#9;geVFile_OpenFN&#9;&#9;&#9;&#9;Open;</P>
<P>&#9;geVFile_DeleteFileFN&#9;&#9;DeleteFile;</P>
<P>&#9;geVFile_RenameFileFN&#9;&#9;RenameFile;</P>
<P>&#9;geVFile_FileExistsFN&#9;&#9;FileExists;</P>
<P>&#9;geVFile_DisperseFN&#9;&#9;&#9;Disperse;</P>
<P>&#9;geVFile_CloseFN&#9;&#9;&#9;&#9;Close;</P>

<P>&#9;geVFile_GetSFN&#9;&#9;&#9;&#9;GetS;</P>
<P>&#9;geVFile_ReadFN&#9;&#9;&#9;&#9;Read;</P>
<P>&#9;geVFile_WriteFN&#9;&#9;&#9;&#9;Write;</P>
<P>&#9;geVFile_SeekFN&#9;&#9;&#9;&#9;Seek;</P>
<P>&#9;geVFile_EOFFN&#9;&#9;&#9;&#9;Eof;</P>
<P>&#9;geVFile_TellFN&#9;&#9;&#9;&#9;Tell;</P>
<P>&#9;geVFile_SizeFN&#9;&#9;&#9;&#9;Size;</P>

<P>&#9;geVFile_GetPropertiesFN&#9;&#9;GetProperties;</P>

<P>&#9;geVFile_SetSizeFN&#9;&#9;&#9;SetSize;</P>
<P>&#9;geVFile_SetAttributesFN&#9;&#9;SetAttributes;</P>
<P>&#9;geVFile_SetTimeFN&#9;&#9;&#9;SetTime;</P>
<P>&#9;geVFile_SetHintsFN&#9;&#9;&#9;SetHints;</P>
<P>}&#9;geVFile_SystemAPIs;</P>

<P>geBoolean GENESISCC VFile_RegisterFileSystem(</P>
<P>&#9;const geVFile_SystemAPIs *&#9;APIs,</P>
<P>&#9;geVFile_TypeIdentifier *&#9;Type);</P>

<P>#endif</P>
<P>&nbsp;</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070063">VFILE.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  VFILE.H                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: Eli Boling                                                                  */</P>
<P>/*  Description: Virtual file interface                                                 */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef&#9;VFILE_H</P>
<P>#define&#9;VFILE_H</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#include&#9;"basetype.h"</P>

<P>typedef&#9;struct&#9;geVFile&#9;&#9;&#9;geVFile;</P>

<P>//--------- Finder (Directory) --------------</P>
<P>typedef&#9;struct&#9;geVFile_Finder&#9;geVFile_Finder;</P>

<P>typedef int     &#9;&#9;geVFile_TypeIdentifier;</P>
<P>typedef unsigned int    geVFile_Attributes;</P>

<P>typedef struct&#9;geVFile_Hints</P>
<P>{</P>
<P>&#9;void *&#9;HintData;</P>
<P>&#9;int&#9;&#9;HintDataLength;</P>
<P>}&#9;geVFile_Hints;</P>

<P>typedef&#9;struct&#9;geVFile_Time</P>
<P>{</P>
<P>&#9;unsigned long&#9;Time1;</P>
<P>&#9;unsigned long&#9;Time2;</P>
<P>}&#9;geVFile_Time;</P>

<P>#define&#9;GE_VFILE_ATTRIB_READONLY&#9;0x00000001</P>
<P>#define&#9;GE_VFILE_ATTRIB_DIRECTORY&#9;0x00000002</P>

<P>typedef&#9;struct&#9;geVFile_Properties</P>
<P>{</P>
<P>&#9;geVFile_Time&#9;&#9;&#9;&#9;Time;</P>
<P>&#9;geVFile_Attributes&#9;&#9;AttributeFlags;</P>
<P>&#9;long&#9;&#9;&#9;&#9;&#9;Size;</P>
<P>&#9;geVFile_Hints&#9;&#9;&#9;&#9;Hints;</P>
<P>&#9;char&#9;&#9;&#9;&#9;&#9;Name[1024];</P>
<P>}&#9;geVFile_Properties;</P>

<P>#ifdef _INC_WINDOWS</P>
<P>GENESISAPI void GENESISCC geVFile_TimeToWin32FileTime(const geVFile_Time *, LPFILETIME Win32FileTime);</P>
<P>&#9;// Converts a geVFile time to a Win32 FILETIME structure.  This API is the</P>
<P>&#9;// way to get the file time into a format to do standardized date/time</P>
<P>&#9;// operations on.  We do not provide date/time operations natively.</P>
<P>#endif</P>

<P>GENESISAPI geVFile_Finder * GENESISCC geVFile_CreateFinder(</P>
<P>&#9;geVFile *&#9;&#9;FileSystem,</P>
<P>&#9;const char *&#9;FileSpec);</P>
<P>&#9;// Creates a finder object from which you can get iterated file names.</P>
<P>&#9;// This is findfirst/findnext functionality.  </P>

<P>GENESISAPI void GENESISCC geVFile_DestroyFinder(geVFile_Finder *Finder);</P>
<P>&#9;// Destroys a Finder object</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_FinderGetNextFile(geVFile_Finder *Finder);</P>
<P>&#9;// Tracks to the next file in the finder directory</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_FinderGetProperties(const geVFile_Finder *Finder, geVFile_Properties *Properties);</P>
<P>&#9;// Gets the file properties from a geVFile_Finder.  You cannot set properties for</P>
<P>&#9;// a file through a finder.  You have to set the properties through a geVFile.</P>

<P>//--------- File System Operations ----</P>

<P>typedef&#9;struct&#9;geVFile_MemoryContext</P>
<P>{</P>
<P>&#9;void *&#9;Data;</P>
<P>&#9;int&#9;&#9;DataLength;</P>
<P>}&#9;geVFile_MemoryContext;</P>

<P>#define GE_VFILE_TYPE_DOS&#9;    ( (geVFile_TypeIdentifier) 1L )</P>
<P>#define GE_VFILE_TYPE_MEMORY&#9;( (geVFile_TypeIdentifier) 2L )</P>
<P>#define GE_VFILE_TYPE_VIRTUAL&#9;( (geVFile_TypeIdentifier) 3L )</P>

<P>// First three flags are mutually exclusive.  Combining them will result in failure</P>
<P>// returns for both geVFile_OpenNewSystem and geVFile_Open.</P>
<P>#define&#9;GE_VFILE_OPEN_READONLY&#9; 0x00000001</P>
<P>#define&#9;GE_VFILE_OPEN_UPDATE &#9; 0x00000002</P>
<P>#define&#9;GE_VFILE_OPEN_CREATE&#9; 0x00000004</P>

<P>#define GE_VFILE_OPEN_DIRECTORY  0x00000008</P>

<P>#if 0</P>
<P>geBoolean GENESISCC&#9;geVFile_Startup(void);</P>
<P>&#9;// Initializes the VFile System.  This API MUST be called before any other</P>
<P>&#9;// VFile APIs are called.  This API ensures that the rest of the VFile systems</P>
<P>&#9;// will be thread safe.  Hence the application should ensure that this function</P>
<P>&#9;// is called once and only once.</P>
<P>#endif</P>

<P>GENESISAPI geVFile * GENESISCC geVFile_OpenNewSystem(</P>
<P>&#9;geVFile *&#9;&#9;&#9;&#9;&#9;FS,</P>
<P>&#9;geVFile_TypeIdentifier&#9;FileSystemType,  // { DOS, MEMORY, ETC ... },</P>
<P>&#9;const char *&#9;&#9;&#9;Name, </P>
<P>&#9;void *&#9;&#9;&#9;&#9;&#9;Context, </P>
<P>&#9;unsigned int &#9;&#9;&#9;OpenModeFlags);</P>
<P>&#9;// Opens a file / file system.</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_UpdateContext(geVFile *FS, void *Context, int ContextSize);</P>

<P>GENESISAPI geVFile * GENESISCC geVFile_GetContext(const geVFile *File);</P>
<P>&#9;// Returns the outer context in which File was opened.</P>

<P>GENESISAPI geVFile * GENESISCC geVFile_Open( </P>
<P>&#9;geVFile *&#9;&#9;&#9;FS,</P>
<P>&#9;const char *&#9;Name, </P>
<P>&#9;unsigned int &#9;OpenModeFlags);</P>

<P>/*</P>
<P>typedef&#9;enum</P>
<P>{</P>
<P>&#9;geVFile_AppendPath,</P>
<P>&#9;geVFile_PrependPath,</P>
<P>}&#9;geVFile_SearchOrder;</P>
<P>*/</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_AddPath(geVFile *FS1, const geVFile *FS2, geBoolean Append);</P>
<P>&#9;// Appends (or prepends) the path associated with FS2 into FS1.</P>
<P>&#9;//    Append==GE_TRUE   causes the FS2 to be searched AFTER FS1</P>
<P>&#9;//    Append==GE_FALSE  causes the FS2 to be searched BEFORE FS1</P>

<P>/*  perhaps geVFile_AppendPath and geVFile_PrependPath */</P>

<P>&nbsp;</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_DeleteFile(geVFile *FS, const char *FileName);</P>
<P>&#9;// Deletes a file within a file system.  Returns GE_TRUE on success, GE_FALSE</P>
<P>&#9;// on failure.</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_RenameFile(geVFile *FS, const char *FileName, const char *NewName);</P>
<P>&#9;// Renames a file within a file system.  Returns GE_TRUE on success, GE_FALSE</P>
<P>&#9;// on failure.</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_FileExists(geVFile *FS, const char *FileName);</P>
<P>&#9;// Returns GE_TRUE if the file FileName exists in FS, GE_FALSE otherwise.</P>
<P>&#9;// Does not do any searching (?)</P>

<P>//geVFile_VFileType geVFile_Register( all kinds of stuff );</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_Close (geVFile *File);</P>
<P>&#9;// closes and destroys the File</P>

<P>//---------- File Specific Operations -----------</P>

<P>typedef&#9;enum</P>
<P>{</P>
<P>&#9;GE_VFILE_SEEKCUR&#9;= 0,</P>
<P>&#9;GE_VFILE_SEEKEND&#9;= 1,</P>
<P>&#9;GE_VFILE_SEEKSET&#9;= 2</P>
<P>}&#9;geVFile_Whence;</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_GetS  &#9;&#9; (&#9;&#9;geVFile *File, void *Buff, int MaxLen);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_Read  &#9;&#9; (&#9;&#9;geVFile *File, void *Buff, int Count);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_Write &#9;&#9; (&#9;&#9;geVFile *File, const void *Buff, int Count);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_Seek  &#9;&#9; (&#9;&#9;geVFile *File, int where, geVFile_Whence Whence);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_Printf&#9;&#9; (&#9;&#9;geVFile *File, const char *Format, ...);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_EOF   &#9;&#9; (const geVFile *File);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_Tell  &#9;&#9; (const geVFile *File, long *Position);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_GetProperties(const geVFile *File, geVFile_Properties *Properties);</P>
<P>//geBoolean geVFile_GetName(geVFile *File, char *Buff, int MaxBuffLen);</P>
<P>&#9;// Gets the name of the file</P>

<P>GENESISAPI geBoolean GENESISCC geVFile_Size  &#9;&#9; (const geVFile *File, long *Size);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_SetSize&#9;&#9; (&#9;&#9;geVFile *File, long Size);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_SetAttributes(&#9;&#9;geVFile *File, geVFile_Attributes Attributes);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_SetTime&#9;&#9; (&#9;&#9;geVFile *File, const geVFile_Time *Time);</P>
<P>GENESISAPI geBoolean GENESISCC geVFile_SetHints&#9; (&#9;&#9;geVFile *File, const geVFile_Hints *Hints);</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>

<P>&nbsp;</P>
<P>OpenSource/Source/Engine/World Subdirectory</P>
</FONT><FONT FACE="Arial"><P>The header files in this subdirectory are the fundamental Genesis3D world creation files.</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070064">Fog.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Fog.h                                                                               */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Fog module                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_FOG_H</P>
<P>#define GE_FOG_H</P>

<P>#include &lt;Assert.h&gt;</P>

<P>#include "Vec3d.h"</P>
<P>#include "BaseType.h"</P>
<P>#include "GeTypes.h"</P>
<P>#include "Ram.h"</P>
<P>#include "Errorlog.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//=====================================================================================</P>
<P>//&#9;Defines / Structure defines</P>
<P>//=====================================================================================</P>
<P>typedef struct&#9;&#9;geFog&#9;&#9;geFog;</P>

<P>typedef geBoolean&#9;SET_ATTR_CB(geFog *Fog);</P>

<P>typedef struct geFog</P>
<P>{</P>
<P>&#9;geVec3d&#9;&#9;&#9;Pos;</P>
<P>&#9;GE_RGBA&#9;&#9;&#9;Color;</P>
<P>&#9;float&#9;&#9;&#9;LightBrightness;</P>
<P>&#9;float&#9;&#9;&#9;VolumeBrightness;</P>
<P>&#9;float&#9;&#9;&#9;VolumeRadius;</P>
<P>&#9;float&#9;&#9;&#9;VolumeRadius2;&#9;&#9;&#9;&#9;// *2</P>
<P>&#9;float&#9;&#9;&#9;VolumeRadiusSquared;&#9;&#9;// Radius squared</P>

<P>&#9;void&#9;&#9;&#9;*UserData;&#9;</P>

<P>&#9;SET_ATTR_CB&#9;&#9;*SetAttrCB;&#9;&#9;&#9;&#9;&#9;// CB for when geFog_SetAttributes is called</P>

<P>&#9;struct geFog&#9;*Next;</P>
<P>&#9;struct geFog&#9;*Prev;</P>
<P>} geFog;</P>

<P>//=====================================================================================</P>
<P>//&#9;Function ProtoTypes</P>
<P>//=====================================================================================</P>
<P>GENESISAPI&#9;&#9;geFog *geFog_Create(SET_ATTR_CB *SetAttrCB);</P>

<P>GENESISAPI&#9;&#9;void geFog_Destroy(geFog *Fog);</P>

<P>GENESISAPI&#9;&#9;geBoolean geFog_SetAttributes(&#9;geFog&#9;&#9;&#9;*Fog, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d&#9;*Pos, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_RGBA&#9;&#9;&#9;*Color,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float&#9;&#9;&#9;LightBrightness, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float&#9;&#9;&#9;VolumeBrightness, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float&#9;&#9;&#9;VolumeRadius);</P>

<P>GENESISAPI&#9;&#9;geBoolean geFog_SetUserData(geFog *Fog, void *UserData);</P>
<P>GENESISAPI&#9;&#9;void *geFog_GetUserData(geFog *Fog);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070065">Frustrum.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Frustum.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Frustum creation/clipping                                              */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_FRUSTUM_H</P>
<P>#define GE_FRUSTUM_H</P>

<P>#include &lt;Assert.h&gt;</P>
<P>//#include &lt;Windows.h&gt;</P>

<P>#include "BaseType.h"</P>
<P>#include "GBSPFile.h"</P>
<P>#include "Vec3d.h"</P>
<P>#include "Camera.h"</P>
<P>#include "XForm3d.h"</P>
<P>#include "Surface.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define MAX_FCP&#9;&#9;&#9;&#9;&#9;&#9;32&#9;&#9;&#9;// Max ClipPlanes for frustum...</P>

<P>#define CLIP_PLANE_EPSILON  0.001f</P>

<P>//================================================================================</P>
<P>//&#9;Structure defines</P>
<P>//================================================================================</P>
<P>typedef struct Frustum_Info</P>
<P>{</P>
<P>&#9;int32&#9;&#9;&#9;NumPlanes;&#9;&#9;&#9;&#9;&#9;// Number of frustum planes to clip against</P>
<P>&#9;GFX_Plane&#9;&#9;Planes[MAX_FCP];&#9;&#9;&#9;// Planes to clip against</P>
<P>&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;// Quick LUTS For BBox testing against frustum</P>
<P>&#9;int32&#9;&#9;&#9;FrustumBBoxIndexes[MAX_FCP*6];</P>
<P>&#9;int32&#9;&#9;&#9;*pFrustumBBoxIndexes[MAX_FCP];</P>
<P>} Frustum_Info;</P>

<P>//================================================================================</P>
<P>//&#9;Function ProtoTypes</P>
<P>//================================================================================</P>
<P>void Frustum_SetFromCamera(Frustum_Info *Info, geCamera *Camera);</P>
<P>geBoolean Frustum_SetFromPoly(Frustum_Info *Info, geVec3d *Verts, int32 NumVerts, geBoolean Flip);</P>
<P>void Frustum_RotateToWorldSpace(Frustum_Info *In, geCamera *Camera, Frustum_Info *Out);</P>
<P>void Frustum_TransformToWorldSpace(const Frustum_Info *In, const geCamera *Camera, Frustum_Info *Out);</P>

<P>geBoolean gePlane_ClipVertsFannedUVRGB(&#9;const geVec3d *In, const Surf_TexVert *TIn, int32 NumIn, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const GFX_Plane *Plane, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *Out, Surf_TexVert *TOut, int32 *NumOut);</P>

<P>geBoolean Frustum_ClipToPlane(&#9;&#9;GFX_Plane *pPlane, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *pIn, geVec3d *pOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, int32 *OutVerts);</P>
<P>geBoolean Frustum_ClipToPlaneUV(&#9;GFX_Plane *pPlane, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *pIn, geVec3d *pOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Surf_TexVert *pTIn, Surf_TexVert *pTOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, int32 *OutVerts);</P>

<P>geBoolean Frustum_ClipToPlaneUVRGB(GFX_Plane *pPlane, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *pIn, geVec3d *pOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Surf_TexVert *pTIn, Surf_TexVert *pTOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, int32 *OutVerts);</P>

<P>geBoolean Frustum_ClipToPlaneUVRGBA(GFX_Plane *pPlane, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *pIn, geVec3d *pOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Surf_TexVert *pTIn, Surf_TexVert *pTOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, int32 *OutVerts);</P>

<P>geBoolean Frustum_ClipToPlaneRGB(&#9;GFX_Plane *pPlane, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *pIn, geVec3d *pOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Surf_TexVert *pTIn, Surf_TexVert *pTOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, int32 *OutVerts);</P>

<P>geBoolean Frustum_ClipToPlaneL(&#9;&#9;GFX_Plane *pPlane, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_LVertex *pIn, GE_LVertex *pOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, int32 *OutVerts);&#9;// CB added</P>

<P>void Frustum_Project(geVec3d *pIn, Surf_TexVert *pTIn, DRV_TLVertex *pOut, int32 NumVerts, const geCamera *Camera);</P>
<P>void Frustum_ProjectRGB(geVec3d *pIn, Surf_TexVert *pTIn, DRV_TLVertex *pOut, int32 NumVerts, const geCamera *Camera);</P>
<P>void Frustum_ProjectRGBA(geVec3d *pIn, Surf_TexVert *pTIn, DRV_TLVertex *pOut, int32 NumVerts, const geCamera *Camera);</P>
<P>void Frustum_ProjectRGBNoClamp(geVec3d *pIn, Surf_TexVert *pTIn, DRV_TLVertex *pOut, int32 NumVerts, const geCamera *Camera);</P>

<P>geBoolean Frustum_PointsInFrustum(const geVec3d *Pin, const GFX_Plane *Plane, int32 NumVerts, int32 *c);</P>

<P>geBoolean Frustum_PointInFrustum(const Frustum_Info *Fi, const geVec3d *Point, float Radius);</P>

<P>geBoolean Frustum_ClipAllPlanesL(const Frustum_Info * Fi,uint32 ClipFlags,GE_LVertex *Verts, int32 *pNumVerts);</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070066">GBSPFILE.H</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Frustum.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Frustum creation/clipping                                              */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_FRUSTUM_H</P>
<P>#define GE_FRUSTUM_H</P>

<P>#include &lt;Assert.h&gt;</P>
<P>//#include &lt;Windows.h&gt;</P>

<P>#include "BaseType.h"</P>
<P>#include "GBSPFile.h"</P>
<P>#include "Vec3d.h"</P>
<P>#include "Camera.h"</P>
<P>#include "XForm3d.h"</P>
<P>#include "Surface.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define MAX_FCP&#9;&#9;&#9;&#9;&#9;&#9;32&#9;&#9;&#9;// Max ClipPlanes for frustum...</P>

<P>#define CLIP_PLANE_EPSILON  0.001f</P>

<P>//================================================================================</P>
<P>//&#9;Structure defines</P>
<P>//================================================================================</P>
<P>typedef struct Frustum_Info</P>
<P>{</P>
<P>&#9;int32&#9;&#9;&#9;NumPlanes;&#9;&#9;&#9;&#9;&#9;// Number of frustum planes to clip against</P>
<P>&#9;GFX_Plane&#9;&#9;Planes[MAX_FCP];&#9;&#9;&#9;// Planes to clip against</P>
<P>&#9;&#9;&#9;&#9;&#9;</P>
<P>&#9;// Quick LUTS For BBox testing against frustum</P>
<P>&#9;int32&#9;&#9;&#9;FrustumBBoxIndexes[MAX_FCP*6];</P>
<P>&#9;int32&#9;&#9;&#9;*pFrustumBBoxIndexes[MAX_FCP];</P>
<P>} Frustum_Info;</P>

<P>//================================================================================</P>
<P>//&#9;Function ProtoTypes</P>
<P>//================================================================================</P>
<P>void Frustum_SetFromCamera(Frustum_Info *Info, geCamera *Camera);</P>
<P>geBoolean Frustum_SetFromPoly(Frustum_Info *Info, geVec3d *Verts, int32 NumVerts, geBoolean Flip);</P>
<P>void Frustum_RotateToWorldSpace(Frustum_Info *In, geCamera *Camera, Frustum_Info *Out);</P>
<P>void Frustum_TransformToWorldSpace(const Frustum_Info *In, const geCamera *Camera, Frustum_Info *Out);</P>

<P>geBoolean gePlane_ClipVertsFannedUVRGB(&#9;const geVec3d *In, const Surf_TexVert *TIn, int32 NumIn, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const GFX_Plane *Plane, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *Out, Surf_TexVert *TOut, int32 *NumOut);</P>

<P>geBoolean Frustum_ClipToPlane(&#9;&#9;GFX_Plane *pPlane, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *pIn, geVec3d *pOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, int32 *OutVerts);</P>
<P>geBoolean Frustum_ClipToPlaneUV(&#9;GFX_Plane *pPlane, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *pIn, geVec3d *pOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Surf_TexVert *pTIn, Surf_TexVert *pTOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, int32 *OutVerts);</P>

<P>geBoolean Frustum_ClipToPlaneUVRGB(GFX_Plane *pPlane, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *pIn, geVec3d *pOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Surf_TexVert *pTIn, Surf_TexVert *pTOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, int32 *OutVerts);</P>

<P>geBoolean Frustum_ClipToPlaneUVRGBA(GFX_Plane *pPlane, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *pIn, geVec3d *pOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Surf_TexVert *pTIn, Surf_TexVert *pTOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, int32 *OutVerts);</P>

<P>geBoolean Frustum_ClipToPlaneRGB(&#9;GFX_Plane *pPlane, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *pIn, geVec3d *pOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Surf_TexVert *pTIn, Surf_TexVert *pTOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, int32 *OutVerts);</P>

<P>geBoolean Frustum_ClipToPlaneL(&#9;&#9;GFX_Plane *pPlane, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_LVertex *pIn, GE_LVertex *pOut,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, int32 *OutVerts);&#9;// CB added</P>

<P>void Frustum_Project(geVec3d *pIn, Surf_TexVert *pTIn, DRV_TLVertex *pOut, int32 NumVerts, const geCamera *Camera);</P>
<P>void Frustum_ProjectRGB(geVec3d *pIn, Surf_TexVert *pTIn, DRV_TLVertex *pOut, int32 NumVerts, const geCamera *Camera);</P>
<P>void Frustum_ProjectRGBA(geVec3d *pIn, Surf_TexVert *pTIn, DRV_TLVertex *pOut, int32 NumVerts, const geCamera *Camera);</P>
<P>void Frustum_ProjectRGBNoClamp(geVec3d *pIn, Surf_TexVert *pTIn, DRV_TLVertex *pOut, int32 NumVerts, const geCamera *Camera);</P>

<P>geBoolean Frustum_PointsInFrustum(const geVec3d *Pin, const GFX_Plane *Plane, int32 NumVerts, int32 *c);</P>

<P>geBoolean Frustum_PointInFrustum(const Frustum_Info *Fi, const geVec3d *Point, float Radius);</P>

<P>geBoolean Frustum_ClipAllPlanesL(const Frustum_Info * Fi,uint32 ClipFlags,GE_LVertex *Verts, int32 *pNumVerts);</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070067">LIGHT.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Light.h                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Handles lightmaps, dynamic light, fog, etc                             */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_LIGHT_H</P>
<P>#define GE_LIGHT_H</P>

<P>#include &lt;Assert.h&gt;</P>
<P>//#include &lt;Windows.h&gt;</P>

<P>#include "Genesis.h"</P>
<P>#include "BaseType.h"</P>
<P>#include "System.h"</P>
<P>#include "DCommon.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//=====================================================================================</P>
<P>//&#9;Defines / Structure defines</P>
<P>//=====================================================================================</P>
<P>#define MAX_DYNAMIC_LIGHTS&#9;&#9;32&#9;// Maximum number of moving lights in map</P>
<P>#define MAX_LTYPES&#9;&#9;&#9;&#9;12&#9;// Max number of ltypes</P>
<P>//#define&#9;MAX_LMAP_SIZE&#9;&#9;&#9;128</P>
<P>//#define&#9;MAX_LMAP_SIZE&#9;&#9;&#9;18</P>
<P>#define&#9;MAX_LMAP_SIZE&#9;&#9;&#9;18</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;geBoolean&#9;Active;&#9;&#9;&#9;&#9;&#9;// Is this light in use?</P>
<P>&#9;GE_RGBA&#9;&#9;Color;&#9;&#9;&#9;&#9;&#9;// Color of light (0...255.0f)</P>
<P>&#9;geVec3d&#9;&#9;Pos;&#9;&#9;&#9;&#9;&#9;// Position of this light</P>
<P>&#9;float&#9;&#9;Radius;&#9;&#9;&#9;&#9;&#9;// Intensity of this light (Radius)</P>

<P>&#9;// Fixed point color</P>
<P>&#9;uint32&#9;&#9;FColorR;</P>
<P>&#9;uint32&#9;&#9;FColorG;</P>
<P>&#9;uint32&#9;&#9;FColorB;</P>

<P>&#9;geBoolean&#9;CastShadow;</P>
<P>} Light_DLight;</P>

<P>typedef struct Light_LightInfo</P>
<P>{</P>
<P>&#9;// Intensity tables, for animated styles</P>
<P>&#9;BOOL&#9;&#9;&#9;LTypeDynamic[MAX_LTYPES];</P>
<P>&#9;int32&#9;&#9;&#9;LTypeIntensities[MAX_LTYPES];</P>
<P>&#9;uint8&#9;&#9;&#9;LTypeIntensities2[MAX_LTYPES];</P>

<P>&#9;char&#9;&#9;&#9;LTypeTable[MAX_LTYPES][70];</P>
<P>&#9;int32&#9;&#9;&#9;IPos[MAX_LTYPES];                 // Ref position in ltype table</P>

<P>&#9;Light_DLight&#9;DynamicLights[MAX_DYNAMIC_LIGHTS];</P>
<P>&#9;int32&#9;&#9;&#9;NumDynamicLights;</P>
<P>} Light_LightInfo;</P>

<P>//=====================================================================================</P>
<P>//&#9;Function ProtoTypes</P>
<P>//=====================================================================================</P>
<P>geBoolean&#9;Light_EngineInit(geEngine *Engine);</P>
<P>void&#9;&#9;Light_EngineShutdown(geEngine *Engine);</P>
<P>geBoolean&#9;Light_WorldInit(geWorld *World);</P>
<P>void&#9;&#9;Light_WorldShutdown(geWorld *World);</P>
<P>geBoolean&#9;Light_SetEngine(geEngine *Engine);</P>
<P>geBoolean&#9;Light_SetWorld(geWorld *World);</P>
<P>geBoolean&#9;Light_SetGBSP(World_BSP *BSP);</P>

<P>Light_DLight *Light_WorldAddLight(geWorld *World);</P>
<P>void&#9;&#9;Light_WorldRemoveLight(geWorld *World, Light_DLight *DLight);</P>
<P>geBoolean&#9; Light_SetupLights(geWorld *World);</P>
<P>geBoolean&#9;Light_SetAttributes(&#9;Light_DLight *Light, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Pos, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const GE_RGBA *RGBA, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float Radius,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBoolean CastShadow);</P>
<P>geBoolean&#9;Light_WorldSetLTypeTable(geWorld *World, int32 LType, const char *Table);</P>

<P>char&#9;&#9;Light_WorldGetLTypeCurrent(geWorld *World, int32 LType);</P>
<P>void&#9;&#9;Light_SetupLightmap(DRV_LInfo *LInfo, BOOL *Dynamic);</P>
<P>geBoolean&#9;Light_GetLightmapRGB(Surf_SurfInfo *Surf, geVec3d *Pos, GE_RGBA *RGBA);</P>
<P>geBoolean&#9;Light_GetLightmapRGBBlended(Surf_SurfInfo *Surf, geVec3d *Pos, GE_RGBA *RGBA);</P>
<P>void&#9;&#9;Light_FogVerts(const geFog *Fog, const geVec3d *POV, const geVec3d *Verts, Surf_TexVert *TexVerts, int32 NumVerts);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070068">Plane.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Plane.h                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Handy functions that deal with GFX_Plane's                             */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_PLANE_H</P>
<P>#define GE_PLANE_H</P>

<P>#include &lt;Assert.h&gt;</P>
<P>#include &lt;Windows.h&gt;</P>

<P>#include "GBSPFile.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//=====================================================================================</P>
<P>//&#9;Defines / Structure defines</P>
<P>//=====================================================================================</P>

<P>//=====================================================================================</P>
<P>//&#9;Function ProtoTypes</P>
<P>//=====================================================================================</P>
<P>geBoolean GENESISCC Plane_SetEngine(geEngine *Engine);</P>
<P>geBoolean GENESISCC Plane_SetWorld(geWorld *World);</P>
<P>geBoolean GENESISCC Plane_SetGBSP(World_BSP *BSP);</P>

<P>int32 GENESISCC Plane_FindLeaf(const geWorld *World, int32 Node, const geVec3d *POV);</P>

<P>float GENESISCC Plane_PlaneDistanceFast(const GFX_Plane *Plane, const geVec3d *Point);</P>
<P>float GENESISCC Plane_FaceDistanceFast(const GFX_Face *Face, const geVec3d *Point);</P>
<P>float GENESISCC Plane_PlaneDistance(const GFX_Plane *Plane, const geVec3d *Point);</P>
<P>void gePlane_SetFromVerts(GFX_Plane *Plane, const geVec3d *V1, const geVec3d *V2, const geVec3d *V3);</P>

<P>&nbsp;</P>
<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070069">Surface.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Surface.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Creates the surfaces for a BSP from the GFX data                       */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_SURFACE_H</P>
<P>#define GE_SURFACE_H</P>

<P>#include &lt;Assert.h&gt;</P>
<P>#include &lt;Windows.h&gt;</P>

<P>#include "BaseType.h"</P>
<P>#include "PtrTypes.h"</P>
<P>#include "Vec3d.h"</P>
<P>#include "DCommon.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//================================================================================</P>
<P>//&#9;Structure defines</P>
<P>//================================================================================</P>

<P>// Surface info carries extra info about a face thats not in GFX_Face (File format face)</P>
<P>typedef struct Surf_SurfInfo</P>
<P>{</P>
<P>&#9;DRV_LInfo&#9;LInfo;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// For RDriver use only...</P>

<P>&#9;geVec3d&#9;&#9;T2WVecs[2];</P>
<P>&#9;geVec3d&#9;&#9;TexOrg;</P>

<P>&#9;geVec3d&#9;&#9;VMins;</P>
<P>&#9;geVec3d&#9;&#9;VMaxs;</P>
<P>&#9;</P>
<P>&#9;int32&#9;&#9;VisFrame;</P>
<P>&#9;</P>
<P>&#9;int32&#9;&#9;TexInfo;</P>
<P>&#9;</P>
<P>&#9;int32&#9;&#9;XStep;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Lightmap step values (1:21:10 fixed)</P>
<P>&#9;int32&#9;&#9;YStep;</P>
<P>&#9;int32&#9;&#9;XScale;</P>
<P>&#9;int32&#9;&#9;YScale;</P>

<P>&#9;float&#9;&#9;ShiftU;</P>
<P>&#9;float&#9;&#9;ShiftV;</P>
<P>&#9;</P>
<P>&#9;int32&#9;&#9;NumLTypes;&#9;&#9;&#9;&#9;&#9;&#9;// Number of lightmap types this face has...</P>
<P>&#9;int32&#9;&#9;DLightFrame;&#9;&#9;&#9;&#9;&#9;// == Globals-&gt;CurFrame if dlighted</P>
<P>&#9;uint32&#9;&#9;DLights;&#9;&#9;&#9;&#9;&#9;&#9;// Bit set for each DLight</P>
<P>&#9;uint32&#9;&#9;Flags;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Surface Flags (NOTE - This is not the flags from the utilities)</P>

<P>} Surf_SurfInfo;</P>

<P>typedef struct Surf_TexVert</P>
<P>{</P>
<P>&#9;float&#9;&#9;u, v;</P>
<P>&#9;float&#9;&#9;r, g, b, a;</P>
<P>} Surf_TexVert;</P>

<P>// Lit vertex</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;float X, Y, Z;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 3d vertex</P>
<P>&#9;float u, v;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Uv's</P>
<P>&#9;float r, g, b, a;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// color</P>
<P>} Surf_LVertex;</P>

<P>// Transformed Lit vertex</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;float x, y, z;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// screen points</P>
<P>&#9;float u, v;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Uv's</P>
<P>&#9;float r, g, b, a;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// color</P>
<P>} Surf_TLVertex;</P>

<P>//&#9;Surface Flags</P>
<P>#define&#9;&#9;SURFINFO_TRANS&#9;&#9;&#9;&#9;(1&lt;&lt;0)&#9;&#9;// Surface is transparent</P>
<P>#define&#9;&#9;SURFINFO_LTYPED&#9;&#9;&#9;&#9;(1&lt;&lt;1)&#9;&#9;// This surface has more than one ltype</P>
<P>#define&#9;&#9;SURFINFO_LIGHTMAP&#9;&#9;&#9;(1&lt;&lt;2)&#9;&#9;// This surface has a lightmap</P>
<P>#define&#9;&#9;SURFINFO_WAVY&#9;&#9;&#9;&#9;(1&lt;&lt;3)&#9;&#9;// This surface is a wavy surface</P>

<P>//================================================================================</P>
<P>//&#9;Function defines</P>
<P>//================================================================================</P>
<P>geBoolean Surf_EngineInit(geEngine *Engine);</P>
<P>void Surf_EngineShutdown(geEngine *Engine);</P>
<P>geBoolean Surf_SetEngine(geEngine *Engine);</P>
<P>geBoolean Surf_SetWorld(geWorld *World);</P>
<P>geBoolean Surf_SetGBSP(World_BSP *BSP);</P>
<P>geBoolean Surf_WorldInit(geWorld *World);</P>
<P>void Surf_WorldShutdown(geWorld *World);</P>

<P>BOOL Surf_InSurfBoundingBox(Surf_SurfInfo *Surf, geVec3d *Pos, float Box);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070070">Trace.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Trace.h                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: BSP collision detection code                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_TRACE_H</P>
<P>#define GE_TRACE_H</P>

<P>#include &lt;Assert.h&gt;</P>
<P>#include &lt;Windows.h&gt;</P>

<P>#include "Genesis.h"</P>
<P>#include "BaseType.h"</P>
<P>#include "Vec3d.h"</P>
<P>#include "World.h"</P>
<P>//#include "System.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//=====================================================================================</P>
<P>//&#9;Defines / Structure defines</P>
<P>//=====================================================================================</P>
<P>#define&#9;PSIDE_FRONT&#9;&#9;&#9;1</P>
<P>#define&#9;PSIDE_BACK&#9;&#9;&#9;2</P>
<P>#define&#9;PSIDE_BOTH&#9;&#9;&#9;(PSIDE_FRONT|PSIDE_BACK)</P>
<P>#define&#9;PSIDE_FACING&#9;&#9;4</P>

<P>int32 Trace_BoxOnPlaneSide(const geVec3d *Mins, const geVec3d *Maxs, GFX_Plane *Plane);</P>
<P>geBoolean Trace_BBoxInVisibleLeaf(geWorld *World, geVec3d *Mins, geVec3d *Maxs);</P>

<P>//=====================================================================================</P>
<P>//&#9;Function ProtoTypes</P>
<P>//=====================================================================================</P>

<P>&nbsp;</P>
<P>geBoolean Trace_GEWorldCollision(&#9;geWorld *World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const&#9;&#9;geVec3d *Mins, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const&#9;&#9;geVec3d *Maxs, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const&#9;&#9;geVec3d *Front, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const&#9;&#9;geVec3d *Back, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32&#9;&#9;Contents,&#9;&#9;&#9;// Contents to collide with</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32&#9;&#9;CollideFlags,&#9;&#9;// GE_COLLIDE_ALL, etc...</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32&#9;&#9;UserFlags,&#9;&#9;&#9;// Flags to mask against actors</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_CollisionCB *CollisionCB,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;void&#9;&#9;*Context,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_Collision *Col);</P>

<P>geBoolean Trace_WorldCollisionBNode(geWorld *World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *Front, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *Back, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 *ModelNum,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *Impact,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 *Node,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 *Plane,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 *Side);</P>

<P>geBoolean Trace_WorldCollisionExact(geWorld *World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Front, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Back, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 Flags, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *Impact,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GFX_Plane *Plane,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geWorld_Model **Model,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Mesh_RenderQ **Mesh,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geActor **Actor,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 UserFlags,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_CollisionCB *CollisionCB,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;void *Context);</P>

<P>// Internal only/ does not chek meshes/ returns index numbers into bsp structures for models</P>
<P>geBoolean Trace_WorldCollisionExact2(geWorld *World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Front, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Back, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *Impact,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 *Node,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 *Plane,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 *Side);</P>

<P>geBoolean Trace_MiscCollision(GFX_BNode *BNodes, GFX_Plane *Planes, const geVec3d *Mins, const geVec3d *Maxs, const geVec3d *Front, const geVec3d *Back, geXForm3d *XForm, geVec3d *I, GFX_Plane *P);</P>
<P>geBoolean Trace_MiscCollision2(GFX_BNode *BNodes, GFX_Plane *Planes, const geVec3d *Front, const geVec3d *Back, geVec3d *I, int32 *P);</P>

<P>geBoolean Trace_WorldCollisionBBox(&#9;geWorld&#9;*World,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Mins, const geVec3d *Maxs, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d *Front, const geVec3d *Back,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 Flags,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d *I, GFX_Plane *P,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geWorld_Model **Model,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Mesh_RenderQ **Mesh,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geActor **Actor,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 UserFlags,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_CollisionCB *CollisionCB,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;void *Context);</P>

<P>geBoolean Trace_TestModelMove(&#9;geWorld&#9;&#9;*World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geWorld_Model&#9;&#9;*Model, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d&#9;*DXForm, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d&#9;&#9;*Mins, const geVec3d *Maxs,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geVec3d&#9;&#9;*In, geVec3d *Out);</P>

<P>geBoolean Trace_ModelCollision(geWorld&#9;&#9;*World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geWorld_Model&#9;&#9;*Model, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;const geXForm3d&#9;*DXForm,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_Collision    *Collision,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//Mesh_RenderQ&#9;**ImpactedMesh,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geVec3d&#9;&#9;&#9;*ImpactPoint);</P>

<P>geBoolean Trace_InverseTreeFromBox(geVec3d *Mins, geVec3d *Maxs, GFX_BNode *BNodes, GFX_Plane *Planes);</P>

<P>geBoolean Trace_GetContents(geWorld *World, const geVec3d *Pos, const geVec3d *Mins, const geVec3d *Maxs, uint32 Flags, uint32 UserFlags, GE_CollisionCB *CollisionCB, void *Context, GE_Contents *Contents);</P>

<P>void Trace_GetMoveBox(const geVec3d *Mins, const geVec3d *Maxs, const geVec3d *Front, const geVec3d *Back, geVec3d *OMins, geVec3d *OMaxs);</P>

<P>void&#9;&#9;Trace_SetupIntersect(geWorld *World);</P>
<P>geBoolean&#9;Trace_IntersectWorldBSP(geVec3d *Front, geVec3d *Back, int32 Node);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070071">User.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  User.h                                                                              */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: User poly's                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_USER_H</P>
<P>#define GE_USER_H</P>

<P>#include &lt;Assert.h&gt;</P>
<P>#include &lt;Windows.h&gt;</P>

<P>#include "BaseType.h"</P>
<P>#include "Vec3d.h"</P>
<P>#include "XForm3d.h"</P>
<P>#include "Camera.h"</P>
<P>#include "Genesis.h"</P>
<P>#include "World.h"</P>
<P>#include "Surface.h"</P>

<P>#include "DCommon.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define MAX_USER_VERTS&#9;&#9;&#9;&#9;4&#9;&#9;&#9;</P>
<P>#define USER_MAX_SORTED_POLYS&#9;&#9;1024</P>

<P>//================================================================================</P>
<P>//&#9;Structure defines</P>
<P>//================================================================================</P>

<P>typedef struct&#9;gePoly</P>
<P>{</P>
<P>#ifdef _DEBUG</P>
<P>&#9;struct gePoly&#9;*Self1;</P>
<P>#endif</P>

<P>&#9;geWorld&#9;&#9;&#9;*World;</P>
<P>&#9;GE_LVertex&#9;&#9;Verts[MAX_USER_VERTS];&#9;// Copy of user verts&#9;&#9;&#9;&#9;&#9;</P>

<P>&#9;geWorld_Leaf&#9;*LeafData;</P>
<P>&#9;float&#9;&#9;&#9;ZOrder;</P>

<P>&#9;int32&#9;&#9;&#9;NumVerts;</P>

<P>&#9;geBitmap&#9;&#9;*Bitmap;</P>

<P>&#9;gePoly_Type&#9;&#9;Type;&#9;&#9;&#9;&#9;&#9;// Type of poly</P>
<P>&#9;int32&#9;&#9;&#9;RenderFlags;&#9;&#9;&#9;// Fx of poly</P>

<P>&#9;float&#9;&#9;&#9;Scale;&#9;&#9;&#9;&#9;&#9;// Currently only used for TexturedPoint</P>

<P>&#9;struct gePoly&#9;*Prev;</P>
<P>&#9;struct gePoly&#9;*Next;</P>

<P>&#9;struct gePoly&#9;*AddOnceNext;</P>

<P>#ifdef _DEBUG</P>
<P>&#9;struct gePoly&#9;*Self2;</P>
<P>#endif</P>
<P>} gePoly;</P>

<P>typedef struct User_Info</P>
<P>{</P>
<P>&#9;gePoly&#9;&#9;*AddPolyOnceList;</P>
<P>} User_Info;</P>

<P>//================================================================================</P>
<P>//&#9;Function ProtoTypes</P>
<P>//================================================================================</P>
<P>geBoolean&#9;User_EngineInit(geEngine *Engine);</P>
<P>void&#9;&#9;User_EngineShutdown(geEngine *Engine);</P>
<P>geBoolean&#9;User_WorldInit(geWorld *World);</P>
<P>void&#9;&#9;User_WorldShutdown(geWorld *World);</P>

<P>geBoolean User_RenderPolyList(gePoly *PolyList);</P>

<P>GENESISAPI&#9;gePoly *geWorld_AddPolyOnce(&#9;geWorld *World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_LVertex *Verts, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap *Bitmap,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;gePoly_Type Type, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 RenderFlags,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float Scale);</P>
<P>GENESISAPI&#9;gePoly *geWorld_AddPoly(&#9;geWorld *World, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GE_LVertex *Verts, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int32 NumVerts, </P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;geBitmap *Bitmap,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;gePoly_Type Type,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;uint32 RenderFlags,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float Scale);</P>

<P>GENESISAPI&#9;void geWorld_RemovePoly(geWorld *World, gePoly *Poly);</P>
<P>GENESISAPI&#9;geBoolean gePoly_GetLVertex(gePoly *Poly, int32 Index, GE_LVertex *LVert);</P>
<P>GENESISAPI&#9;geBoolean gePoly_SetLVertex(gePoly *Poly, int32 Index, const GE_LVertex *LVert);</P>

<P>geBoolean&#9;User_SetCameraInfo(geEngine *Engine, geWorld *World, geCamera *Camera, Frustum_Info *Fi);</P>
<P>geBoolean&#9;User_DestroyOncePolys(geWorld *World);</P>
<P>void&#9;&#9;User_DestroyPolyList(geWorld *World, gePoly *List);</P>

<P>void&#9;&#9;User_EngineFillRect(geEngine *Engine, const GE_Rect *Rect, const GE_RGBA *Color);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070072">Vis.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  Vis.h                                                                               */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Code to vis the world from a given pov                                 */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_VIS_H</P>
<P>#define GE_VIS_H</P>

<P>#include "Genesis.h"</P>
<P>#include "BaseType.h"</P>

<P>#include "Frustum.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//=====================================================================================</P>
<P>//&#9;Defines / Structure defines</P>
<P>//=====================================================================================</P>

<P>//=====================================================================================</P>
<P>//&#9;Function ProtoTypes</P>
<P>//=====================================================================================</P>
<P>geBoolean&#9;Vis_WorldInit(geWorld *World);</P>
<P>void&#9;&#9;Vis_WorldShutdown(geWorld *World);</P>

<P>geBoolean&#9;Vis_VisWorld(geEngine *Engine, geWorld *World, const geCamera *Camera, Frustum_Info *Fi);</P>

<P>geBoolean&#9;Vis_MarkWaterFaces(World_BSP *WBSP);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070073">WBitmap.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  WBitmap.h                                                                           */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Creates geBitmaps from the data in the BSP, that are used to render    */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef WBITMAP_H</P>
<P>#define WBITMAP_H</P>

<P>#include &lt;Assert.h&gt;</P>

<P>#include "BaseType.h"</P>
<P>#include "GBSPFile.h"</P>
<P>#include "Bitmap.h"</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>//==</P>
<P>// This stuff should really go in GBSPFile.h...</P>
<P>&#9;#define&#9;&#9;TEXTURE_SKYBOX&#9;&#9;&#9;&#9;(1&lt;&lt;0)&#9;&#9;&#9;&#9;// This is a skybox texture</P>

<P>&#9;//&#9;TexInfo Flags (Global shared info about each surface)</P>
<P>&#9;#define&#9;&#9;TEXINFO_MIRROR&#9;&#9;&#9;&#9;(1&lt;&lt;0)</P>
<P>&#9;#define&#9;&#9;TEXINFO_FULLBRIGHT&#9;&#9;&#9;(1&lt;&lt;1)&#9;&#9;&#9;&#9;// No lightmap/fullbright</P>
<P>&#9;#define&#9;&#9;TEXINFO_SKY&#9;&#9;&#9;&#9;&#9;(1&lt;&lt;2)&#9;&#9;&#9;&#9;// Sky face</P>
<P>&#9;#define&#9;&#9;TEXINFO_LIGHT&#9;&#9;&#9;&#9;(1&lt;&lt;3)&#9;&#9;&#9;&#9;// Face produces light</P>
<P>&#9;#define&#9;&#9;TEXINFO_TRANS&#9;&#9;&#9;&#9;(1&lt;&lt;4)&#9;&#9;&#9;&#9;// Face has transparency</P>
<P>&#9;#define&#9;&#9;TEXINFO_GOURAUD&#9;&#9;&#9;&#9;(1&lt;&lt;5)</P>
<P>&#9;#define&#9;&#9;TEXINFO_FLAT&#9;&#9;&#9;&#9;(1&lt;&lt;6)</P>
<P>&#9;#define&#9;&#9;TEXINFO_NO_LIGHTMAP&#9;&#9;&#9;(1&lt;&lt;15)</P>
<P>//==</P>

<P>//================================================================================</P>
<P>//&#9;#defs</P>
<P>//================================================================================</P>
<P>#define&#9;&#9;WBITMAP_SKYBOX&#9;&#9;&#9;&#9;(1&lt;&lt;0)&#9;&#9;&#9;&#9;// This is a skybox wbitmap</P>

<P>//================================================================================</P>
<P>//&#9;Structure defines</P>
<P>//================================================================================</P>
<P>typedef struct geWBitmap&#9;&#9;&#9;geWBitmap;</P>
<P>typedef struct geWBitmap_Pool&#9;&#9;geWBitmap_Pool;</P>

<P>//================================================================================</P>
<P>//&#9;Function defines</P>
<P>//================================================================================</P>
<P>geWBitmap_Pool *geWBitmap_Pool_Create(GBSP_BSPData *BSPData);</P>
<P>void geWBitmap_Pool_Destroy(geWBitmap_Pool *Pool);</P>
<P>int32 geWBitmap_Pool_GetWBitmapCount(geWBitmap_Pool *Pool);</P>
<P>geWBitmap *geWBitmap_Pool_GetWBitmapByBitmap(geWBitmap_Pool *Pool, const geBitmap *Bitmap);</P>
<P>geWBitmap *geWBitmap_Pool_GetWBitmapByIndex(geWBitmap_Pool *Pool, int32 Index);</P>
<P>geBitmap *geWBitmap_Pool_GetBitmapByIndex(geWBitmap_Pool *Pool, int32 Index);</P>
<P>geBitmap *geWBitmap_Pool_GetBitmapByName(geWBitmap_Pool *Pool, const char *BitmapName);</P>
<P>geBoolean geWBitmap_Pool_CreateAllWBitmaps(geWBitmap_Pool *Pool, GBSP_BSPData *BSPData);</P>
<P>void geWBitmap_Pool_DestroyAllWBitmaps(geWBitmap_Pool *Pool);</P>
<P>uint32 geWBitmap_GetFlags(geWBitmap *WBitmap);</P>
<P>geBitmap *geWBitmap_GetBitmap(geWBitmap *WBitmap);</P>
<P>int32 geWBitmap_GetVisFrame(geWBitmap *WBitmap);</P>
<P>geBoolean geWBitmap_SetVisFrame(geWBitmap *WBitmap, int32 VisFrame);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>

<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P><A NAME="_Toc454070074">World.h</A></P>
</B></I></FONT><FONT FACE="Arial" SIZE=2><P>/****************************************************************************************/</P>
<P>/*  World.h                                                                             */</P>
<P>/*                                                                                      */</P>
<P>/*  Author: John Pollard                                                                */</P>
<P>/*  Description: Code to render the world, and distribute work to other modules         */</P>
<P>/*                                                                                      */</P>
<P>/*  The contents of this file are subject to the Genesis3D Public License               */</P>
<P>/*  Version 1.01 (the "License"); you may not use this file except in                   */</P>
<P>/*  compliance with the License. You may obtain a copy of the License at                */</P>
<P>/*  http://www.genesis3d.com                                                            */</P>
<P>/*                                                                                      */</P>
<P>/*  Software distributed under the License is distributed on an "AS IS"                 */</P>
<P>/*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See                */</P>
<P>/*  the License for the specific language governing rights and limitations              */</P>
<P>/*  under the License.                                                                  */</P>
<P>/*                                                                                      */</P>
<P>/*  The Original Code is Genesis3D, released March 25, 1999.                            */</P>
<P>/*  Copyright (C) 1996-1999 Eclipse Entertainment, L.L.C. All Rights Reserved           */</P>
<P>/*                                                                                      */</P>
<P>/****************************************************************************************/</P>
<P>#ifndef GE_WORLD_H</P>
<P>#define GE_WORLD_H</P>

<P>#include "ErrorLog.h"</P>
<P>#include "PtrTypes.h"</P>
<P>#include "Genesis.h"</P>
<P>#include "GBSPFile.h"</P>
<P>#include "Motion.h"</P>
<P>#include "Surface.h"</P>
<P>#include "Fog.h"</P>
<P>#include "WBitmap.h"</P>
<P>#include "User.h"</P>
<P>#include "Light.h"</P>

<P>#include "Bitmaplist.h"</P>

<P>#include "Actor.h"&#9;&#9;&#9;</P>

<P>#ifdef __cplusplus</P>
<P>extern "C" {</P>
<P>#endif</P>

<P>#define MAX_MODELS&#9;256</P>

<P>// Upper limits on misc things</P>
<P>#define&#9;MAX_MIRROR_RECURSION&#9;&#9;1</P>
<P>#define MAX_RENDERFACE_VERTS&#9;&#9;64</P>

<P>//=====================================================================================</P>
<P>//&#9;Structure defines</P>
<P>//=====================================================================================</P>
<P>#define MODEL_CHANGED_XFORM&#9;&#9;&#9;&#9;(1&lt;&lt;0)</P>

<P>typedef struct geWorld_Model</P>
<P>{</P>
<P>&#9;char&#9;&#9;&#9;Name[64];&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Model's name</P>
<P>&#9;int32&#9;&#9;&#9;GFXModelNum;&#9;&#9;&#9;&#9;&#9;&#9;// Model number in disk tree structure</P>
<P>&#9;geXForm3d&#9;&#9;XForm;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Models transform&#9;(Object Space)</P>
<P>&#9;geVec3d&#9;&#9;&#9;Mins, Maxs;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Model BBox (World Space)</P>
<P>&#9;geVec3d&#9;&#9;&#9;TMins, TMaxs;&#9;&#9;&#9;&#9;&#9;&#9;// Translated Model BBox (World Space)</P>
<P>&#9;geVec3d&#9;&#9;&#9;Pivot;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Center of rotation (World Space)</P>
<P>&#9;geVec3d&#9;&#9;&#9;RealCenter;</P>
<P>&#9;int32&#9;&#9;&#9;VisFrame;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// == World-&gt;CurFrame if visible</P>
<P>&#9;void&#9;&#9;&#9;*UserData;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Place for client to store data</P>
<P>&#9;GFX_Model *&#9;&#9;BSPModel;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Oh, this is terrible.</P>

<P>&#9;geBoolean&#9;&#9;Open;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Model Open/Closed&#9;(Set by API, used for area vising)</P>

<P>&#9;uint32&#9;&#9;&#9;Flags;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// GE_MODEL_RENDER_NORMAL, etc... (getypes.h)</P>

<P>&#9;uint32&#9;&#9;&#9;ChangedFlags;</P>
<P>} geWorld_Model;</P>

<P>typedef struct geWorld_Leaf</P>
<P>{</P>
<P>&#9;int32&#9;&#9;&#9;VisFrame;</P>
<P>&#9;int32&#9;&#9;&#9;Parent;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Parent nodes of all leafs</P>

<P>&#9;gePoly&#9;&#9;&#9;*PolyList;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// List of poly fragments to render for this leaf (geWorld_AddPoly)</P>
<P>} geWorld_Leaf;</P>

<P>#define MAX_VISIBLE_FOG&#9;&#9;12&#9;// Hope to God there is not this much visible at a time!!!</P>

<P>// This is set in the UserData of the fog the the world creates at load time</P>
<P>typedef struct</P>
<P>{</P>
<P>&#9;int32&#9;&#9;&#9;Leaf;</P>

<P>&#9;geVec3d&#9;&#9;&#9;Mins;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// - Radius</P>
<P>&#9;geVec3d&#9;&#9;&#9;Maxs;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// + Radius</P>

<P>&#9;int32&#9;&#9;&#9;VisFrame;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// == World-&gt;CurFrameDynamic when visible</P>

<P>&#9;geWorld&#9;&#9;&#9;*World;</P>
<P>} geWorld_FogData;</P>

<P>typedef struct World_BSP</P>
<P>{</P>
<P>&#9;char&#9;&#9;&#9;FileName[200];</P>
<P>&#9;GBSP_BSPData&#9;BSPData;&#9;&#9;&#9;&#9;// Info in the BSP loaded directly off disk</P>

<P>&#9;//&#9;Extra info thats not in the disk bsp structure</P>
<P>&#9;Surf_SurfInfo&#9;*SurfInfo;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Valid when GE_SetGBSPFile is called</P>
<P>&#9;Surf_TexVert&#9;*TexVerts;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//</P>

<P>&#9;geWBitmap_Pool&#9;*WBitmapPool;</P>

<P>&#9;geWorld_Model&#9;Models[MAX_MODELS];&#9;&#9;&#9;&#9;&#9;// Extra info about models not in disk structure</P>

<P>&#9;geWorld_Leaf&#9;*LeafData;</P>

<P>&#9;int32&#9;&#9;&#9;*ClusterVisFrame;</P>
<P>&#9;int32&#9;&#9;&#9;*NodeVisFrame;</P>
<P>&#9;int32&#9;&#9;&#9;*AreaVisFrame;</P>
<P>&#9;uint8&#9;&#9;&#9;AreaConnections[256][256];</P>

<P>&#9;int32&#9;&#9;&#9;*NodeParents;&#9;&#9;&#9;&#9;&#9;&#9;// Parent nodes of all leafs</P>

<P>} World_BSP;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;// Untransformed original data</P>
<P>&#9;geVec3d&#9;&#9;&#9;Verts[6][4];</P>
<P>&#9;Surf_TexVert&#9;TexVerts[6][4];</P>
<P>&#9;</P>
<P>&#9;geVec3d&#9;&#9;&#9;Axis;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Rotation axis</P>
<P>&#9;float&#9;&#9;&#9;Dpm;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Degres per minute</P>
<P>&#9;float&#9;&#9;&#9;DrawScale;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Texture drawscale</P>
<P>&#9;int32&#9;&#9;&#9;Textures[6];</P>
<P>&#9;</P>
<P>&#9;float&#9;&#9;&#9;Angle;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Current rotation angle around roation axis</P>

<P>} World_SkyBox;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;// Transformed data</P>
<P>&#9;uint32&#9;&#9;&#9;SkyFlags;</P>

<P>&#9;geVec3d&#9;&#9;&#9;TransformedVecs[6][2];</P>
<P>&#9;GFX_Plane&#9;&#9;TransformedPlanes[6];</P>

<P>&#9;int32&#9;&#9;&#9;NumTransformed;&#9;&#9;&#9;&#9;&#9;&#9;// Num transformed and clipped</P>
<P>&#9;geVec3d&#9;&#9;&#9;TransformedVerts[6][10];&#9;&#9;&#9;// Transformed verts</P>
<P>&#9;Surf_TexVert&#9;TransformedTexVerts[6][10];&#9;&#9;&#9;// Transformed tex verts</P>
<P>&#9;int32&#9;&#9;&#9;NumTransformedVerts[6];&#9;&#9;&#9;&#9;// Number of transformed verts/texverts</P>
<P>&#9;int32&#9;&#9;&#9;OriginalFaces[6];&#9;&#9;&#9;&#9;&#9;// Indexes to original bitmap</P>

<P>} geWorld_SkyBoxTData;</P>

<P>typedef struct World_Actor</P>
<P>{</P>
<P>&#9;geActor&#9;&#9;&#9;*Actor;</P>
<P>&#9;uint32&#9;&#9;&#9;Flags;&#9;&#9;&#9;&#9;// GE_ACTOR_RENDER_NORMAL, GE_ACTOR_RENDER_MIRRORS, GE_ACTOR_COLLIDE</P>
<P>&#9;uint32&#9;&#9;&#9;UserFlags;</P>

<P>&#9;//int32&#9;&#9;&#9;Leaf;&#9;&#9;&#9;&#9;// Current leaf the actor is in (currently used for PVS occlusion)</P>
<P>} World_Actor;</P>

<P>/******</P>

<P>Critial : A negative-numbered Node is a Leaf.</P>
<P>&#9;Node (-1) is Leaf 0 ; (the first leaf is Leaf 0).</P>
<P>&#9;Node (-N) is Leaf (N-1) = (-Node-1)</P>

<P>******/</P>

<P>#define MAX_WORLD_ENT_CLASS_SETS&#9;256</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;const char&#9;&#9;&#9;*ClassName;&#9;&#9;// NULL for main set</P>
<P>&#9;geEntity_EntitySet&#9;*Set;</P>
<P>} geWorld_EntClassSet;</P>

<P>typedef struct</P>
<P>{</P>
<P>&#9;int32&#9;&#9;NumNodesTraversed1;</P>
<P>&#9;int32&#9;&#9;NumNodesTraversed2;</P>
<P>&#9;int32&#9;&#9;NumLeafsHit1;</P>
<P>&#9;int32&#9;&#9;NumLeafsHit2;</P>
<P>&#9;int32&#9;&#9;NumLeafsWithUserPolys;</P>
<P>&#9;int32&#9;&#9;NumUserPolys;</P>

<P>} geWorld_DebugInfo;</P>

<P>typedef struct geWorld</P>
<P>{</P>
<P>&#9;int32&#9;&#9;&#9;&#9;CurFrameStatic;&#9;&#9;&#9;&#9;&#9;&#9;// World CurrentFrame</P>
<P>&#9;int32&#9;&#9;&#9;&#9;CurFrameDynamic;&#9;&#9;&#9;&#9;&#9;// World CurrentFrame</P>
<P>&#9;float&#9;&#9;&#9;&#9;CurTime;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// World CurrentTime</P>
<P>&#9;int32&#9;&#9;&#9;&#9;CurrentLeaf;</P>
<P>&#9;geBoolean&#9;&#9;&#9;ForceVis;</P>

<P>&#9;geBoolean&#9;&#9;&#9;VisInfo;</P>

<P>&#9;// Info that each respective module fills in...</P>
<P>&#9;World_BSP&#9;&#9;&#9;*CurrentBSP;&#9;&#9;&#9;&#9;&#9;&#9;// Valid when geWorld_SetGBSP is called</P>

<P>&#9;World_SkyBox&#9;&#9;SkyBox;</P>

<P>&#9;Frustum_Info&#9;&#9;*FrustumInfo;</P>

<P>&#9;Light_LightInfo&#9;&#9;*LightInfo;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Info that the light module fills in</P>

<P>&#9;Mesh_MeshInfo&#9;&#9;*MeshInfo;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Info that the mesh module fills in</P>
<P>&#9;</P>
<P>&#9;int32&#9;&#9;&#9;&#9;ActorCount;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Number of actors in world</P>
<P>&#9;World_Actor&#9;&#9;&#9;*ActorArray;&#9;&#9;&#9;&#9;&#9;&#9;// Array of actors</P>
<P>&#9;</P>
<P>&#9;geWorld_EntClassSet&#9;EntClassSets[MAX_WORLD_ENT_CLASS_SETS];</P>
<P>&#9;int32&#9;&#9;&#9;&#9;NumEntClassSets;</P>

<P>&#9;User_Info&#9;&#9;&#9;*UserInfo;</P>

<P>&#9;// Debug info</P>
<P>&#9;int32&#9;&#9;&#9;&#9;ActiveUserPolys;</P>
<P>&#9;geWorld_DebugInfo&#9;DebugInfo;</P>

<P>&#9;geFog&#9;&#9;&#9;&#9;*FogList;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Linked list of fog in the world currently</P>
<P>&#9;</P>
<P>&#9;geFog&#9;&#9;&#9;&#9;*VisibleFog[MAX_VISIBLE_FOG];&#9;&#9;// List of visible fog for this frame</P>
<P>&#9;int32&#9;&#9;&#9;&#9;NumVisibleFog;</P>

<P>&#9;BitmapList&#9;&#9;&#9;*AttachedBitmaps;&#9;&#9;&#9;&#9;&#9;&#9;</P>

<P>&#9;geXForm3d&#9;&#9;&#9;LastCameraXForm;</P>

<P>&#9;int32&#9;&#9;&#9;&#9;RefCount;</P>

<P>&#9;geBoolean&#9;&#9;&#9;Changed;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// GE_TRUE if this world has changed</P>

<P>} geWorld;</P>

<P>//=====================================================================================</P>
<P>//&#9;Function prototypes</P>
<P>//=====================================================================================</P>
<P>GENESISAPI&#9;&#9;geWorld *geWorld_Create(geVFile *File);</P>
<P>GENESISAPI&#9;&#9;void geWorld_Free(geWorld *World);</P>
<P>geBoolean&#9;&#9;geWorld_CreateRef(geWorld *World);</P>

<P>geBoolean&#9;World_EngineInit(geEngine *Engine);</P>
<P>void&#9;&#9;World_EngineShutdown(geEngine *Engine);</P>

<P>geBoolean&#9;World_SetEngine(geEngine *Engine);</P>
<P>geBoolean&#9;World_SetWorld(geWorld *World);</P>
<P>geBoolean&#9;World_SetGBSP(World_BSP *BSP);</P>

<P>geBoolean&#9;World_WorldRenderQ(geEngine *Engine, geWorld *World, geCamera *Camera);</P>

<P>GENESISAPI geBoolean geWorld_SetModelXForm(</P>
<P>&#9;geWorld *&#9;&#9;&#9;World,</P>
<P>&#9;geWorld_Model *&#9;&#9;Model,</P>
<P>&#9;const geXForm3d *&#9;XForm);</P>
<P>GENESISAPI geBoolean geWorld_GetModelXForm(</P>
<P>&#9;const geWorld *&#9;&#9;&#9;World,</P>
<P>&#9;const geWorld_Model *&#9;Model,</P>
<P>&#9;geXForm3d *&#9;&#9;&#9;&#9;XForm);</P>

<P>GENESISAPI geBoolean geWorld_GetModelRotationalCenter(</P>
<P>&#9;const geWorld *&#9;&#9;&#9;World,</P>
<P>&#9;const geWorld_Model *&#9;Model,</P>
<P>&#9;geVec3d *&#9;&#9;&#9;&#9;Center);</P>

<P>GENESISAPI geMotion * geWorld_ModelGetMotion(geWorld_Model *Model);</P>

<P>GENESISAPI void * geWorld_ModelGetUserData(const geWorld_Model *Model);</P>

<P>GENESISAPI void&#9;geWorld_ModelSetUserData(geWorld_Model *Model, void *UserData);</P>

<P>GENESISAPI geWorld_Model *geWorld_WorldGetNextModel(geWorld *World, geWorld_Model *Start);</P>

<P>GENESISAPI geBoolean geWorld_AddBitmap(geWorld *World, geBitmap *Bitmap);</P>
<P>GENESISAPI geBoolean geWorld_RemoveBitmap(geWorld *World,geBitmap *Bitmap);</P>

<P>GENESISAPI geBitmap *geWorld_GetBitmapByName(geWorld *World, const char *BitmapName);</P>

<P>geBoolean geWorld_AttachAll(geWorld *World, DRV_Driver *Driver, geFloat Gamma);</P>
<P>geBoolean geWorld_DetachAll(geWorld *World);</P>

<P>#ifdef __cplusplus</P>
<P>}</P>
<P>#endif</P>
<P>#endif</P>
</FONT><B><I><FONT FACE="Arial Black" SIZE=4><P></A></P></B></I></FONT></BODY>
</HTML>
